<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog of Saul</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-09T12:59:37.494Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Saul</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Typescript(1):Class</title>
    <link href="http://yoursite.com/2019/03/09/Typescript-1-Class/"/>
    <id>http://yoursite.com/2019/03/09/Typescript-1-Class/</id>
    <published>2019-03-09T01:50:28.000Z</published>
    <updated>2019-03-09T12:59:37.494Z</updated>
    
    <content type="html"><![CDATA[<h3 id="结构型类型系统"><a href="#结构型类型系统" class="headerlink" title="结构型类型系统"></a>结构型类型系统</h3><p>ts中，一般情况下当我们比较两种类型时，我们实际比较的是<strong>类型的结构</strong>，即对比他们的成员类型是否都是兼容的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Food &#123;</div><div class="line">    name:<span class="built_in">string</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">foodName:<span class="built_in">string</span></span>)&#123;</div><div class="line">        <span class="keyword">this</span>.name = foodName;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Cake <span class="keyword">extends</span> Food&#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> FoodModel &#123;</div><div class="line">    name:<span class="built_in">string</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">foodName:<span class="built_in">string</span></span>)&#123;</div><div class="line">        <span class="keyword">this</span>.name = foodName;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//Food可以赋值给FoodModel</span></div><div class="line"><span class="keyword">let</span> model:FoodModel = <span class="keyword">new</span> FoodModel(<span class="string">'cake'</span>);</div><div class="line">model = <span class="keyword">new</span> Food(<span class="string">'cake'</span>);</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="private和protected"><a href="#private和protected" class="headerlink" title="private和protected"></a>private和protected</h3><p>然而当类的成员带有private和protected修饰符时情况就变得不对了，<strong>如果其中一个类型里包含一个<code>private</code>成员，那么只有当另外一个类型中也存在这样一个 <code>private</code>成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于 <code>protected</code>成员也使用这个规则。</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Food &#123;</div><div class="line">    <span class="keyword">private</span> name:<span class="built_in">string</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">foodName:<span class="built_in">string</span></span>)&#123;</div><div class="line">        <span class="keyword">this</span>.name = foodName;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Cake <span class="keyword">extends</span> Food&#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> FoodModel &#123;</div><div class="line">    <span class="keyword">private</span> name:<span class="built_in">string</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">foodName:<span class="built_in">string</span></span>)&#123;</div><div class="line">        <span class="keyword">this</span>.name = foodName;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> model:FoodModel = <span class="keyword">new</span> FoodModel(<span class="string">'cake'</span>);</div><div class="line"><span class="comment">//报错，类型不兼容</span></div><div class="line">model = <span class="keyword">new</span> Food(<span class="string">'cake'</span>);</div></pre></td></tr></table></figure>
<p>如果父类声明了一个private的成员，那么它的派生类不能再声明一个相同private成员</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Food &#123;</div><div class="line">    <span class="keyword">private</span> name:<span class="built_in">string</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">foodName:<span class="built_in">string</span></span>)&#123;</div><div class="line">        <span class="keyword">this</span>.name = foodName;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Cake <span class="keyword">extends</span> Food&#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">//报错，private的成员name不能分别定义</span></div><div class="line"><span class="keyword">class</span> FoodModel <span class="keyword">extends</span> Food&#123;</div><div class="line">    <span class="keyword">private</span> name:<span class="built_in">string</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">foodName:<span class="built_in">string</span></span>)&#123;</div><div class="line">        <span class="keyword">super</span>(foodName);</div><div class="line">        <span class="keyword">this</span>.name = foodName;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>事实上子类不能重新定义一个父类已经有的同名成员为private：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Food &#123;</div><div class="line">    name:<span class="built_in">string</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">foodName:<span class="built_in">string</span></span>)&#123;</div><div class="line">        <span class="keyword">this</span>.name = foodName;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//报错，父类有name但是不是private</span></div><div class="line"><span class="keyword">class</span> FoodModel <span class="keyword">extends</span> Food&#123;</div><div class="line">    <span class="keyword">private</span> name:<span class="built_in">string</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">foodName:<span class="built_in">string</span></span>)&#123;</div><div class="line">        <span class="keyword">super</span>(foodName);</div><div class="line">        <span class="keyword">this</span>.name = foodName;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>protected类型则不然</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Food &#123;</div><div class="line">    <span class="keyword">protected</span> name:<span class="built_in">string</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">foodName:<span class="built_in">string</span></span>)&#123;</div><div class="line">        <span class="keyword">this</span>.name = foodName;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> FoodModel <span class="keyword">extends</span> Food&#123;</div><div class="line">    <span class="keyword">protected</span> name:<span class="built_in">string</span>;</div><div class="line">    <span class="comment">//public name:string; 这样也可以</span></div><div class="line">    <span class="keyword">constructor</span>(<span class="params">foodName:<span class="built_in">string</span></span>)&#123;</div><div class="line">        <span class="keyword">super</span>(foodName);</div><div class="line">        <span class="keyword">this</span>.name = foodName;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="语法特性"><a href="#语法特性" class="headerlink" title="语法特性"></a>语法特性</h2><h3 id="属性参数"><a href="#属性参数" class="headerlink" title="属性参数"></a>属性参数</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Person &#123;</div><div class="line">    name:<span class="built_in">string</span>;</div><div class="line">    age:<span class="built_in">number</span>;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的写法是我们之前见过的一个类的声明，其实我们并不需要在类的块里声明变量，然后在构造器中赋值，我们有更简单的写法，这就是属性赋值，<strong>我们可以在构造函数的参数前加上修饰符(private,public,protected,readonly)</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Person &#123;</div><div class="line">    <span class="comment">//不加修饰符的变量不会被声明为成员</span></div><div class="line">    <span class="comment">//constructor(name: string, age: number) &#123;</span></div><div class="line">    <span class="comment">//&#125;</span></div><div class="line">    </div><div class="line">    <span class="comment">//效果等同于上面的声明</span></div><div class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span>,<span class="keyword">public</span> age: <span class="built_in">number</span></span>) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> person:Person = <span class="keyword">new</span> Person(<span class="string">'sd'</span>,<span class="number">1</span>);</div><div class="line">person.name;</div></pre></td></tr></table></figure>
<h3 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h3><p>声明getter/setter方法，对于protected和private成员变量我们可能需要为其设置get/set方法，在ts中如果一个成员变量有get方法而没有set方法则默认会把它设置成readonly变量。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Panda &#123;</div><div class="line">    <span class="keyword">private</span> _weight:<span class="built_in">number</span>;</div><div class="line">    <span class="keyword">private</span> _age:<span class="built_in">number</span>;</div><div class="line"></div><div class="line">    <span class="keyword">get</span> weight(): <span class="built_in">number</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._weight;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">get</span> age(): <span class="built_in">number</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">set</span> age(value: <span class="built_in">number</span>) &#123;</div><div class="line">        <span class="keyword">this</span>._age = value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="编译后的类声明"><a href="#编译后的类声明" class="headerlink" title="编译后的类声明"></a>编译后的类声明</h2><p>ts最终会编译成浏览器可以执行的js文件，比如我们声明了以下这个类</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Person &#123;</div><div class="line">    <span class="keyword">static</span> count:<span class="built_in">number</span> = <span class="number">0</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span>,<span class="keyword">public</span> age: <span class="built_in">number</span></span>) &#123;</div><div class="line">    &#125;</div><div class="line">    sayHello()&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;this.name&#125;</span> hello!`</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//最终编译后的效果</span></div><div class="line"><span class="keyword">var</span> Person = <span class="comment">/** @class */</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line">    Person.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">"+hello"</span>);</div><div class="line">    &#125;;</div><div class="line">    Person.count = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> Person;</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<p>可以看到Person被赋值成为了构造函数，我们也可以清晰的看到在闭包中声明的类的静态部分和实例部分。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//output: function</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Person);</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;结构型类型系统&quot;&gt;&lt;a href=&quot;#结构型类型系统&quot; class=&quot;headerlink&quot; title=&quot;结构型类型系统&quot;&gt;&lt;/a&gt;结构型类型系统&lt;/h3&gt;&lt;p&gt;ts中，一般情况下当我们比较两种类型时，我们实际比较的是&lt;strong&gt;类型的结构&lt;/strong&gt;，即对比他们的成员类型是否都是兼容的。&lt;/p&gt;
&lt;figure class=&quot;highlight typescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; Food &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    name:&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;foodName:&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;&lt;/span&gt;)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = foodName;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; Cake &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; Food&amp;#123;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; FoodModel &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    name:&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;foodName:&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;&lt;/span&gt;)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = foodName;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//Food可以赋值给FoodModel&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; model:FoodModel = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; FoodModel(&lt;span class=&quot;string&quot;&gt;&#39;cake&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;model = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Food(&lt;span class=&quot;string&quot;&gt;&#39;cake&#39;&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="typescript" scheme="http://yoursite.com/tags/typescript/"/>
    
      <category term="study notes" scheme="http://yoursite.com/tags/study-notes/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript(0):Interface</title>
    <link href="http://yoursite.com/2019/03/08/TypeScript-0-Interface/"/>
    <id>http://yoursite.com/2019/03/08/TypeScript-0-Interface/</id>
    <published>2019-03-08T06:09:47.000Z</published>
    <updated>2019-03-08T15:59:16.863Z</updated>
    
    <content type="html"><![CDATA[<h2 id="接口如何工作？"><a href="#接口如何工作？" class="headerlink" title="接口如何工作？"></a>接口如何工作？</h2><p>下面我们声明了一个函数，它接受一个{color:string}类型的对象，那么在ts编译期间编译器如何来验证我们传入对象符合我们给定的类型呢？</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params">shape:&#123;color:<span class="built_in">string</span>&#125;</span>)</span>&#123;</div><div class="line">   <span class="built_in">console</span>.log(<span class="string">`I am a <span class="subst">$&#123;shape.color&#125;</span> shape`</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上ts的类型检查针对以下三点：</p>
<p>1.必须属性是否存在</p>
<p>2.类型是否匹配</p>
<p>3.对于字面量对象还会有多余的属性检查</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//报错，类型检查失败，多了一个length属性, （对于字面量还会检查是否存在不必要的属性）</span></div><div class="line">draw(&#123;color: <span class="string">'red'</span>, length: <span class="number">1</span>&#125;);</div><div class="line"></div><div class="line"><span class="comment">//类型检查成功，使用变量来跳过对字面量多余属性的检查</span></div><div class="line"><span class="keyword">let</span> shape = &#123;color: <span class="string">'red'</span>, length: <span class="number">1</span>&#125;;</div><div class="line">draw(shape);</div><div class="line"></div><div class="line"><span class="comment">//报错， 没有必要的属性</span></div><div class="line"><span class="keyword">let</span> secondShape = &#123; length: <span class="number">1</span>&#125;;</div><div class="line">draw(secondShape);</div><div class="line"></div><div class="line"><span class="comment">// Ok!</span></div><div class="line">draw(&#123;color:<span class="string">'red'</span>&#125;);</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h2><p>如果属性不是必须的我们可以把它声明为可选属性</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Shape &#123;</div><div class="line">    color?:<span class="built_in">string</span>;</div><div class="line">    id?:<span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">enhancedDraw</span>(<span class="params">shape:Shape</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`I am a <span class="subst">$&#123;shape.color&#125;</span> shape, my id is <span class="subst">$&#123;shape.id&#125;</span>`</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//Ok！</span></div><div class="line">enhancedDraw(&#123;&#125;);</div><div class="line">enhancedDraw(&#123;color:<span class="string">'red'</span>&#125;);</div><div class="line">enhancedDraw(&#123;id:<span class="number">1</span>&#125;);</div></pre></td></tr></table></figure>
<h2 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h2><p>一个常用的操作是设置把属性设置为只读的，ts里面也迎合了这种需求</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//只读属性</span></div><div class="line"><span class="keyword">interface</span> Circle &#123;</div><div class="line">    readonly radius:<span class="built_in">number</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不过如果我们声明一类实现该接口，类中必须强制声明一个叫做radius的属性，但是不需要它是只读的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> RedCircle <span class="keyword">implements</span> Circle&#123;</div><div class="line">    radiu: <span class="built_in">number</span>;<span class="comment">//报错，没有声明radius</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> RedCircle <span class="keyword">implements</span> Circle&#123;</div><div class="line">    radius: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//ok</span></div><div class="line"><span class="keyword">let</span> rc = <span class="keyword">new</span> RedCircle()</div><div class="line">rc.radius = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="comment">//Error!不能修改只读属性</span></div><div class="line"><span class="keyword">let</span> c:Circle = <span class="keyword">new</span> RedCircle()</div><div class="line">c.radius = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> circle:Circle = &#123;radius:<span class="number">1</span>&#125;;</div><div class="line"><span class="comment">//报错，不能修改只读的属性</span></div><div class="line">circle.radius = <span class="number">1</span>;</div></pre></td></tr></table></figure>
<h3 id="不可变数组"><a href="#不可变数组" class="headerlink" title="不可变数组"></a>不可变数组</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//不可变数组</span></div><div class="line"><span class="keyword">let</span> readOnlyArr:ReadonlyArray&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</div><div class="line"><span class="comment">//指针可变</span></div><div class="line">readOnlyArr = readOnlyArr.concat([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</div><div class="line"></div><div class="line"><span class="comment">//报错不能，把不可变数组赋值给普通数组</span></div><div class="line"><span class="keyword">let</span> read:<span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = readOnlyArr;</div><div class="line"></div><div class="line"><span class="comment">//Ok 类型断言</span></div><div class="line"><span class="keyword">let</span> read:<span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = readOnlyArr <span class="keyword">as</span> ReadonlyArray&lt;<span class="built_in">number</span>&gt;;</div></pre></td></tr></table></figure>
<h2 id="额外的属性检查"><a href="#额外的属性检查" class="headerlink" title="额外的属性检查"></a>额外的属性检查</h2><p>对象字面量会被特殊对待，即经过额外的属性检测：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。</div></pre></td></tr></table></figure>
<p>这一点我们已经在本文的第一节中验证过了：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extractPropsCheck</span>(<span class="params">squre:&#123;color: <span class="built_in">string</span>&#125;</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(squre.color);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 报错，特殊类型检验</span></div><div class="line">extractPropsCheck(&#123;color:<span class="string">'green'</span>, id:<span class="number">1</span>&#125;)</div></pre></td></tr></table></figure>
<p>如何绕开额外的类型检测？</p>
<p>1.类型断言：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">extractPropsCheck(&#123;color:<span class="string">'green'</span>, id:<span class="number">1</span>&#125; <span class="keyword">as</span> &#123;color:<span class="built_in">string</span>&#125;);</div></pre></td></tr></table></figure>
<p>2.赋值给一个变量(使字面量变量化)</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;color:<span class="string">'green'</span>, id:<span class="number">1</span>&#125;;</div><div class="line">extractPropsCheck(obj);</div></pre></td></tr></table></figure>
<p>3.最佳方式添加一个字符串索引签名：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> EnhancedSquare &#123;</div><div class="line">    color:<span class="built_in">string</span>;</div><div class="line">    side?:<span class="built_in">number</span>;</div><div class="line">    [props:<span class="built_in">string</span>]:<span class="built_in">any</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">enhancedExtractPropsCheck</span>(<span class="params">enhancedSquare:EnhancedSquare</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(enhancedSquare.color);</div><div class="line">    <span class="built_in">console</span>.log(enhancedSquare.side);</div><div class="line">&#125;</div><div class="line"></div><div class="line">enhancedExtractPropsCheck(&#123;color: <span class="string">'red'</span>, width: <span class="number">1</span>, height: <span class="number">2</span>&#125;);</div></pre></td></tr></table></figure>
<h2 id="使用接口来描述函数类型"><a href="#使用接口来描述函数类型" class="headerlink" title="使用接口来描述函数类型"></a>使用接口来描述函数类型</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用接口来描述函数类型</span></div><div class="line"><span class="keyword">interface</span> plusOperator &#123;</div><div class="line">    (a: <span class="built_in">number</span>, b: <span class="built_in">number</span>): <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> op: plusOperator = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</div><div class="line">op = <span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> a + b;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h2><p>索引签名描述了对象的索引类型还有相应的索引的返回值类型</p>
<p>ts支持的索引签名有<strong>字符串和数字</strong></p>
<h3 id="数字索引"><a href="#数字索引" class="headerlink" title="数字索引"></a>数字索引</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//利用索引类型声明一种boolean数组</span></div><div class="line"><span class="keyword">interface</span> BooleanArray &#123;</div><div class="line">    [props:<span class="built_in">number</span>]:<span class="built_in">boolean</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> boolArr:BooleanArray = [<span class="literal">false</span>,<span class="literal">true</span>];</div><div class="line"><span class="keyword">let</span> b:<span class="built_in">boolean</span> = boolArr[<span class="number">0</span>];</div></pre></td></tr></table></figure>
<h3 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h3><p>字符串索引签名会确保所有属性与其返回值类型相匹配</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> IDEs &#123;</div><div class="line">    eclipse:<span class="built_in">string</span>;</div><div class="line">    vs:<span class="built_in">string</span>;</div><div class="line">    idea:<span class="built_in">string</span>;</div><div class="line">    [others:<span class="built_in">string</span>]:<span class="built_in">string</span>;</div><div class="line">    <span class="comment">//报错，不是string类型</span></div><div class="line">    <span class="comment">// myeclipase:number;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="混合索引"><a href="#混合索引" class="headerlink" title="混合索引"></a>混合索引</h3><p>我们可以同时使用数字和字符串两种索引类型，但是<strong>数字索引的返回值必须是字符串索引返回值的子类型</strong>，这种限制产生的原因是用number来进行索引时，js会将其转化为string在去索引对象。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Animal &#123;</div><div class="line">    sound:<span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Tiger <span class="keyword">extends</span> Animal&#123;</div><div class="line">    attackPower:<span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">interface</span> Zoo &#123;</div><div class="line">    [someThing:<span class="built_in">number</span>]:Tiger;</div><div class="line">    [ceatainThing:<span class="built_in">string</span>]:Animal;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//报错，数字索引的返回值必须是字符串索引返回值的子类型</span></div><div class="line"><span class="comment">// interface Zoo &#123;</span></div><div class="line"><span class="comment">//     [someThing:number]:Animal;</span></div><div class="line"><span class="comment">//     [ceatainThing:string]:Tiger;</span></div><div class="line"><span class="comment">// &#125;</span></div></pre></td></tr></table></figure>
<h3 id="只读的索引签名"><a href="#只读的索引签名" class="headerlink" title="只读的索引签名"></a>只读的索引签名</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//只读的索引签名</span></div><div class="line"><span class="keyword">interface</span> ReadonlyBooleanMap &#123;</div><div class="line">    readonly [key:<span class="built_in">string</span>]:<span class="built_in">boolean</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> osSupportMap:ReadonlyBooleanMap = &#123;</div><div class="line">    windows: <span class="literal">false</span>,</div><div class="line">    linux: <span class="literal">true</span>,</div><div class="line">    unix: <span class="literal">false</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 报错，只读索引的指向不能被改变</span></div><div class="line"><span class="comment">// osSupportMap['windows'] = true;</span></div></pre></td></tr></table></figure>
<h3 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h3><p>有时我们希望一个对象可以同时作为函数和对象使用</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Counter &#123;</div><div class="line">    (start: <span class="built_in">number</span>): <span class="built_in">string</span>;</div><div class="line">    interval: <span class="built_in">number</span>;</div><div class="line">    reset(): <span class="built_in">void</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>): <span class="title">Counter</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> counter = &lt;Counter&gt;<span class="function"><span class="keyword">function</span> (<span class="params">start: <span class="built_in">number</span></span>) </span>&#123; &#125;;</div><div class="line">    counter.interval = <span class="number">123</span>;</div><div class="line">    counter.reset = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;;</div><div class="line">    <span class="keyword">return</span> counter;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> c = getCounter();</div><div class="line">c(<span class="number">10</span>);</div><div class="line">c.reset();</div><div class="line">c.interval = <span class="number">5.0</span>;</div></pre></td></tr></table></figure>
<h3 id="接口集成类"><a href="#接口集成类" class="headerlink" title="接口集成类"></a>接口集成类</h3><p>接口可以继承一个类，此时接口将包括这个类所有成员的声明，不管他们的访问域如何！</p>
<p><strong>如果一个接口继承了一个有private或者protected成员的类，那么该接口类型只能被这个类或者其子类实现</strong>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Control &#123;</div><div class="line">    <span class="keyword">private</span> state: <span class="built_in">any</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">interface</span> SelectableControl <span class="keyword">extends</span> Control &#123;</div><div class="line">    select(): <span class="built_in">void</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Button <span class="keyword">extends</span> Control <span class="keyword">implements</span> SelectableControl &#123;</div><div class="line">    select() &#123; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> TextBox <span class="keyword">extends</span> Control &#123;</div><div class="line">    select() &#123; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 错误：“Image”类型缺少“state”属性。</span></div><div class="line"><span class="keyword">class</span> Image <span class="keyword">implements</span> SelectableControl &#123;</div><div class="line">    select() &#123; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Location &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;接口如何工作？&quot;&gt;&lt;a href=&quot;#接口如何工作？&quot; class=&quot;headerlink&quot; title=&quot;接口如何工作？&quot;&gt;&lt;/a&gt;接口如何工作？&lt;/h2&gt;&lt;p&gt;下面我们声明了一个函数，它接受一个{color:string}类型的对象，那么在ts编译期间编译器如何来验证我们传入对象符合我们给定的类型呢？&lt;/p&gt;
&lt;figure class=&quot;highlight typescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;draw&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;shape:&amp;#123;color:&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;&amp;#125;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;`I am a &lt;span class=&quot;subst&quot;&gt;$&amp;#123;shape.color&amp;#125;&lt;/span&gt; shape`&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;实际上ts的类型检查针对以下三点：&lt;/p&gt;
&lt;p&gt;1.必须属性是否存在&lt;/p&gt;
&lt;p&gt;2.类型是否匹配&lt;/p&gt;
&lt;p&gt;3.对于字面量对象还会有多余的属性检查&lt;/p&gt;
&lt;figure class=&quot;highlight typescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//报错，类型检查失败，多了一个length属性, （对于字面量还会检查是否存在不必要的属性）&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;draw(&amp;#123;color: &lt;span class=&quot;string&quot;&gt;&#39;red&#39;&lt;/span&gt;, length: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//类型检查成功，使用变量来跳过对字面量多余属性的检查&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; shape = &amp;#123;color: &lt;span class=&quot;string&quot;&gt;&#39;red&#39;&lt;/span&gt;, length: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;draw(shape);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//报错， 没有必要的属性&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; secondShape = &amp;#123; length: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;draw(secondShape);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Ok!&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;draw(&amp;#123;color:&lt;span class=&quot;string&quot;&gt;&#39;red&#39;&lt;/span&gt;&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="typescript" scheme="http://yoursite.com/tags/typescript/"/>
    
      <category term="study notes" scheme="http://yoursite.com/tags/study-notes/"/>
    
  </entry>
  
  <entry>
    <title>ElasticSearch(1):Base knowledge</title>
    <link href="http://yoursite.com/2018/11/18/ElasticSearch-1-Base-knowledge/"/>
    <id>http://yoursite.com/2018/11/18/ElasticSearch-1-Base-knowledge/</id>
    <published>2018-11-18T12:34:06.000Z</published>
    <updated>2019-03-07T14:01:51.954Z</updated>
    
    <content type="html"><![CDATA[<p>es是一个开源搜索引擎，其建立在,lucene上提供了一系列非常直观好用的restful api接口，以及分布式方案，用es的这些提供物，你不在需要写一个java程序去访问lucene，你也不再需要依赖其他的集群方案去建立并思考如何管理一个lucene集群，es是一套非常优秀的拿来即用的工具，一个天生的分布式的软件。</p>
<a id="more"></a>
<h2 id="es集群的简单介绍"><a href="#es集群的简单介绍" class="headerlink" title="es集群的简单介绍"></a>es集群的简单介绍</h2><p>一个运行中的es实例，即是一个节点，es集群由多个cluster.name相同的节点组合而成，<strong>es集群一旦得知新节点的加入或者旧节点被移除，就会重新平均分配节点中的所有数据</strong>。</p>
<p>一个es集群会选举产生<strong>主节点</strong>，<strong>主节点负责管理集群范围内所有的变更</strong>，如增删索引或者节点，但是主节点<strong>不负责文档级别的变更或者搜索</strong>，这个特性使得对文档的变更和搜索的性能不是由主节点的数量或者性能来决定的。</p>
<p>es集群中<strong>任何节点都知道任意文档所处的位置</strong>，它们能够将我们的实际请求转发到存储我们的目标文档的节点上，所以我们不关心我们的请求发到的是哪个节点，因为任何节点都能给予我们正确的响应。</p>
<p>一个简单而重要的es api是查看集群的当前的健康状况</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//GET _cluster/health</div><div class="line"></div><div class="line">&#123;</div><div class="line">  "cluster_name": "docker-cluster",</div><div class="line">  "status": "yellow",</div><div class="line">  "timed_out": false,</div><div class="line">  "number_of_nodes": 1,</div><div class="line">  "number_of_data_nodes": 1,</div><div class="line">  "active_primary_shards": 21,</div><div class="line">  "active_shards": 21,</div><div class="line">  "relocating_shards": 0,</div><div class="line">  "initializing_shards": 0,</div><div class="line">  "unassigned_shards": 20,</div><div class="line">  "delayed_unassigned_shards": 0,</div><div class="line">  "number_of_pending_tasks": 0,</div><div class="line">  "number_of_in_flight_fetch": 0,</div><div class="line">  "task_max_waiting_in_queue_millis": 0,</div><div class="line">  "active_shards_percent_as_number": 51.21951219512195</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到我的es集群的状态是yellow，这表示所有<strong>主分片</strong>都正常运行但是<strong>副本分片</strong>却存在没有正常运行的情况，一般来说这里是应该是green,即主分片和副本分片都正常运行，而如果是red则代表了有主分片没有正常运行。</p>
<p>我们的es集群状态为yellow是因为我们只有一个节点，这意味着所有的主分片和副本分片都在同一个节点上，这表示我们的副本毫无意义，因为这个节点挂了，主副数据都挂了，完全只是浪费空间，所以是黄色，unassigned_shards为20说明了这一点。</p>
<p>要了解<strong>分片</strong>是什么，首先我们想要知道索引，索引是在es中保存相关数据的地方，实际上它是<strong>指向对个物理分片的逻辑命名空间</strong>，而一个分片则是一个底层的工作单元，一个分片实际上就是一个lucene实例，因此本身就是一个完整的搜索引擎，我们的文档被存储和索引到分片内，然而外部的应用并不关心分片这个东西，我们直接与索引打交道。<strong>分片只是数据的容器，而它们被分散在集群中的各个节点里</strong>，一旦集群规模发生改变，es会迁移各节点中的分片，使得数据仍然均匀的分布在集群中。</p>
<p>从细节上来说，主分片的数目决定了索引能够保存的最大数据量，因为任何文档都会存在于一个主分片。</p>
<p>我们可以在建立索引时决定其分片数量，当然它也有默认值</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//PUT /cars</div><div class="line">&#123;</div><div class="line">   "settings" : &#123;</div><div class="line">      "number_of_shards" : 3,</div><div class="line">      "number_of_replicas" : 1</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于节点来说，一个节点中的分片数越少，则单个分片所分到的资源更多，单个分片的性能也就更好，<strong>写操作只能由主分片来处理</strong>，但是读操作则主副分片都可以处理，更多的副分片一方面可以保证更高的可靠性，另一方面则可以提高吞吐量。以下面的方式可以来增加我们的副分片数量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//PUT /cars/_settings</span></div><div class="line">&#123;</div><div class="line">   <span class="string">"number_of_replicas"</span> : <span class="number">2</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们的集群一开始有多个节点，然后你关闭了其中一个，然后又打开它，es会尝试重用之前的数据，并用自己的新数据去同步之前的老数据。</p>
<h2 id="文档的分布式存储"><a href="#文档的分布式存储" class="headerlink" title="文档的分布式存储"></a>文档的分布式存储</h2><p>文档是es中的最小的存储单位，我们存储文档时通常要指定其索引和类型，那么es最终会如何选择相应的分片存储这个被索引的文档呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">shard = hash(routing) % number_of_primary_shards</div></pre></td></tr></table></figure>
<p>实际上有上面这个公式，默认的routing是文档的_id，我们也可以自定义routing，实际上所有的文档api,如bulk，update等等都接受一个名为routing的参数。</p>
<h3 id="单文档操作"><a href="#单文档操作" class="headerlink" title="单文档操作"></a>单文档操作</h3><p>一般来说我们进行文档操作，会通过以下的步骤</p>
<p>1.请求到某个节点（称作协调节点），该节点会通过_id来确定文档属于哪个分片（routing）。</p>
<p>2.如果参数是增删改的，那么请求会被转发到这个分片的主分片</p>
<p>3.主分片执行请求中的操作，如果成功则<strong>并行</strong>转发到副本分片上，所有的副本分片会执行同样的请求，并向主分片报道成功。</p>
<p>4.主分片接到所有副本分片的成功报道，会向协调节点报告成功</p>
<p>5.协调节点接到主分片的成功报道，转而向客户端报道操作成功</p>
<p>如果第2步是一个查询操作，则协调节点会以自己的负载均衡方式（一般是轮询）来选择一个分片，但是这里可能会存在主分片有数据，而副分片还没有数据的情况，这时可能会报道查不到文档。</p>
<p>如果第2步是一个局部更新操作，则主分区会在局部更新完成后重新索引这个文档，如果它发现文档被更改，则会从新执行更新，然后再查询，如果还发现被更改则再重复执行更新和查询操作，直到达到指定的retry_on_conflict次数后，才会放弃，这是为了保证一致性。另外：当主分片把更改转发到副本分片时， 它不会转发更新请求。 相反，<strong>它转发完整文档的新版本</strong>。请记住，这些更改将会异步转发到副本分片，并且不能保证它们以发送它们相同的顺序到达。 如果es仅转发更改请求，则可能以错误的顺序应用更改，导致得到损坏的文档</p>
<h3 id="多文档操作"><a href="#多文档操作" class="headerlink" title="多文档操作"></a>多文档操作</h3><p>在用mget和bulk操作时，情况大致相同，只不过协同服务器会将请求给多个分片,并等待多个分片的响应信息。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;es是一个开源搜索引擎，其建立在,lucene上提供了一系列非常直观好用的restful api接口，以及分布式方案，用es的这些提供物，你不在需要写一个java程序去访问lucene，你也不再需要依赖其他的集群方案去建立并思考如何管理一个lucene集群，es是一套非常优秀的拿来即用的工具，一个天生的分布式的软件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="-ElasticSearch" scheme="http://yoursite.com/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>React(5):HOC</title>
    <link href="http://yoursite.com/2018/10/11/React-5-HOC/"/>
    <id>http://yoursite.com/2018/10/11/React-5-HOC/</id>
    <published>2018-10-11T06:35:28.000Z</published>
    <updated>2018-10-11T07:55:38.356Z</updated>
    
    <content type="html"><![CDATA[<p>联系高阶函数概念，高阶组件是指接受一个组件返回一个组件的<strong>函数</strong>。它常用来分离组件的通用逻辑，可看作是装饰器模式的一种应用。</p>
<p><strong>注意：高阶组件并不是组件，而是函数</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myHOC</span>(<span class="params">WrappedComponent</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</div><div class="line">        render()&#123;</div><div class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125;/&gt;</span></span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>既然高阶组件是函数，那么js函数中有的性质它都有，高阶组件并不一定是只能有一个参数的单个参数列表，我们可以给它传入多个参数，定义多个参数列表，柯里化等等都没有问题。</p>
<a id="more"></a>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myHOC</span> = (<span class="params">data</span>) =&gt; (<span class="params">WrappedComponent</span>) =&gt; </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</div><div class="line">    	construct(props)&#123;</div><div class="line">            <span class="keyword">super</span>(props)</div><div class="line">            <span class="keyword">this</span>.setState(&#123;data&#125;)</div><div class="line">    	&#125;</div><div class="line">        render()&#123;</div><div class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125;/&gt;</span></span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function Mycomponent(props)&#123;</div><div class="line"> 	return <span class="tag">&lt;<span class="name">div</span> /&gt;</span>   </div><div class="line">&#125;</div><div class="line"></div><div class="line">const hoc = myHOC(&#123;name:"Saul"&#125;)(Mycomponent)</div></pre></td></tr></table></figure>
<p><strong>劫持渲染</strong></p>
<p>有事我们可能要根据props或者状态来判断组件是不是能够被渲染，或者是不是要转换为其他的表现形式，比如下面，我们判断组件是不是应该被构造</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">judgePaintComponent</span>(<span class="params">WrappedComponent</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span></span>&#123;</div><div class="line">        render()&#123;</div><div class="line">        	<span class="keyword">if</span>(<span class="keyword">this</span>.props.paint)</div><div class="line">        		<span class="keyword">return</span> <span class="keyword">super</span>.render();</div><div class="line">        	<span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最佳实践</p>
<p>1.高阶组件采用统一的名称，比如把被包装组件的名称显示加入到高阶组件名称，如：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">withStudentList</span>(<span class="params">students</span>)</span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2.高阶组件每次都会返回一个新的组件，所以最好不要再render和组件的声明周期函数中使用，因为这些函数经常被调用，所以非常消耗空间，又消耗时间（前一次组件被卸载）。</p>
<p>3.高阶组件生成的新组件不会包含被包装组件的静态方法，开发者需要手动复制</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Wrapped.staticMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myHOC</span>(<span class="params">WrappedComponent</span>)</span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">newComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</div><div class="line">        render()&#123;</div><div class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125;/&gt;</span></span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //手动复制</div><div class="line">    newComponent.staticMethod = WrappedComponent.staticMethod;</div><div class="line">    return newComponent;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> const mycomponent = myHOC(Wrapped);</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;联系高阶函数概念，高阶组件是指接受一个组件返回一个组件的&lt;strong&gt;函数&lt;/strong&gt;。它常用来分离组件的通用逻辑，可看作是装饰器模式的一种应用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：高阶组件并不是组件，而是函数&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight jsx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;myHOC&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;WrappedComponent&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;React&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;Component&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        render()&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;WrappedComponent&lt;/span&gt; &amp;#123;&lt;span class=&quot;attr&quot;&gt;...this.props&lt;/span&gt;&amp;#125;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;既然高阶组件是函数，那么js函数中有的性质它都有，高阶组件并不一定是只能有一个参数的单个参数列表，我们可以给它传入多个参数，定义多个参数列表，柯里化等等都没有问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React(4):Communication way of Component</title>
    <link href="http://yoursite.com/2018/10/10/Communication-way-of-Component/"/>
    <id>http://yoursite.com/2018/10/10/Communication-way-of-Component/</id>
    <published>2018-10-10T09:59:51.000Z</published>
    <updated>2018-10-11T04:45:28.499Z</updated>
    
    <content type="html"><![CDATA[<p>  单独的组件几乎没什么意义，一个真实的UI界面是由多个组件打起来的，而这些组件部分又与服务器通信得到数据，更改自身的state进行渲染，组件之间也有通信方式，比如父组件就通过props把数据传给子组件进行渲染，以至于整个界面“活”了起来。</p>
<a id="more"></a>
<h2 id="组件与服务器通信"><a href="#组件与服务器通信" class="headerlink" title="组件与服务器通信"></a>组件与服务器通信</h2><p>考虑通信问题，在明确怎么通信和在哪通信两个点，我们在<a href="http://saul.xin/2018/10/09/react-2-Component/" target="_blank" rel="external">前一篇文章</a>中介绍了组件的生命周期方法，组件的生命周期方法覆盖了整个组件的生命周期，在哪通信实际上就是选择合适的生命周期方法来通信。</p>
<p>首先是<strong>挂载阶段</strong>的通信：</p>
<p>挂载阶段有下面的方法：</p>
<p><code>constructor -&gt; componentWillMount -&gt; render -&gt; componentDidMount</code></p>
<p>首先我们排除两个特定的方法，构造器和render，虽然你可以在里面写通信代码但是这样做显然有背与该方法的自身定义的作用，并且你在render里写的话严重影响程序效率，因为这个方法很多时候都会被调用。</p>
<p>余下的方法里，一般我们选择componentDidMount，此时组件已经挂载，它能保证DOM操作是安全的。且如果组件在服务器端渲染，componentWillMount会被调用两次（服务器端一次，浏览器端一次）。</p>
<p><strong>更新阶段的通信</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">componentWillReceiveProps -&gt; shouldComponentUpdate -&gt; componentWillUpdate -&gt; render -&gt; componentDidUpdate</div></pre></td></tr></table></figure>
<p>组件更新阶段常常需要从服务器获取最新数据，这很容易理解，比如组件向服务器发送请求有一个参数来自于props的一个属性,那么props的这个属性发生改变时，理应从新请求服务器数据。</p>
<p>这样结果就很清楚了，<code>componentWillReceiveProps(nextProps)</code>用来做更新时的服务器通信再好不过,并且在实际请求前可以先对比nextProps和当前的props，确定请求依赖的属性有变化，再发送请求。</p>
<h3 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h3><h3 id="父子通信"><a href="#父子通信" class="headerlink" title="父子通信"></a>父子通信</h3><p>父子组件通信在React应用中是常有的情况，父子组件通信主要依赖于props，父组件向子组件传递props比较简单，子组件向父组件通信时，需要依赖于父组件传入的回调函数。</p>
<h3 id="兄弟通信"><a href="#兄弟通信" class="headerlink" title="兄弟通信"></a>兄弟通信</h3><p>另外兄弟组件之间也是可以通信的，这里的兄弟和树形兄弟不同，你可以认为如果他们有同一个祖先，那么他们就是兄弟组件，并不一定是处于相同的层级。</p>
<p>兄弟组件间不能够直接通信，一般来说要把这些组件需要共享的状态放到离他们最近的祖先中，然后通过父组件传递来的回调函数去改变这些共享状态。</p>
<h3 id="使用上下文-不推荐使用"><a href="#使用上下文-不推荐使用" class="headerlink" title="使用上下文(不推荐使用)"></a>使用上下文(不推荐使用)</h3><p>祖先往子孙传递上下文需要经过多个层级操作，这样会很麻烦，React提供了一个<strong>试用性的功能</strong>，即提供了一个context，不过要用这个功能必须在提供context的组件内新增一个getChildContext方法，并且还要在组件的childContextTypes属性上定义context对象的属性的类型信息。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</div><div class="line">	<span class="comment">//...</span></div><div class="line">	getChildContext()&#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">onAction</span>: <span class="keyword">this</span>.handleMethod</div><div class="line">        &#125;;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">Container.childContextTypes = &#123;</div><div class="line">    <span class="attr">onAction</span>: PropTypes.func</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在子组件中可以通过[this.context.属性名]来获取到提供context组件中所传入的对象。子组件也需要声明context的属性类型：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SubElement.contextTypes = &#123;</div><div class="line">    <span class="attr">onAddUser</span>: propTypes.func</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  单独的组件几乎没什么意义，一个真实的UI界面是由多个组件打起来的，而这些组件部分又与服务器通信得到数据，更改自身的state进行渲染，组件之间也有通信方式，比如父组件就通过props把数据传给子组件进行渲染，以至于整个界面“活”了起来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React(3):More details of component</title>
    <link href="http://yoursite.com/2018/10/10/React-3-More-details-of-component/"/>
    <id>http://yoursite.com/2018/10/10/React-3-More-details-of-component/</id>
    <published>2018-10-10T00:36:20.000Z</published>
    <updated>2018-10-11T06:34:05.669Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Key属性"><a href="#Key属性" class="headerlink" title="Key属性"></a>Key属性</h2><p>React用Key来标记列表中的每一个元素，通过查看key是否改变来知道哪些元素需要重新渲染，这样就节省了渲染时间，毕竟一个列表中有时包含太多元素。<strong>因此要避免使用索引值作为key</strong>,因为索引可能很容易会被改变，比如增加或者删除列表元素时。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;ul&gt;</div><div class="line">	&lt;li key = "one"&gt;one&lt;/li&gt;</div><div class="line">	&lt;li key = "two"&gt;two&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line"></div><div class="line">//changed</div><div class="line">&lt;ul&gt;</div><div class="line">    &lt;li key = "three"&gt;three&lt;/li&gt;</div><div class="line">	&lt;li key = "one"&gt;one&lt;/li&gt;</div><div class="line">	&lt;li key = "two"&gt;two&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure>
<p>上面这种情况发生时，因为key的存在，react会知道one和two两个项根本没变，所以会直接在one的前面插入一个three。</p>
<p><strong>另外，key是一个在同列表下不能重复的属性。</strong></p>
<a id="more"></a>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p><strong>React中的事件要采用驼峰命名法</strong>，处理事件的<strong>响应函数要以对象形式赋值给事件属性</strong>。并且因为React事件是合成事件，所以不能通过返回false来阻止事件的默认行为，而<strong>必须显示的调用preventDefault来阻止</strong>，另外可以通过事件对象的nativeEvent属性来获取DOM原生事件。</p>
<p><strong>es6 class并不会自动绑定this到当前对象，所以开发者在某些形式下需要手动绑定。</strong></p>
<h3 id="箭头函数来定义事件"><a href="#箭头函数来定义事件" class="headerlink" title="箭头函数来定义事件"></a>箭头函数来定义事件</h3><p>如果用<code>{(index) =&gt; alert(index + &quot;:&quot; + this.props.name)}</code>这样的lambda形式来定义事件,因为箭头函数的this总是指向函数定义的对象，所以这里的对象就是当前组件的实例。</p>
<p>但是这样有一个缺点，就是如果箭头函数在render中定义，那么每次render时都会创建一个新的处理函数对象，虽然一般情况下这点消耗是可以忽略的，如果组件层级比较低，那么这样的消耗就比较大了。</p>
<h3 id="直接绑定组件方法"><a href="#直接绑定组件方法" class="headerlink" title="直接绑定组件方法"></a>直接绑定组件方法</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(props)&#123;</div><div class="line">        <span class="keyword">super</span>(props);</div><div class="line">        <span class="comment">//绑定指向</span></div><div class="line">        <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    handleClick(event)&#123;</div><div class="line">        alert(<span class="string">"hello"</span>+<span class="keyword">this</span>.props.whose)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span></span></div><div class="line">                &#123;this.props.whose&#125; Button</div><div class="line">            <span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这种方式在构造函数中为后面用到的事件处理函数绑定了this的指向。如果你的事件处理函数里根本没有用到this，那不绑定也可以，但是一般不会出现这种没用到this的事件处理函数。</p>
<p>有些人觉得构造函数中用的那种绑定模板代码比较繁琐，会用下面的方式直接在事件声明时绑定this指针的指向。不过bind会返回一个新的对象，这样的话相当于每次render调用时还是创建了一个新的对象。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">        <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick.bind(this)&#125;</span>&gt;</span></span></div><div class="line">            &#123;this.props.whose&#125; Button</div><div class="line">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">    );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="属性初始化语法"><a href="#属性初始化语法" class="headerlink" title="属性初始化语法"></a>属性初始化语法</h3><p>这是一个试验阶段的特性，默认不支持，不过create-react-app手脚架默认是支持的，在其他项目中可能需要引入transform-class-properties插件获取这个特性支持。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(props)&#123;</div><div class="line">        <span class="keyword">super</span>(props);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    handleClick = <span class="function">(<span class="params">event</span>) =&gt;</span>&#123;</div><div class="line">        alert(<span class="string">"hello"</span>+<span class="keyword">this</span>.props.whose)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span></span></div><div class="line">                &#123;this.props.whose&#125; Button</div><div class="line">            <span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="受控和非受控组件"><a href="#受控和非受控组件" class="headerlink" title="受控和非受控组件"></a>受控和非受控组件</h2><p>某些元素自身维护了一些状态，比如很多表单元素维护着自身的输入和显示内容，React组件的状态只能通state来管理，这些状态不被React来控制的元素，即是非受控元素。</p>
<h3 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h3><p>那么为了达成这种控制，React引入了受控组件概念，如果一个表单元素的值是由React来管理的那么它就是一个受控组件，这样做的目的是为了保证state是界面上所有元素状态的唯一来源。</p>
<p><strong>text/password/textarea:</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyForm</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(props)&#123;</div><div class="line">        <span class="keyword">super</span>(props);</div><div class="line">        <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">this</span>.state = &#123;<span class="attr">username</span>:<span class="string">''</span>, <span class="attr">password</span>: <span class="string">''</span>&#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;form&gt;</div><div class="line">                &lt;input name = "username" type="text" onChange=&#123;this.handleChange&#125; value=&#123;this.state.username&#125;/&gt;</div><div class="line">                &lt;input name = "password" type="password" onChange=&#123;this.handleChange&#125; value=&#123;this.state.password&#125;/&gt;</div><div class="line">            &lt;/form&gt;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    handleChange(event) &#123;</div><div class="line">        this.setState(&#123;[event.target.name]: event.target.value&#125;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">export default MyForm;</div></pre></td></tr></table></figure>
<p>上面的代码展示了React如何控制表单元素的状态，在父组件的render函数中我们将表单元素的value与父组件的state绑定，然后定义onChange函数，它在受控组件被改变时触发，每次都更新我们的state,以至于视图能够重新渲染，通过state来作为唯一状态源的目的就此达到，如果你把handleChange中的setState注释掉，表单的input元素不能被输入。</p>
<p>其他表单元素也类似，只不过是受控属性有些不同：</p>
<p><strong>select:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//通过设置option的value来选择</div><div class="line">&lt;select value = &#123;this.state.value&#125; onChange = &#123;this.handleChange&#125;&gt;</div><div class="line">	&lt;option value = "react"&gt;React&lt;/option&gt;</div><div class="line">	&lt;option value = "vue"&gt;Vue&lt;/option&gt;</div><div class="line">&lt;/select&gt;</div></pre></td></tr></table></figure>
<p><strong>checkbox/radio:</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">this.state = &#123;</div><div class="line">	vue : false,</div><div class="line">	react : false,</div><div class="line">	angluar :false</div><div class="line">&#125;</div><div class="line">*/</div><div class="line">&lt;input type = <span class="string">"checkbox"</span> name = <span class="string">"react"</span> value = <span class="string">"react"</span> checked =&#123;<span class="keyword">this</span>.state.react&#125; onchanged = &#123;<span class="keyword">this</span>.handleChange&#125; /&gt;</div><div class="line">&lt;input type = "checkbox" name = "vue" value = "vue" checked =&#123;this.state.vue&#125; onchanged = &#123;this.handleChange&#125; /&gt;</div><div class="line">&lt;input type = "checkbox" name = "angluar" value = "angluar" checked =&#123;this.state.angluar&#125; onchanged = &#123;this.handleChange&#125; /&gt;</div></pre></td></tr></table></figure>
<h3 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h3><p>定义受控组件的过程异常繁琐，如果一个表单中有大量元素，那么声明将会变得很复杂。</p>
<p>我们能不能采用非受控组件呢?如果采用非受控组件会存在一些问题，<strong>如何获取到表单元素的值？</strong>，为了解决这个问题React中提供了一个特殊的属性ref，这个属性用来应用React组件或DOM元素的实例。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;input name = <span class="string">"username"</span> type=<span class="string">"text"</span> ref=&#123;(input) =&gt; <span class="keyword">this</span>.input = input&#125; defaultValue = <span class="string">"something"</span>/&gt;</div></pre></td></tr></table></figure>
<p>这里我们利用ref属性，其中传入的input是当前的表单元素，利用ref我们把input赋值给了this.input，那么在组件的其他地方我们就能够通过this.input来访问这个元素。如果一个表单元素需要默认值，但是我们知道value属性是React没办法控制的，因此我们一般用defaultValue来指定属性的默认值。如果你直接用value指定你会发现输入框有值但是无法被改变。另外其他表单元素，如checkbox，等等都有类似的属性来设置默认值，但是这种方法破坏了React状态管理的一致性，不建议使用，所以一般我们还是通过之前的方法去声明受控组件。</p>
<h2 id="设计State"><a href="#设计State" class="headerlink" title="设计State"></a>设计State</h2><h3 id="小而完整的state"><a href="#小而完整的state" class="headerlink" title="小而完整的state"></a>小而完整的state</h3><p><strong>state最佳实践是一个最小但最完整的状态集</strong></p>
<p>完整：<strong>这个状态集必须能代表一个组件UI的呈现</strong>，换句话说UI的任何改变都能够通过state的变化反应出来。</p>
<p>最小：<strong>所有状态都用于反应UI变化，没有任何冗余</strong>，且没有通过其他状态计算出来的状态。（比如一个订单的订单金额，可以通过各项计算出来，那么它不应该为一个totalPrice状态）</p>
<p>一个完整的状态集中的数据有两类：</p>
<p>渲染组件使用的数据：比如学生的姓名</p>
<p>判断UI展现形式的依据：比如是否展示，怎么对齐等等</p>
<h3 id="普通属性"><a href="#普通属性" class="headerlink" title="普通属性"></a>普通属性</h3><p>React我们以props和state来定义组件UI，本质上它们是Component class的属性，我们只是继承了这个类（函数组件除外），有些属性，比如定时器之类的与UI的渲染无关，我们不应该把其定义为props或者state,我们直接用<code>this.属性名</code>这种方式来定义，一般来说组件的render方法中没有用到的属性都应该定义为普通属性。</p>
<h3 id="区分props和state"><a href="#区分props和state" class="headerlink" title="区分props和state"></a>区分props和state</h3><p>props是一个对外的属性，对组件本身他是不可变的，一般由父组件中传入，而state是一个对内的属性，组件通过改变它来改变UI的渲染。定义影响UI的数据时应该参照这两条，以及上面的<code>普通属性</code>和<code>小而完整的state</code>的说法来确定一个数据到底应该存在state对象里还是props对象里。</p>
<p>对于state有些点是要注意的：</p>
<p>1.首先state必须通过调用setState来改变，利用<code>this.state.name = &quot;saul&quot;</code>这种方式来改变并不会触发render。</p>
<p>2.state的<strong>更新是异步</strong>的，setState只是把要修改的状态放入一个队列，等待时机再修改，从componentWillReceiveProps中调用setState并不能立刻更新就可以略知一二，并且React可能会将多次状态修改合并成一次，<strong>有意思的是props的更新也是异步的，对于它们你都不能指望用前面的状态来计算出后面的状态。</strong></p>
<p><code>this.setState({count: this.state.count + 1})</code></p>
<p>相当于合并操作：</p>
<p><code>Object.assign({}, this.state, { count: this.state.count + 1 });</code></p>
<p>不过setState提供了另一种形式的调用，即传入一个函数</p>
<p><code>setState((preState,props)=&gt;({counter:preState.count + 1}))</code></p>
<p>这个方法用来处理异步更新，React 会把我们更新 state 的函数加入到一个队列里面，然后，按照函数的顺序依次调用，这样就能够保证顺序了，其中preState是更新前的状态,props是组件当前的props。</p>
<p>3.state的更新是一个合并过程</p>
<p>4.最佳实践:把state当做不可变对象</p>
<p>状态类型是数组：</p>
<p>用数组的concat,slice和mapreduce方法，或es6扩展语法<code>[...perState.persons,&quot;Tom&quot;]</code>，不要用push,pop,shift,unshift,splice等方法。</p>
<p>状态类型是普通对象：</p>
<p>es6扩展语法：</p>
<p><code>{...perState.person,name:&#39;Tom&#39;}</code></p>
<p>es6的Object.assign方法：</p>
<p><code>Object.assign({},preState.person,{name:&#39;Tom&#39;})</code></p>
<p>使用不可变对象，能够带来一些比较判断上的好处，比如直接比较引用而不需要比较内容，另外引入诸如Immutable之类的库，也可以方便我们创建不可变对象。</p>
<h2 id="Ref属性"><a href="#Ref属性" class="headerlink" title="Ref属性"></a>Ref属性</h2><p>在<a href="http://saul.xin/2018/10/10/React-3-More-details-of-component/#%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6" target="_blank" rel="external">非受控组件</a>中介绍了一个叫做ref的属性，一般来说这个属性是不应该使用的，因为它破坏了React的典型数据流。</p>
<p>下面复现一下我们如何定义非受控组件</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;input name = <span class="string">"username"</span> type=<span class="string">"text"</span> ref=&#123;(input) =&gt; <span class="keyword">this</span>.input = input&#125; defaultValue = <span class="string">"something"</span>/&gt;</div></pre></td></tr></table></figure>
<p>上面的这种定义方式，ref接受了一个回调函数作为值，这个回调函数会在<strong>挂载</strong>和<strong>卸载(或原有的ref属性变化)</strong>时被调用，挂载时传入的是当前DOM元素，而后两种情况时传入null。</p>
<p>ref属性只能在类组件或者返回dom元素的函数组件上定义（因为dom元素本身被实例化了）,下面这张方式ref不起作用</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyFunctionalComponent</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &lt;input /&gt;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Parent extends React.Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    // 无状态函数组件没有组件实例化过程，所以根本没有this这种东西,自然也不会有this.ref</div><div class="line">    return (</div><div class="line">      &lt;MyFunctionalComponent</div><div class="line">        ref=&#123;(input) =&gt; &#123; this.textInput = input; &#125;&#125; /&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>利用ref我们还可以获取到子组件的子元素,把函数传入props然后再对子组件的子元素的ref赋值，于是this.textInput能获取到那个input元素</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyFunctionalComponent</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &lt;input ref = &#123;props.inputRef&#125; /&gt;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Parent extends React.Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    // 无状态函数组件没有组件实例化过程，所以根本没有this这种东西</div><div class="line">    return (</div><div class="line">      &lt;MyFunctionalComponent</div><div class="line">        inputRef=&#123;(input) =&gt; &#123; this.textInput = input; &#125;&#125; /&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Key属性&quot;&gt;&lt;a href=&quot;#Key属性&quot; class=&quot;headerlink&quot; title=&quot;Key属性&quot;&gt;&lt;/a&gt;Key属性&lt;/h2&gt;&lt;p&gt;React用Key来标记列表中的每一个元素，通过查看key是否改变来知道哪些元素需要重新渲染，这样就节省了渲染时间，毕竟一个列表中有时包含太多元素。&lt;strong&gt;因此要避免使用索引值作为key&lt;/strong&gt;,因为索引可能很容易会被改变，比如增加或者删除列表元素时。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;ul&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;lt;li key = &quot;one&quot;&amp;gt;one&amp;lt;/li&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;lt;li key = &quot;two&quot;&amp;gt;two&amp;lt;/li&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;/ul&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;//changed&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;ul&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;li key = &quot;three&quot;&amp;gt;three&amp;lt;/li&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;lt;li key = &quot;one&quot;&amp;gt;one&amp;lt;/li&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;lt;li key = &quot;two&quot;&amp;gt;two&amp;lt;/li&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;/ul&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面这种情况发生时，因为key的存在，react会知道one和two两个项根本没变，所以会直接在one的前面插入一个three。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另外，key是一个在同列表下不能重复的属性。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React(2):Component </title>
    <link href="http://yoursite.com/2018/10/09/react-2-Component/"/>
    <id>http://yoursite.com/2018/10/09/react-2-Component/</id>
    <published>2018-10-09T03:13:52.000Z</published>
    <updated>2018-10-10T06:29:48.773Z</updated>
    
    <content type="html"><![CDATA[<p>  React的核心概念就是组件，组件是整个React应用的基石，组件是UI中被拆分成的独立，可复用的模块。</p>
<h2 id="定义组件"><a href="#定义组件" class="headerlink" title="定义组件"></a>定义组件</h2><h3 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h3><p>  组件的声明方式有两种，使用ES 6 class声明的<strong>类组件</strong>和使用函数的声明<strong>函数组件</strong>，然而class语法只是es6的一个语法糖，不过在这里沟通过继承React已定义好的组件类能够简化开发。</p>
<p>一个class组件如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Board.js</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Board</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line"></div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">                Board</div><div class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//这句话将Board作为默认模块导出，从而可以在其他JS文件中导入使用</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> Board;</div></pre></td></tr></table></figure>
<p>以下两点需要注意：</p>
<p><strong>class组件必须继承自React.Component</strong></p>
<p><strong>class内部必须定义render方法，该方法返回代表该组件UI的react元素</strong></p>
<a id="more"></a>
<p>此时的Board还没有挂载，所以并未正确显示，我们需要把它挂载到界面的root节点上:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//index.js</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"></div><div class="line"><span class="comment">//导入Board组件模块</span></div><div class="line"><span class="keyword">import</span> Board <span class="keyword">from</span> <span class="string">'./Board'</span></div><div class="line"></div><div class="line"><span class="comment">//mount!</span></div><div class="line">ReactDOM.render(</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Board</span> /&gt;</span>,</span></div><div class="line">    document.getElementById('root')</div><div class="line">);</div></pre></td></tr></table></figure>
<p>上面的<code>import ReactDOM from &#39;react-dom&#39;;</code>用于导入react-dom库，这个库用于虚拟DOM节点到浏览器DOM节点间的转换。</p>
<h4 id="props和state"><a href="#props和state" class="headerlink" title="props和state"></a>props和state</h4><p>props和state是组件的两个重要属性，它们都会反映到最终UI上，但它们有所不同。</p>
<p>你可以把React组件看作是一个函数,输入是props和state输出是UI,你可以认为相同组件最终表现出的UI就是由传入的两个参数来决定的</p>
<p><code>UI = Component(props,state)</code></p>
<p>props是一般是一个由父组件中传入的不可变数据，实质上传入的一般是一个简单的结构对象，其属性由组件作为JSX标签使用时的属性组成。</p>
<p>state则是组件内部的状态，一般在组件的constructor中定义一个组件初始状态，后续通过setState来改变组件的状态（一般在相应函数中），改变后组件UI也会重新渲染。</p>
<p>可以这么说：</p>
<p>props是一个对外的接口，组件通过props接收外部的数据（有时也是方法，当然方法也是一种数据），内部不要去改变props，所以一般来说这个属性是只读的，只在组件创建的那一刻决定了。</p>
<p>states则是一个对内接口，组件的内不要变化通过state来反映出来，这个数据是可变的，我们通过setState方法来修改。</p>
<h3 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h3><p>  props和state都可以影响组件UI，那么组件必须要同时它们两者么？我们知道props一般作为只读的属性，一般来说你只能在创建组件时就把它的值给决定了，而state则不然，这样的话我们知道对于那些不可变的<strong>无状态组件</strong>，我们根本不需要state，我们一般用一个函数来定义无状态组件，因为更加简单明了，当然你也可以用比较长的类定义来定义组件，比如：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Board</span>(<span class="params">props</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.whose&#125; Board<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> Board;</div></pre></td></tr></table></figure>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"><span class="keyword">import</span> Board <span class="keyword">from</span> <span class="string">'./Board'</span></div><div class="line"></div><div class="line"><span class="comment">//mount!</span></div><div class="line">ReactDOM.render(</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Board</span> <span class="attr">whose</span> = <span class="string">"Saul's"</span> /&gt;</span>,</span></div><div class="line">    document.getElementById('root')</div><div class="line">);</div></pre></td></tr></table></figure>
<p>Board是一个无状态的函数式组件，我们在挂载它的时候为它传入了<code>props.whose</code>,组件渲染出来将会是<code>Saul&#39;s Board</code>这句话。</p>
<p>现实中大多数组件是一次性渲染的无状态组件，最佳实践中我们定义少量的有状态组件来管理整个应用的状态变化拥有处理状态变化的逻辑，而无状态组件关注绝大部分UI的渲染工作。</p>
<h2 id="组件和元素"><a href="#组件和元素" class="headerlink" title="组件和元素"></a>组件和元素</h2><p>React的组件和元素并不是同一个东西，JSX是createElement的语法糖，所以JSX其实就是用来创建元素的，而组件的声明方式在上面提到了，显然它们并不是一种东西。</p>
<p>React元素实际上是一个JS对象，它的结构的例子如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    type : 'div',</div><div class="line">    props : &#123;</div><div class="line">        className : 'students',</div><div class="line">        student : &#123;</div><div class="line">            type : 'Student',</div><div class="line">            props : &#123;</div><div class="line">                name : 'Liu',</div><div class="line">                age : 20</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以JSX创建上面这个元素是：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div className = <span class="string">'students'</span>&gt;</div><div class="line">	<span class="xml"><span class="tag">&lt;<span class="name">Student</span> <span class="attr">name</span> = <span class="string">'Liu'</span> <span class="attr">age</span> = <span class="string">20</span> /&gt;</span> </span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>因为JSX创建的就是一个普通的js对象，你可以用JSX语法创建一个元素对象赋值给一个变量</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> student = <span class="xml"><span class="tag">&lt;<span class="name">Student</span> <span class="attr">name</span> = <span class="string">'Liu'</span> <span class="attr">age</span> = <span class="string">20</span> /&gt;</span>;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span> = <span class="string">'students'</span>&gt;</span></div><div class="line">	&#123;student&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h3><p>React组件从创建到销毁之间会经历多个生命周期方法，目的是为了让开发者更好的控制组件行为而准备。<strong>函数组件没有生命周期方法（很简单它只是一个普通的函数，不可能无中生有出几个方法）。</strong></p>
<h4 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h4><p>该阶段组件被创建和初始化，然后被挂载到DOM里，完成组件的第一次渲染。</p>
<p><code>constructor -&gt; componentWillMount -&gt; render -&gt; componentDidMount</code></p>
<p><code>constructor</code>方法不用多说</p>
<p><code>componentWillMount</code>方法，执行且仅执行一次，该方法中调用setState不会引起重新渲染，该方法很少用到。</p>
<p><code>render</code>根据props和state返回一个React元素。注意这个元素只是描述UI并不是真正去渲染，把它当做一个输入值是this的纯函数用比较好。</p>
<p><code>componentDidMount</code>只会在组件被挂载到DOM后执行一次，此时DOM的结构已经可以获取到，一些依赖DOM节点的操作可以放到这个方法中，<strong>这个方法还常常用来向服务器请求数据</strong>，该方法中如果改变state则会引起组件的从新渲染。</p>
<h4 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h4><p>组件的更新一般只是由于props或者state的变化引起，state只能由setState来改变，而props是对外接口，一般是因为父组件的render方法执行而改变，当然有时候也许父组件的render方法并没有改变props的值，但是组件依然会执行更新阶段的声明周期函数。</p>
<p><code>componentWillReceiveProps -&gt; shouldComponentUpdate -&gt; componentWillUpdate -&gt; render -&gt; componentDidUpdate</code></p>
<p><code>componentWillReceiveProps(nextProps)</code>只在props引起的组件更新过程中才会被调用,nextProps是父组件传递过来来新的props，它的值可能和this.props一致。</p>
<p>如果在这个方法中执行了setState，实际上要等到render执行之后才更新state，<code>shouldComponentUpdate</code>，<code>componentWillUpdate</code>中的state不变。</p>
<p><code>shouldComponentUpdate(nextProps,nextState)</code>该方法决定组件是否继续执行更新过程，默认返回true，即继续执行更新，一旦该方法返回false，后面的声明周期方法不会被调用，在该方法中一般比较state和props是否改变，可以节省一部分渲染时间，因为如果state和props更本没变，则没必要渲染，该方法体里面不能调用setState，不然会引起循环调用。</p>
<p><code>componentWillUpdate(nextProps,nextState)</code>很少用到,里面不能调用setState，不然会引起循环调用。</p>
<p><code>componentDidUpdate(prevProps,prevState)</code>组件更新后被调用，作为操作更新后的DOM的地方。</p>
<h4 id="卸载阶段"><a href="#卸载阶段" class="headerlink" title="卸载阶段"></a>卸载阶段</h4><p>只有一个方法,在卸载前调用</p>
<p><code>componentWillUnmount</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  React的核心概念就是组件，组件是整个React应用的基石，组件是UI中被拆分成的独立，可复用的模块。&lt;/p&gt;
&lt;h2 id=&quot;定义组件&quot;&gt;&lt;a href=&quot;#定义组件&quot; class=&quot;headerlink&quot; title=&quot;定义组件&quot;&gt;&lt;/a&gt;定义组件&lt;/h2&gt;&lt;h3 id=&quot;类组件&quot;&gt;&lt;a href=&quot;#类组件&quot; class=&quot;headerlink&quot; title=&quot;类组件&quot;&gt;&lt;/a&gt;类组件&lt;/h3&gt;&lt;p&gt;  组件的声明方式有两种，使用ES 6 class声明的&lt;strong&gt;类组件&lt;/strong&gt;和使用函数的声明&lt;strong&gt;函数组件&lt;/strong&gt;，然而class语法只是es6的一个语法糖，不过在这里沟通过继承React已定义好的组件类能够简化开发。&lt;/p&gt;
&lt;p&gt;一个class组件如下：&lt;/p&gt;
&lt;figure class=&quot;highlight jsx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//Board.js&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; React &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;react&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Board&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;React&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;Component&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    render() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                Board&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        );&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//这句话将Board作为默认模块导出，从而可以在其他JS文件中导入使用&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; Board;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以下两点需要注意：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;class组件必须继承自React.Component&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;class内部必须定义render方法，该方法返回代表该组件UI的react元素&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React(1):meet react</title>
    <link href="http://yoursite.com/2018/10/09/react-1-meet-react/"/>
    <id>http://yoursite.com/2018/10/09/react-1-meet-react/</id>
    <published>2018-10-09T01:44:08.000Z</published>
    <updated>2018-10-10T06:29:56.678Z</updated>
    
    <content type="html"><![CDATA[<p>  几乎所有的软件问题都可以添加一层抽象来解决，react通过添加虚拟DOM这层抽象，=，解决了处理DOM的效率问题，<strong>虚拟DOM即用来描述真实DOM的JS对象</strong>，我们知道处理结构化的js对象，要比处理一大段文本快得多。</p>
<a id="more"></a>
<p>  特点：</p>
<p>  <strong>声明式的视图层</strong>：以JSX语法声明视图层，因此可以随意使用状态数据</p>
<p>  <strong>从状态到UI的单向数据流</strong>：定义UI的状态，让React来把它渲染为最终的UI，React根据最新状态来渲染最新UI。</p>
<p>  <strong>灵活渲染</strong>：React并不直接把视图渲染成最终的界面，而是把它们渲染为了中间的抽象，即虚拟DOM，结合其他库，可以把虚拟DOM渲染成不同的最终界面，在浏览器上是react-dom,在移动端上则可以配合Native来使用，在服务端则可以配合Node进行渲染。</p>
<p>  <strong>高效DOM操作</strong>：本身对js对象的操作就远快于对真实DOM操作，配合一些诸如Diff之类的差异算法，更是可以减少渲染速度，让界面性能增加。</p>
<h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p>  JSX是一种用于描述UI的JS扩展语法，React用其来描述组件的UI。发明这种语法与React本身的理念有关，与传统很多模板思想把数据和UI拆分有所不同，其理念把<strong>组件</strong>当做是界面的可复用模块，<strong>且认为组件应该是具备UI描述和UI数据的完整体</strong>，不应该把它们分开来处理。</p>
<p>  实际上JSX仅仅是React提供的语法糖，它对应的方法是</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">React.createElement(component,props, ...chi)</div></pre></td></tr></table></figure>
<p>  所有的JSX最终都会转变为对上面这个方法的调用，但是为了对被声明的视图一目了然，首选使用JSX，就像java8中一般不会使用匿名类来代替lambda语法一样。</p>
<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>  JSX只有两种标签，React通过首字母是否大写来区分这两类标签，而且它们可以互相嵌套使用：</p>
<p>  其一就是DOM类型的标签，也就是html的基础标签诸如div,span,p等等，首字母必须小写。</p>
<p>  然后则是React组件标签，首字母必须大写。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//dom标签</span></div><div class="line"><span class="keyword">const</span> divElement = <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> hello saul <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//组件标签</span></div><div class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">SaulBlog</span> /&gt;</span>;</span></div><div class="line">     </div><div class="line">//嵌套使用</div><div class="line">const hello = (<span class="tag">&lt;<span class="name">div</span>&gt;</span> <span class="tag">&lt;<span class="name">SaulBlog</span> /&gt;</span> <span class="tag">&lt;/<span class="name">div</span>&gt;</span>;</div></pre></td></tr></table></figure>
<h3 id="js表达式"><a href="#js表达式" class="headerlink" title="js表达式"></a>js表达式</h3><p>JSX本质上依然是Js，我们可以用{}讲表达式括起来的方式来使用表达式，一般有两种情况我们要用这种语法：</p>
<p>  <strong>通过表达式给标签属性赋值</strong></p>
<p>  <strong>通过表达式定义子组件</strong></p>
<p>需要注意的是和scala之类的语言不同，js表达式并不支持多行js语句，用;隔开两条语句是会报错的。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Error!</span></div><div class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">Saul</span> <span class="attr">value</span> = <span class="string">&#123;const</span> <span class="attr">val</span> = <span class="string">1+1;return</span> <span class="attr">val</span>; &#125; /&gt;</span></span></div></pre></td></tr></table></figure>
<p>所以你用不了if-eles语句，但是可以用三目运算符?和&amp;&amp;代替if的作用。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> boolean = <span class="literal">false</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">Saul</span> <span class="attr">value</span> = <span class="string">&#123;boolean</span> &amp;&amp; <span class="attr">1</span>&#125; /&gt;</span></span></div></pre></td></tr></table></figure>
<h3 id="标签属性和注释"><a href="#标签属性和注释" class="headerlink" title="标签属性和注释"></a>标签属性和注释</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>除了部分属性外，DOM标签支持的属性JSX同样支持，只不过有些地方有点变化，比如es6占用的class关键字，现在需要在标签属性中用className代替</p>
<p>另外React对标签支持的事件进行了重新分封装，封装时采用的是驼峰命名法，如onclick要写成onClick。</p>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>注释方面需要用{}把/**/括起来</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="comment">/* 我是注释 */</span>&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  几乎所有的软件问题都可以添加一层抽象来解决，react通过添加虚拟DOM这层抽象，=，解决了处理DOM的效率问题，&lt;strong&gt;虚拟DOM即用来描述真实DOM的JS对象&lt;/strong&gt;，我们知道处理结构化的js对象，要比处理一大段文本快得多。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Notes of CS231n:Structure of CNN</title>
    <link href="http://yoursite.com/2018/03/12/Notes-of-Deep-Learning-Structure-of-CNN/"/>
    <id>http://yoursite.com/2018/03/12/Notes-of-Deep-Learning-Structure-of-CNN/</id>
    <published>2018-03-12T03:04:18.000Z</published>
    <updated>2018-03-12T08:39:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>  卷积神经网络也由有学习能力的神经元组成，这些神经元中也有权重和偏差。整个卷积神经网络实为是一个可导的评分函数，在神经网络中我们实现的各种技巧和要点依旧适用于卷积神经网络。但是<strong>卷积神经网络与一般神经网络不同的是，它基于一个假设，即输入的数据是图像</strong>。基于这个假设，我们添加了一些特有的特性，从而让我们的前向传播更为高效，<strong>同时也大大降低了网络中的参数数量</strong>。降低参数数量是一个很好的特性，因为在一般的神经网络中，因为是全连接的，如果要处理一个大点的图像，比如一个200*200*3的图像，一个神经元就有12万个权重，显然这是不可接受的。</p>
<a id="more"></a>
<h2 id="卷积神经网络结构"><a href="#卷积神经网络结构" class="headerlink" title="卷积神经网络结构"></a>卷积神经网络结构</h2><h3 id="三维排列的神经元"><a href="#三维排列的神经元" class="headerlink" title="三维排列的神经元"></a>三维排列的神经元</h3><p>在一般的神经网络中，神经元的排列一般是如下图所示：</p>
<p><img src="\img\QQ图片20180214180333.jpg" alt="QQ图片20180214180333"></p>
<p>我们可以观察到，如果硬要以一个形式的语言来描述的话，可以用宽度和高度来描述这个二维的神经元排列，但是卷积神经网络与此不同，它是三维排列的，如下图所示，我们以<strong>宽度，高度，和深度</strong>标记了这个神经元排列：</p>
<p><img src="\img\QQ图片20180312120608.png" alt="QQ图片20180312120608"></p>
<p>  从上图中你没办法发现神经元之间具体是如何连接的，但是你可以先了解一点，<strong>卷积神经网络的各层中的神经元不再采用全连接的方式</strong>，层中的神经元将只与前一层中的一小块区域连接，当然输出层例外，输出层还是全连接的。</p>
<p>  上图中的卷积神经网络的神经元排列可能不能让你清楚的知道深度的意义。我们以CIFAR-10举例，你知道CIFAR-10中的数据体是32*32*3这个大小，后面的3是代表了RGB颜色通道，那么它的神经元排列就是深度为3，宽度和高度都是32的排列。最后的输出层是1*1*10的，表示了评分向量。</p>
<blockquote>
<p>卷积神经网络是由层组成的。每一层都有一个简单的API：用一些含或者不含参数的可导的函数，将输入的3D数据变换为3D的输出数据。</p>
</blockquote>
<h3 id="以层构造的卷积神经网络"><a href="#以层构造的卷积神经网络" class="headerlink" title="以层构造的卷积神经网络"></a>以层构造的卷积神经网络</h3><p>卷积神经网络由不同类型的层按照一定的排列顺序组成，这些层会使用一个可微分的函数将激活数据从自身层传到另一个层。比如一个简单的用于CIFAR-10图像分类的网络结构：</p>
<blockquote>
<p>[输入层-卷积层-ReLU层-汇聚层-全连接层]</p>
</blockquote>
<p>1.输入层即是输入[32*32*3]的原始图像像素值</p>
<p>2.卷基层中，神经元与输入层的一个局部区域相连，每个神经元都计算自己与输入层相连的小区域与自己权重的内积。卷积层会计算所有神经元的输出。如果我们使用12个滤波器（也叫作核），得到的输出数据体的维度就是[32x32x12]。</p>
<p>3.ReLU层将会逐个元素地进行激活函数操作，比如使用以0为阈值的max(0,x)作为激活函数。该层对数据尺寸没有改变，还是[32x32x12]。</p>
<p>4.汇聚层在在空间维度（宽度和高度）上进行降采样（downsampling）操作，数据尺寸变为[16x16x12]。</p>
<p>5.全连接层将会计算分类评分，数据尺寸变为[1x1x10]，其中10个数字对应的就是CIFAR-10中10个类别的分类评分值。正如其名，全连接层与常规神经网络一样，其中每个神经元都与前一层中所有神经元相连接。</p>
<p>具体说来，卷积层和全连接层（CONV/FC）对输入执行变换操作的时候，不仅会用到激活函数，还会用到很多参数（神经元的突触权值和偏差）。而ReLU层和汇聚层则是进行一个固定不变的函数操作，它没有参数（汇聚层有额外的超参数）。卷积层和全连接层中的参数会随着梯度下降被训练，这样卷积神经网络计算出的分类评分就能和训练集中的每个图像的标签吻合了。</p>
<h2 id="卷基层与汇聚层"><a href="#卷基层与汇聚层" class="headerlink" title="卷基层与汇聚层"></a>卷基层与汇聚层</h2><h3 id="卷基层"><a href="#卷基层" class="headerlink" title="卷基层"></a>卷基层</h3><p>  从卷积神经网络的名字你就应该知道什么层是核心，卷基层产生了网络中的大部分计算量。</p>
<h4 id="滤波器"><a href="#滤波器" class="headerlink" title="滤波器"></a>滤波器</h4><p>  首先你肯定想知道卷积层是怎么样计算的，先明确的一点是：<strong>卷基层的参数是由一些可学习的滤波器（即一组固定权重的集合，又被称作卷积核）集合构成的。</strong>这些滤波器的宽度和高度都比较小，但是深度与输入数据一致。比如在上面CIFAR例子中的第一层卷积层与输入层相连，它的滤波器大小可能是5*5*3，其中5<em>5是宽高，而3则与数据体的RGB通道深度相同。在前向传播的时候，让每个滤波器都在输入数据的宽度和高度上滑动（更精确地说是卷积），然后计算整个滤波器和输入数据任一处的内积。当<strong>滤波器沿着输入数据的宽度和高度滑过</strong>后，会生成一个2维的激活图（activation map），激活图给出了在每个空间位置处滤波器的反应。直观地来说，网络会让滤波器学习到当它看到某些类型的视觉特征时就激活。<em>*在每个卷积层上，我们会有一整个集合的滤波器（比如12个），每个都会生成一个不同的二维激活图。将这些激活映射在深度方向上层叠起来就生成了输出数据。</em></em></p>
<h4 id="感受野"><a href="#感受野" class="headerlink" title="感受野"></a>感受野</h4><p>  图像数据是高维的，如果让每个神经元与之进行全连接，那么将会产生大量的参数以至于计算量不能忍受。于是我们让每个神经元只与输入数据的一个局部区域进行连接，这个局部区域的尺寸（高宽）是一个超参数，我们把它叫做神经元的<strong>感受野</strong>。但是可以确定的是，在数据深度上这个连接大小与输入数据一致。比如：</p>
<p><em>例1</em>：假设输入数据体尺寸为[32x32x3]（比如CIFAR-10的RGB图像），如果感受野（或滤波器尺寸）是5x5，那么卷积层中的每个神经元会有输入数据体中[5x5x3]区域的权重，共5x5x3=75个权重（还要加一个偏差参数）。注意这个连接在深度维度上的大小必须为3，和输入数据体的深度一致。</p>
<p><em>例2</em>：假设输入数据体的尺寸是[16x16x20]，感受野尺寸是3x3，那么卷积层中每个神经元和输入数据体就有3x3x20=180个连接。再次提示：在空间上连接是局部的（3x3），但是在深度上是和输入数据体一致的（20）。</p>
<h3 id="输出数据体"><a href="#输出数据体" class="headerlink" title="输出数据体"></a>输出数据体</h3><p>  现在我们知道了卷积层中神经元与输入数据体中的连接方式，那么卷积层的输出数据体是怎么样的呢？有三个超参数控制着输出数据体的尺寸：<strong>即深度，步长和零填充。</strong></p>
<p>  输出数据体的深度是一个超参数，它与滤波器数量一致，每个滤波器在输入数据中寻找一些不同的东西。举例来说，如果第一个卷积层的输入是原始图像，那么在深度维度上的不同神经元将可能被不同方向的边界，或者是颜色斑点激活。我们将这些沿着深度方向排列、感受野相同的神经元集合称为<strong>深度列（depth column）</strong>，也有人使用纤维（fibre）来称呼它们。</p>
<p>  另外，滑动滤波器的时候，需要指定步长，这个步长大小同零填充的大小一起决定了输出数据体的高宽。步长和零填充的大小都是超参数。填充有一个良好性质，即可以控制输出数据体的空间尺寸（最常用的是用来保持输入数据体在空间上的尺寸，这样输入和输出的宽高都相等）。</p>
<p>  输出数据体在空间（高度和宽度）上的尺寸可以通过输入数据体尺寸（W），卷积层中神经元的感受野尺寸（F），步长（S）和零填充的数量（P）的函数来计算。（<strong>*译者注</strong>：这里假设输入数组的空间形状是正方形，即高度和宽度相等<em>）<em>*输出数据体的空间尺寸为(W-F +2P)/S+1</em></em>（注意如果这个公式得出的值不是一个整数，说明你的步长和零填充的设置是无效的）。比如输入是7x7，滤波器是3x3，步长为1，填充为0，那么就能得到一个5x5的输出。</p>
<h3 id="参数共享"><a href="#参数共享" class="headerlink" title="参数共享"></a>参数共享</h3><p>  在2012年的ImageNet挑战中，Krizhevsky采用了这么一个设定，输入图像的尺寸是[227x227x3]。在第一个卷积层，神经元使用的感受野尺寸<strong>F=11</strong>，步长<strong>S=4</strong>，不使用零填充<strong>P=0</strong>。因为(227-11)/4+1=55，卷积层的深度<strong>K=96</strong>，则卷积层的输出数据体尺寸为[55x55x96]。</p>
<p>  我们可以看到上面举出的这个第一个卷积层就有55*55*96=290,400个神经元，每个有11*11*3个参数和一个偏差，你可以乘一下就发现，第一层卷积层参数就上亿了，显然我们需要一些策略来避免这种情况发生，这个策略就是<strong>参数共享</strong>。</p>
<p>  一个合理的假设：如果一个特征在计算某个空间位置(x,y)的时候有用，那么它在计算另一个不同位置(x2,y2)的时候也有用。基于这个假设，可以显著地减少参数数量。换言之，就是将深度维度上一个单独的2维切片看做<strong>深度切片（depth slice）</strong>，比如一个数据体尺寸为[55x55x96]的就有96个深度切片，每个尺寸为[55x55]。在这样的参数共享下，例子中的第一个卷积层就只有96个不同的权重集了，一个权重集对应一个深度切片，共有96x11x11x3=34,848个不同的权重，或34,944个参数（+96个偏差）。）。在每个深度切片中的55x55个权重使用的都是同样的参数。<strong>在反向传播的时候，都要计算每个神经元对它的权重的梯度，但是需要把同一个深度切片上的所有神经元对权重的梯度累加，这样就得到了对共享权重的梯度。</strong>这样，每个切片只更新一个权重集。</p>
<p>  注意，如果在一个深度切片中的所有权重都使用同一个权重向量，那么卷积层的前向传播在每个深度切片中可以看做是在计算神经元权重和输入数据体的<strong>卷积</strong>（这就是“卷积层”名字由来）。这也是为什么总是将这些权重集合称为<strong>滤波器（filter）</strong>（或<strong>卷积核（kernel）</strong>），因为它们和输入进行了卷积。下图演示了一个卷积过程，该图中几个超参数分别是K=2（卷积层深度），F=3（感受野尺寸），S=2（步长），P=1（零填充）：</p>
<p><img src="\img\20160707204048899.gif" alt="20160707204048899"></p>
<p>我们可以看到，在该图中对一个深度切片（蓝色部分每一个矩阵），都用相同的权重进行卷积的过程。</p>
<h3 id="汇聚层"><a href="#汇聚层" class="headerlink" title="汇聚层"></a>汇聚层</h3><p>  一般我们都会在连续的卷积层之间周期性的插入一个汇聚层，目的是为了降低数据体的空间尺寸，这样的话就能够减少网络中参数的尺寸，从而降低计算成本，另外还有控制过拟合的好处。</p>
<p>  汇聚层也是对输入数据体的每一个深度切片独立进行MAX操作，以改变其空间尺寸（高宽）。最常见的形式是汇聚层使用尺寸2x2的滤波器，以步长为2来对每个深度切片进行降采样，将其中75%的激活信息都丢掉。每个MAX操作是从4个数字中取最大值（也就是在深度切片中某个2x2的区域）。深度保持不变。</p>
<p>汇聚层也有计算公式：</p>
<p>  输入数据体高H1，宽W1，深度为D1</p>
<p>  MAX操作空间大小为F,步长为S</p>
<p>  那么输出数据体:</p>
<p>  宽度：W2=(W1-F)/S+1</p>
<p>  高度：H2=(H1-F)/S+1</p>
<p>  深度不变：D2=D1</p>
<p>一般来说MAX汇聚层只有两种形式：F=3，S=2还有前面说的最常用的F=2，S=2。</p>
<p><img src="\img\641c8846abcb02d35938660cf96cef1b_r.jpg" alt="641c8846abcb02d35938660cf96cef1b_r"></p>
<h4 id="汇聚层反向传播"><a href="#汇聚层反向传播" class="headerlink" title="汇聚层反向传播"></a>汇聚层反向传播</h4><p><strong>反向传播：</strong>回顾一下反向传播的内容，其中max(x,y)函数的反向传播可以简单理解为将梯度只沿最大的数回传。因此，在向前传播经过汇聚层的时候，通常会把池中最大元素的索引记录下来（有时这个也叫作<strong>道岔（switches）</strong>），这样在反向传播的时候梯度的路由就很高效。</p>
<p>有些人更倾向于在卷积层中使用更大的步长来降低数据体的尺寸，而不是在模型中使用汇聚层，另外有发现认为，在训练一个良好的生成模型时，弃用汇聚层也是很重要的。</p>
<h2 id="全连接层到卷积层的转换"><a href="#全连接层到卷积层的转换" class="headerlink" title="全连接层到卷积层的转换"></a>全连接层到卷积层的转换</h2><p>全连接层和卷积层之间唯一的不同就是卷积层中神经元只与输入数据中的一个局部区域连接，并且在卷积列中的神经元共享参数。但是两类层中神经元都是计算点积，它们的函数形式实际上是相同的。</p>
<p>我们可以把卷积层转化为一个全连接层，这个全连接层的权重矩阵是巨大的，除了某些特定的块，其余部分都是零（局部连接）。而大部分块中，元素都是相等的（参数共享）。</p>
<p>那么，全连接层也能够被转化为卷积层，因为卷积层连接局部，但是如果这个局部大小大到了和全局一样，那就成了全连接层了。<strong>以卷积层代替全连接层可以让卷积网络在一张更大的输入图片上滑动，得到每个区域的输出（这样就突破了输入尺寸的限制）。下面这段话全部看完可以理解它的意思：</strong></p>
<blockquote>
<p>举个例子，如果我们想让224x224尺寸的浮窗，以步长为32在384x384的图片上滑动，把每个经停的位置都带入卷积网络，最后得到6x6个位置的类别得分。上述的把全连接层转换成卷积层的做法会更简便。如果224x224的输入图片经过卷积层和汇聚层之后得到了[7x7x512]的数组，那么，384x384的大图片直接经过同样的卷积层和汇聚层之后会得到[12x12x512]的数组（因为途径5个汇聚层，尺寸变为384/2/2/2/2/2 = 12）。然后再经过上面由3个全连接层转化得到的3个卷积层，最终得到[6x6x1000]的输出（因为(12 - 7)/1 + 1 = 6）。这个结果正是浮窗在原图经停的6x6个位置的得分！</p>
<p>面对384x384的图像，让（含全连接层）的初始卷积神经网络以32像素的步长独立对图像中的224x224块进行<strong>多次评价</strong>，其效果和使用把全连接层变换为卷积层后的卷积神经网络进行<strong>一次</strong>前向传播是一样的。</p>
<p>自然，相较于使用被转化前的原始卷积神经网络对所有36个位置进行迭代计算，使用转化后的卷积神经网络进行一次前向传播计算要高效得多，因为36次计算都在共享计算资源。这一技巧在实践中经常使用，一次来获得更好的结果。比如，通常将一张图像尺寸变得更大，<strong>然后使用变换后的卷积神经网络来对空间上很多不同位置进行评价得到分类评分，然后在求这些分值的平均值。</strong></p>
</blockquote>
<h2 id="一些对于层的建议"><a href="#一些对于层的建议" class="headerlink" title="一些对于层的建议"></a>一些对于层的建议</h2><h3 id="层的排列"><a href="#层的排列" class="headerlink" title="层的排列"></a>层的排列</h3><p>一个最常见的神经网络结构如下：</p>
<p><strong>INPUT -&gt; [[CONV -&gt; RELU]<em>N -&gt; POOL?]</em>M -&gt; [FC -&gt; RELU]*K -&gt; FC</strong></p>
<p>其中POOL后面的？代表汇聚层是可选的，如果没有其他说明POOL层都是MAX汇聚。</p>
<p>一般而言，几个小滤波器卷积层的组合比一个大滤波器卷积层好。比如你一层一层地重叠了3个3x3的卷积层（层与层之间有非线性激活函数）。在这个排列下，第一个卷积层中的每个神经元都对输入数据体有一个3x3的视野。第二个卷积层上的神经元对第一个卷积层有一个3x3的视野，也就是对输入数据体有5x5的视野。同样，在第三个卷积层上的神经元对第二个卷积层有3x3的视野，也就是对输入数据体有7x7的视野。假设不采用这3个3x3的卷积层，二是使用一个单独的有7x7的感受野的卷积层，那么所有神经元的感受野也是7x7，但是就有一些缺点。</p>
<p>1.多层小的卷积层能更好的提取出深层次的特征</p>
<p>2.在这里，3个3*3的卷积层的参数数目是3*3*3<em>通道数N，而7\</em>7的单个卷积层则是7*7*通道数N，这个数目要大于前者。</p>
<h3 id="层的尺寸"><a href="#层的尺寸" class="headerlink" title="层的尺寸"></a>层的尺寸</h3><p>输入层图像大小应该能被2整除多次，比如32，或者是诸如96或者224，384，512这样的数。</p>
<p>卷积层应该使用小的滤波器，比如3*3或者5*5，大的滤波器如果采用了也一般是接上原始输入层的第一个卷积层，并且我们一般会用适当的零填充来保持数据在空间维度上的尺寸，步长一般是1。在实际应用中，更小的步长效果更好。<strong>上文也已经提过，步长为1可以让空间维度的降采样全部由汇聚层负责，卷积层只负责对输入数据体的深度进行变换。</strong>如果卷积层值进行卷积而不进行零填充，那么数据体的尺寸就会略微减小，那么图像边缘的信息就会过快地损失掉。</p>
<p>对汇聚层的选择一般都是用比较小的感受野，比如2*2，一旦感受野太大可能会使得数据信息丢失。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  卷积神经网络也由有学习能力的神经元组成，这些神经元中也有权重和偏差。整个卷积神经网络实为是一个可导的评分函数，在神经网络中我们实现的各种技巧和要点依旧适用于卷积神经网络。但是&lt;strong&gt;卷积神经网络与一般神经网络不同的是，它基于一个假设，即输入的数据是图像&lt;/strong&gt;。基于这个假设，我们添加了一些特有的特性，从而让我们的前向传播更为高效，&lt;strong&gt;同时也大大降低了网络中的参数数量&lt;/strong&gt;。降低参数数量是一个很好的特性，因为在一般的神经网络中，因为是全连接的，如果要处理一个大点的图像，比如一个200*200*3的图像，一个神经元就有12万个权重，显然这是不可接受的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Notes of CS231n:Neural network 4</title>
    <link href="http://yoursite.com/2018/03/11/Notes-of-Deep-Learning-Neural-network-4/"/>
    <id>http://yoursite.com/2018/03/11/Notes-of-Deep-Learning-Neural-network-4/</id>
    <published>2018-03-11T13:30:24.000Z</published>
    <updated>2018-03-13T03:56:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>  我们利用反向传播计算出解析梯度，然后利用计算出的解析梯度来进行参数更新，这里记录一些有些的最优化技巧，但不进行细节分析。</p>
<a id="more"></a>
<h2 id="参数更新方法"><a href="#参数更新方法" class="headerlink" title="参数更新方法"></a>参数更新方法</h2><h3 id="普通更新"><a href="#普通更新" class="headerlink" title="普通更新"></a>普通更新</h3><p>  沿着负梯度方向改变参数是一个简单有效的方法，比如一个参数向量x，它的梯度为dx，那么这个简单的方法可以表示为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x+=learning_rate*dx</div></pre></td></tr></table></figure>
<h3 id="动量更新"><a href="#动量更新" class="headerlink" title="动量更新"></a>动量更新</h3><p>  普通更新的缺点是，其更新方向完全依赖于当前的batch，使得更新非常不稳定，从物理角度得到启发，人们想出来一种在深度网络上有着更好收敛速度且更新更稳定的方法，即<strong>动量(Momentum)更新</strong>。</p>
<p>  在上面的普通更新中我们可以看到梯度的大小直接影响到了x的值的更新，<strong>而动量更新则不同，它会由梯度去影响“速度”，然后速度再去影响x的更新</strong>，研究这个方法的人把损失值理解为一个高地，而参数更新这个最优化过程可以看做是一个质量以初始速度0，慢慢的加速，把梯度看做是提供这种加速度的力。听起来很玄学，这也能扯上关系？实际上所做的就是改变了x的更新方式而已，把以前的learning_rate*dx增量变成了一个更加科学的“速度”，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">v = mu * v - learning_rate * dx</div><div class="line">x += v</div></pre></td></tr></table></figure>
<p>其中这个mu是一个超参数，叫做动量，它模拟的物体运动的惯性，即更新的时候在一定程度上保留之前更新的方向，同时利用当前batch的梯度微调最终的更新方向，实际上它的意义更加贴近于阻尼系数，mu<em>v提供了一个阻力，这个变量会抑制速度，<em>*一般mu设置为0.9</em></em>，也有一些研究表明mu随时间变化能略改善最优化效果，比如一个典型的设置是一开始mu=0.5，而随后在多个周期中慢慢提升到0.99，[0.5,0.9,0.95,0.99]。</p>
<h3 id="Nesterov动量更新"><a href="#Nesterov动量更新" class="headerlink" title="Nesterov动量更新"></a>Nesterov动量更新</h3><p>  对于动量更新，还有一个增强版的思路，理论上它对于凸函数的收敛有帮助，实践中似乎也确实比上面的标准动量更新表现好点。</p>
<p>  这个思路在于考虑到，更新时，mu*v这个项会稍加改变参数向量，我们最好是在x+mu*v这个近似未来的位置附近计算梯度，而不是在x处计算，这样我们的代码可以变为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x_ahead = x + mu * v</div><div class="line"><span class="comment"># 计算dx_ahead(在x_ahead处的梯度，而不是在x处的梯度)</span></div><div class="line">v = mu * v - learning_rate * dx_ahead</div><div class="line">x += v</div></pre></td></tr></table></figure>
<p><img src="\img\20150906103038485.png" width="600px\"></p>
<p>  首先，按照原来的更新方向更新一步（棕色线），然后在该位置计算梯度值（红色线），然后用这个梯度值修正最终的更新方向（绿色线）。上图中描述了两步的更新示意图，其中蓝色线是标准momentum更新路径。</p>
<h3 id="二阶方法"><a href="#二阶方法" class="headerlink" title="二阶方法"></a>二阶方法</h3><p>  实际上除了各种随机梯度下降算法以外还有一种方法是基于牛顿法的，但是因为实现起来比较困难并不常用。</p>
<h2 id="学习率动态设定"><a href="#学习率动态设定" class="headerlink" title="学习率动态设定"></a>学习率动态设定</h2><h3 id="学习率退火"><a href="#学习率退火" class="headerlink" title="学习率退火"></a>学习率退火</h3><p>学习率随着时间慢慢减小对深度学习训练很有帮助，我们并不想看着参数向量无规律的跳动，但是如果学习率过高这很可能发生，并且意味着我们很难达到最好的位置。一般我们有以下三种退火方式：</p>
<p><strong>随步数衰减</strong>：每隔几个周期就根据某些因素降低学习 率，比如每5个周期减半，或者每20个周期减少到之前的0.1。训练的同时观察验证集的错误率，每当验证集错误率停止下降，就将原来的学习率乘以一个常数比例来降低它。</p>
<p><strong>指数衰减</strong>：a=a[0]e^(-kt),a0和k是超参数，t是迭代次数或者周期</p>
<p><strong>1/t衰减</strong>：a=a[0]/(1+kt),a0和k是超参数，t是迭代次数或者周期</p>
<p>实践中一般都采用第一种方法。</p>
<h3 id="逐参数适应学习率方法"><a href="#逐参数适应学习率方法" class="headerlink" title="逐参数适应学习率方法"></a>逐参数适应学习率方法</h3><p>学习率调参是很耗费计算资源的过程，所以很多工作投入到发明能够适应性地对学习率调参的方法，甚至是逐个参数适应学习率调参。这里将记录一些常用的适应算法。</p>
<h4 id="Adagrad"><a href="#Adagrad" class="headerlink" title="Adagrad"></a>Adagrad</h4> <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 假设有梯度和参数向量x</span></div><div class="line">cache += dx**<span class="number">2</span></div><div class="line">x += - learning_rate * dx / (np.sqrt(cache) + eps)</div></pre></td></tr></table></figure>
<p>Adagrad的一个缺点是，在深度学习中单调递减的学习率被证明通常过于激进且过早停止学习。这里的<strong>eps是一个很小的数</strong>，通常为1e-4到1e-8之间，<strong>引入它的目的是为了防止出现除以0这种不合法情况出现</strong>。</p>
<h4 id="RMSprop"><a href="#RMSprop" class="headerlink" title="RMSprop"></a>RMSprop</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cache =  decay_rate * cache + (1 - decay_rate) * dx**2</div><div class="line">x += - learning_rate * dx / (np.sqrt(cache) + eps)</div></pre></td></tr></table></figure>
<p>RMSprop（Root Mean Square Propagation）方法是Adagrad的改进版本，没有公开发表，但是却非常高效，它来自Geoff Hinton的Coursera课程的<a href="http://link.zhihu.com/?target=http%3A//www.cs.toronto.edu/%257Etijmen/csc321/slides/lecture_slides_lec6.pdf" target="_blank" rel="external">第六课的第29页PPT</a>。上面的代码里decay_rate是一个超参数，常用值是[0.9,0.99,0.999]。你可以观察这个方法改变了cache的计算部分，而第二个式子却是相同的。RMSProp任然是基于梯度的大小来对每个权重的学习率进行修改，但是学习率不会再单调递减，这是和Adagrad的主要区别，也就是说该方法更不那么激进。</p>
<h4 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">m = beta1*m + (<span class="number">1</span>-beta1)*dx</div><div class="line">v = beta2*v + (<span class="number">1</span>-beta2)*(dx**<span class="number">2</span>)</div><div class="line">x += - learning_rate * m / (np.sqrt(v) + eps)</div></pre></td></tr></table></figure>
<p>Adam（Adaptive Moment Estimation）是推荐使用的方法，一般而言跑起来比RMSProp要好一点。但是也可以试试SGD+Nesterov动量。Adam方法看起来真的和RMSProp很像，除了使用的是平滑版的梯度<strong>m</strong>，而不是用的原始梯度向量<strong>dx</strong>。论文中推荐的参数值<strong>eps=1e-8, beta1=0.9, beta2=0.999</strong>。完整的Adam更新算法也包含了一个偏置<em>（bias）矫正</em>机制，因为<strong>m,v</strong>两个矩阵初始为0，在没有完全热身之前存在偏差，需要采取一些补偿措施。</p>
<h2 id="超参数调优"><a href="#超参数调优" class="headerlink" title="超参数调优"></a>超参数调优</h2><p>  你知道一个模型中往往存在着很多超参数，比如随机失活的概率p，以及我们上面提到的种种适应学习率算法中的超参数，我们上面已经给出了一些好的实践值，但是有可能你想去找到更好的值，或者你研究新算法需要有新的超参数。</p>
<h3 id="采用仆程序"><a href="#采用仆程序" class="headerlink" title="采用仆程序"></a>采用仆程序</h3><p>我们可以采用仆程序持续的设置参数然后进行最优化，并且它对各个周期后验证集的准确率进行监控，并将这个记录点的模型数据（记录点中有各种各样的训练统计数据，比如随着时间的损失值变化等）记录到相关文件中。</p>
<h3 id="只使用单个验证集"><a href="#只使用单个验证集" class="headerlink" title="只使用单个验证集"></a>只使用单个验证集</h3><p>为了让代码更简单，可以只采用一个合理尺寸的验证集，而不是采用几个数据集来交叉验证。</p>
<h3 id="使用随机搜索"><a href="#使用随机搜索" class="headerlink" title="使用随机搜索"></a>使用随机搜索</h3><p>比起“网格式”搜索（即相同的间距），随机搜索往往更容易实现也更加好。</p>
<h3 id="对于边界上的最优值要小心"><a href="#对于边界上的最优值要小心" class="headerlink" title="对于边界上的最优值要小心"></a>对于边界上的最优值要小心</h3><p>这种情况一般发生在你在一个不好的范围内搜索超参数（比如学习率）的时候。比如我们使用<strong>learning_rate = 10 \</strong> uniform(-6,1)**来进行搜索。假设我们得到一个比较好的值-6，一定要确认你的值不是出于这个范围的边界上，不然你可能错过更好的其他搜索范围,就像这里可能-6是边界值而最好的结果在-8和-6之间。</p>
<h3 id="从粗到细地分阶段搜索"><a href="#从粗到细地分阶段搜索" class="headerlink" title="从粗到细地分阶段搜索"></a>从粗到细地分阶段搜索</h3><p>在实践中，先进行初略范围（比如10 ** [-6, 1]）搜索，然后根据好的结果出现的地方，缩小范围进行搜索。进行粗搜索的时候，让模型训练一个周期就可以了，因为很多超参数的设定会让模型没法学习，或者突然就爆出很大的损失值。第二个阶段就是对一个更小的范围进行搜索，这时可以让模型运行5个周期，而最后一个阶段就在最终的范围内进行仔细搜索，运行很多次周期。</p>
<h2 id="模型集成"><a href="#模型集成" class="headerlink" title="模型集成"></a>模型集成</h2><p>实践中有一个方法总是能提升神经网络几个百分点的准确率，即在训练的时候训练几个独立模型，然后在测试的时候平均它们的预测结果。集成的模型数量增加，算法的结果也单调提升（但提升效果越来越少）。还有模型之间的差异度越大，提升效果可能越好。进行集成有以下几种方法：</p>
<p>1.相同的模型，不同的初始化。</p>
<p>2.使用不同的超参数的模型。这些模型都是分别训练的。</p>
<p>3.如果训练太耗时，可以采用一次训练中不同的记录点（仆程序记录）的模型来进行集成。</p>
<p>4.在训练的时候跑参数的平均值。和上面一点相关的，还有一个也能得到1-2个百分点的提升的小代价方法，这个方法就是在训练过程中，如果损失值相较于前一次权重出现指数下降时，就在内存中对网络的权重进行一个备份。这样你就对前几次循环中的网络状态进行了平均。你会发现这个“平滑”过的版本的权重总是能得到更少的误差。直观的理解就是目标函数是一个碗状的，你的网络在这个周围跳跃，所以对它们平均一下，就更可能跳到中心去。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  我们利用反向传播计算出解析梯度，然后利用计算出的解析梯度来进行参数更新，这里记录一些有些的最优化技巧，但不进行细节分析。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Notes of CS231n:Neural network 3</title>
    <link href="http://yoursite.com/2018/03/10/Notes-of-Deep-Learning-Neural-network-3/"/>
    <id>http://yoursite.com/2018/03/10/Notes-of-Deep-Learning-Neural-network-3/</id>
    <published>2018-03-10T05:41:24.000Z</published>
    <updated>2018-03-12T08:37:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>  在上一篇文章中，记录了如何构造一个神经网络，比如如何初始化参数，如何选择激活函数和损失函数，应该用哪种方法来防止过拟合等等，在这篇记录中，记录的是如何训练一个神经网络，包括如何学习参数以及如何将超参数最优化。</p>
<a id="more"></a>
<h2 id="梯度检测"><a href="#梯度检测" class="headerlink" title="梯度检测"></a>梯度检测</h2><p>  梯度检测就是把解析梯度和数值梯度进行比较，这里只是记录一些小技巧：</p>
<h3 id="使用中心化公式而不是有限差值来近似"><a href="#使用中心化公式而不是有限差值来近似" class="headerlink" title="使用中心化公式而不是有限差值来近似"></a>使用中心化公式而不是有限差值来近似</h3><p>即使用[f(x+h)+f(x-h)]/2h来计算数值梯度，该公式计算出的梯度会近似于O(h^2)，该结果是通过对f(x+h)，f(x-h)进行泰勒展开得到的。</p>
<h3 id="使用相对误差来进行梯度检测"><a href="#使用相对误差来进行梯度检测" class="headerlink" title="使用相对误差来进行梯度检测"></a>使用相对误差来进行梯度检测</h3><p>我们知道数值梯度和解析梯度的差值正负值都有可能，很明显我们需要取这个差值的绝对值，但是我们不得不考虑实际梯度的大小，即我们要考虑这个误差绝对值占实际梯度的百分比，如果梯度是1000，误差是0.1和梯度是1e-4梯度是1.0，实际上比率是一样的，如果一个梯度是1而误差达到了0.5这个样子显然我们就得考虑梯度计算是不是错了。</p>
<p>所以我们利用|f’[a]-f’[n]|/max(f’[a],f’[n])来计算相对误差作为我们的误差值，这是一个比率值，我们倾向于在实践中采用这种判断：</p>
<p>相对误差&gt;1e-2时，梯度可能出错了</p>
<p>1e-2&gt;相对误差&gt;1e-4：这个值可能不是很好，但勉强说得过去</p>
<p>1e-4&gt;相对误差：可以接受</p>
<p>1e-7或者更小：比较完美了</p>
<h3 id="注意误差伴随深度积累"><a href="#注意误差伴随深度积累" class="headerlink" title="注意误差伴随深度积累"></a>注意误差伴随深度积累</h3><p><strong>有时候我们还是得视情况而定</strong>，要知道误差是在不断积累的，随着深度的加深误差也在不断增大，那么我们可以改变上面的策略，比如一个网络深度达到数十层时1e-2就是可以接受的了。</p>
<h3 id="注意目标函数中存在的不可导点"><a href="#注意目标函数中存在的不可导点" class="headerlink" title="注意目标函数中存在的不可导点"></a>注意目标函数中存在的不可导点</h3><p>ReLU等函数存在着不可导点，我们知道ReLU中如果出现了x&lt;0的情况，在该点梯度就是0，但是如果这个x值比较小，比如-0.000001我们增加了一个小的增量h，可能此时的h就不是负数了，f(x+h)在可导的点上，从而梯度检查认为这个梯度计算错了。</p>
<p><strong>使用少量数据点。</strong>解决上面的不可导点问题的一个办法是使用更少的数据点。因为含有不可导点的损失函数(例如：因为使用了ReLU或者边缘损失等函数)的数据点越少，不可导点就越少，所以在计算有限差值近似时越过不可导点的几率就越小。还有，如果你的梯度检查对2-3个数据点都有效，那么基本上对整个批量数据进行梯度检查也是没问题的。所以使用很少量的数据点，能让梯度检查更迅速高效。</p>
<h3 id="梯度检查中h的设置"><a href="#梯度检查中h的设置" class="headerlink" title="梯度检查中h的设置"></a>梯度检查中h的设置</h3><p>h并不是越小越好，太小了会遇到精度和数值问题，一般可以设置为1e-4或者1e-6</p>
<h3 id="梯度检查前先“预热”"><a href="#梯度检查前先“预热”" class="headerlink" title="梯度检查前先“预热”"></a>梯度检查前先“预热”</h3><p>我们的梯度检查只是在参数空间中一个特定的单独的点进行的，所以并不能很稳的确定全局梯度都正确。一般来说我们不再一开始就进行梯度检查，而是等到损失函数开始下降之后在进行梯度检查。</p>
<h3 id="当心正则化损失"><a href="#当心正则化损失" class="headerlink" title="当心正则化损失"></a>当心正则化损失</h3><p>上一文记录损失函数最后的值是正则化损失和数据损失的和，有些情况梯度主要来源于正则化部分，因此会掩盖数据损失梯度不正确的事实。为了防止这种情况出现我们可以先关掉正则化对数据损失做单独检查，当然这也做会导致我们需要再对正则化损失做单独检查。</p>
<h3 id="关闭随机失活和数据扩张"><a href="#关闭随机失活和数据扩张" class="headerlink" title="关闭随机失活和数据扩张"></a>关闭随机失活和数据扩张</h3><p>在进行梯度检查时，记得关闭网络中任何不确定的效果的操作，比如随机失活，随机数据扩展等。不然它们会在计算数值梯度的时候导致巨大误差。关闭这些操作不好的一点是无法对它们进行梯度检查（例如随机失活的反向传播实现可能有错误）我们可以在计算f(x+h)和f(x-h)时强制增加一个特定是随机种子，在计算解析梯度时也同样如此。</p>
<h3 id="检查少量的维度"><a href="#检查少量的维度" class="headerlink" title="检查少量的维度"></a>检查少量的维度</h3><p>在实际中，梯度可以有上百万的参数，在这种情况下只能检查其中一些维度然后假设其他维度是正确的。注意：确认在所有不同的参数中都抽取一部分来梯度检查。在某些应用中，为了方便，人们将所有的参数放到一个巨大的参数向量中。在这种情况下，例如偏置就可能只占用整个向量中的很小一部分，所以不要随机地从向量中取维度，一定要把这种情况考虑到，确保所有参数都收到了正确的梯度。</p>
<h2 id="跟踪各个重要数值"><a href="#跟踪各个重要数值" class="headerlink" title="跟踪各个重要数值"></a>跟踪各个重要数值</h2><p>  跟踪并可视化我们的训练过程可以让我们尽早的发现一些问题，我们所跟踪的一般是一些比较重要的数值，我们通常每个<strong>周期</strong>进行一轮跟踪，这里的<strong>周期</strong>衡量了在训练中每个样本数据都被观察过次数的期望（一个周期意味着每个样本数据都被观察过了一次）。</p>
<p>1.跟踪损失值</p>
<p>以周期为x轴度量，损失值的曲线往往会反应我们所设置的学习率的问题，比如：</p>
<p><img src="\img\loss_learningrate.png" alt="loss_learningrate"></p>
<p>上图左图中我们可以观察到学习率与损失值的关系，右图则反应了损失值的震荡程度，这与批尺寸（batch size）有关（这里的批指的是我们一般把训练集拆分成多个批次，每次取一个训练），如果批尺寸太小了比如1，那么每次修正方向以各自样本的梯度方向修正，难以达到收敛震荡幅度就大，而如果以整个训练集大小为批尺寸则震荡幅度最小，但是这并不是一个好的想法，首先内存容量增加，第二我们可能得不到最好的结果，batchsize 的正确选择是为了在内存效率和内存容量之间寻找最佳平衡，比如我们可以看下图：</p>
<p><img src="\img\lU3sx.png" alt="lU3sx"></p>
<p>红色代表批尺寸为1，绿色为一个适中的尺寸，蓝色为不分批次，即全尺寸，我们可以观察到震荡程度是不同的。</p>
<p>2.跟踪训练集和验证集的准确率</p>
<p>跟踪准确率可以知道我们的模型是不是过拟合了，如图：</p>
<p><img src="\img\QQ图片20180310170549.png" alt="QQ图片20180310170549"></p>
<p>如果观察到我们的模型过拟合了，就应该增大正则化强度，比如调高随机失活率p，或者将L1损失换位到L2损失，采用更丰富的数据集等等，当然如果你的模型太小也会导致过拟合，这时候我们就应该考虑更换更大的模型了。</p>
<p>3.跟踪权重的跟新比例</p>
<p>  权重中更新值的数量和全部值的数量之间的比例也是我们值得更新的。注意：是<em>更新的</em>，而不是原始梯度（比如，在普通sgd中就是梯度乘以学习率）。需要对每个参数集的更新比例进行单独的计算和跟踪。一个经验性的结论是这个比例应该在1e-3左右。如果更低，说明学习率可能太小，如果更高，说明学习率可能太高。</p>
<p>4.跟踪每层激活数据和梯度分布</p>
<p>  我们可以观察激活函数的输出，把这些数据变成柱状与表示会更明显，比如对于tanh函数，如果神经元输出总是0，或者总是-1或1，那说明可能出现了某些问题了。</p>
<p>5.如果是图像数据考虑将第一层特征可视化</p>
<p>如果需要做的是图像方面的识别，我们考虑将第一层特征显示出来，比如：</p>
<p><img src="\img\96573094f9d7f4b3b188069726840a2e_r.jpg" alt="96573094f9d7f4b3b188069726840a2e_r"></p>
<p>  上图中，很明显前面的图，特征非常不平滑，很多噪点，而后面则好得多，一般如果我们训练模型得到的是第一张图这种特征你需要仔细考虑是不是要重新训练模型了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  在上一篇文章中，记录了如何构造一个神经网络，比如如何初始化参数，如何选择激活函数和损失函数，应该用哪种方法来防止过拟合等等，在这篇记录中，记录的是如何训练一个神经网络，包括如何学习参数以及如何将超参数最优化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Notes of CS231n:Neural network 2</title>
    <link href="http://yoursite.com/2018/03/01/Notes-of-Deep-Learning-Neural-network-2/"/>
    <id>http://yoursite.com/2018/03/01/Notes-of-Deep-Learning-Neural-network-2/</id>
    <published>2018-03-01T02:26:43.000Z</published>
    <updated>2018-03-12T08:36:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>  从上一篇博文，我们知道，神经网络其实就是一个一系列线性映射和非线性激活函数交织起来的评分函数，我们在输入层输入我们的数据，经过隐层的一系列点积和激活函数计算在输出层得到一个类型评分，然而要比较好地训练一个神经网络，我们需要更多的考虑，比如数据预处理，我们还需要考虑权重的初始值以及如何选择激活函数。</p>
<h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>  我们通常会对<strong>训练集</strong>数据进行预处理，当然这可能有很多种形式，比如我们如果要去除一些噪声可能要进行数据清洗，这一部分这里先不介绍了，我们这里主要介绍归一化，归一化可以有利于避免模型训练时出现数值问题，还有利于网络快速收敛，更具体的优点你可以查看<a href="http://nnetinfo.com/nninfo/showText.jsp?id=37" target="_blank" rel="external">这里</a>。</p>
<p>  归一化（Normalization）即把数据的所有维度都归一化，使其数值范围都近似相等，这个种预处理操作只在确信不同输入特征有不同的输入范围时才有意义，对于图像处理中，像素的范围都是0-255，所以这样做对于图片数据意义不大，但是数据如果是表示一个人，（体重（kg），身高（m），年龄）,这样的数据显然60Kg的体重和1.7m的身高不太对等，这会产生一些数值问题，我们有必要进行归一化。这里有两种方式进行<strong>归一化</strong>：</p>
<p>先假设数据矩阵M，尺寸是N*D,N为样本数目，D是数据维度</p>
<p>第一种：对数据先做零中心化(zero-centered)，如果用numpy表示：M-=np.mean(X,axis=0)，然后我们对每个维度都除以它的标准差就可以了，M/=np.std(X,axis=0)。</p>
<p>第二种：对每个维度归一化使得每个维度的最大和最小值是1和-1。</p>
<a id="more"></a>
<p>  实际上零中心化单独也可以看成是一种预处理操作，被称作是<strong>均值减法</strong>在实际中用的也比较多，另外由于近来BN层的引入，归一化在有BN层的情况下也就没有必要了，因为每次卷积后BN层会把数据拉到0均值1方差的分布（标准高斯分布）上，并且这个均值和方差还是更加精确的动态统计出来的，而非原始输入上统计，因此在BN引入后归一化没什么必要。</p>
<p>  我在前面就说过，数据预处理，归一化只是一种情况，还可能进行数据清洗，数据增强，白化和PCA等等操作，图片处理中有时候我们还会转换图片的格式，这也是一种预处理。预处理在模型训练中非常重要，有时候甚至决定着学习算法本身的好坏。</p>
<h2 id="权重初始化"><a href="#权重初始化" class="headerlink" title="权重初始化"></a>权重初始化</h2><p>  要训练我们的网络，我们确定好我们需要一个怎么样的模型，然后构建一个最开始的网络，这样的话，网络中各种参数的初始值就显得非常重要，权重就是其中之一。</p>
<p>  一些人可能会认为把权重都设置为0比较好，然而仔细思考一下，如果一开始整个网络中每一个神经元的输出都是一样的（权重相同），那么反向传播中他们会输出同样的梯度，从而进行同样的更新，这显然就是不对的，你相当于复制了神经元。</p>
<p>  因为数据进行了适当的归一化，又要避免相同的参数更新，我们可以让权重的初始值接近于0，但是却又不等于0，为了得到不同的权重，我们可以以随机数产生器器来初始化我们的权重，这里我们产生的随机数可以服从正态分布或者均匀分布。需要注意的时，最好不要让随机值太小，因为太小的权重值会导致计算出的额梯度非常小，以至于一致我们在反向传播中的梯度信号。</p>
<p>  为了保证神经元起始时有近似相同的输出分布，我们必须想办法校准方差，一般的方法是采用1/sqrt(N)，来做校准，其中N是输入数据的数量，这样我们可以把输出数据的分布的方差校准到1，如果用numpy表示，即：w=np.random.randn(N)/sqrt(n)。</p>
<p>  有一种被称作<strong>稀疏初始化</strong> 的方法，将索引权重设置为0，但是为了避免相同的参数更新，每个神经元都同下一层固定数目的神经元随机连接，连接权重的数值由一个小的高斯分布生成。</p>
<p>  当前比较推荐的方法是在激活函数是ReLU的情况下使用，w=np.random.randn(N)/sqrt(2/n)来进行权重初始化，另外我们一般把偏置设置为0。</p>
<p>  上面介绍数据预处理的时候我们提到过一个被称为BN层(Batch Normalization)的东西，中文翻译是：<strong>批量归一化</strong>，它不仅可以避免<strong>归一化</strong>操作，也可以帮助我们解决初始化神经网络这个问题，我们通常会在全连接或者卷积层与激活函数之间添加一个BN层，让数据服从标准高斯分布，详细操作可以看这篇<a href="https://arxiv.org/abs/1502.03167" target="_blank" rel="external">文章</a>。</p>
<h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><p>  我们在上一篇文章中知道了，正则化是避免过拟合的好方法，正则化也有很多种,比如最常见的L2正则化，以及你听的非常多的随机失活(dropout)方法。</p>
<h3 id="L1，L2正则化"><a href="#L1，L2正则化" class="headerlink" title="L1，L2正则化"></a>L1，L2正则化</h3><p>1.L2正则化</p>
<p>  <strong>L2正则化的思想是对大数值的权重向量进行严厉的惩罚，从而倾向于权重向量更加分散，即使网络更倾向于使用所有的特征。</strong>实际操作是对网络中的每个权重w，向目标函数中增加一个<strong>1/2（λ*w^2)</strong>,λ是正则化强度，而乘上常数1/2是数学上的小技巧，即让求导后梯度变成λw，而非2λw。在梯度下降和参数更新的时候，使用L2正则化意味着所有的权重都以<strong>w += -lambda * W</strong>向着0线性下降。</p>
<p>2.L1正则化</p>
<p>  <strong>L1正则化则倾向于让神经元最后使用它们最重要输入数据的稀疏子集，可看做特征选择</strong>，它的实际操作是对每个w都像目标函数增加一个λ*|w|，这样的话，你可以知道求导的时候，附加项的导数就与w的符号有关，如果w为正，最优化更新后的w变小（相比与没有添加L1正则项时），如果为负则更新后的w变大，即尽可能使权重值为0。在w为0时，我们把取符号的sgn(w）看作是0，即sgn(0)=0,sgn(w&gt;0)=1,sgn(w&lt;0)=-1。</p>
<p>一般来说，实践更倾向于使用L2正则化，除非我们需要特征选择。</p>
<h3 id="随机失活"><a href="#随机失活" class="headerlink" title="随机失活"></a>随机失活</h3><p>  目前我们经常看到随机失活(dropout)的字眼，<strong>其与L1，L2正则化，以及最大范式约束的方法互为补充</strong>，实际操作过程中，随机失活即是让神经元以超参数p为概率被设置为0或者被激活,<strong>p一般设置为0.5</strong>，这样我们可以看做对完整的神经网络抽样出一些子集，每次基于输入数据只更新子网络的参数。</p>
<p><img src="\img\dropout.jpg" alt="dropout"></p>
<p>  但实际上我们更倾向于使用Inverted dropout，这是因为如果我们在训练网络时使用前向随机失活，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_step</span><span class="params">(X)</span>:</span></div><div class="line">  <span class="comment"># 3层neural network的前向传播</span></div><div class="line">  H1 = np.maximum(<span class="number">0</span>, np.dot(W1, X) + b1)</div><div class="line">  U1 = np.random.rand(*H1.shape) &lt; p <span class="comment"># 第一个随机失活遮罩</span></div><div class="line">  H1 *= U1 <span class="comment"># drop!</span></div><div class="line">  H2 = np.maximum(<span class="number">0</span>, np.dot(W2, H1) + b2)</div><div class="line">  U2 = np.random.rand(*H2.shape) &lt; p <span class="comment"># 第二个随机失活遮罩</span></div><div class="line">  H2 *= U2 <span class="comment"># drop!</span></div><div class="line">  out = np.dot(W3, H2) + b3</div></pre></td></tr></table></figure>
<p>  上面这段代码中有p的概率，神经元会被激活，而又1-p的概率神经元会被设置为0，然后流向下一层，那么我们可以知道在随机失活进行后，输出为px，而在我们的测试过程中并不存在随机失活层，所以神经元对输入都是可见的，那么为了保持同样的预期输出，我们必须在测试时把输出结果乘以p,来缩放激活函数输出结果，以防止测试输出数值范围大于训练输出，如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(X)</span>:</span></div><div class="line">  <span class="comment"># 前向传播时模型集成</span></div><div class="line">  H1 = np.maximum(<span class="number">0</span>, np.dot(W1, X) + b1) * p <span class="comment"># 注意：激活数据要乘以p</span></div><div class="line">  H2 = np.maximum(<span class="number">0</span>, np.dot(W2, H1) + b2) * p <span class="comment"># 注意：激活数据要乘以p</span></div><div class="line">  out = np.dot(W3, H2) + b3</div></pre></td></tr></table></figure>
<p>  这样的话测试时要多乘一次p显得非常麻烦，为了让我们的测试效率更高，各种深度学习框架中实践的其实是inverted dropout,有翻译为<strong>反向随机失活</strong>，个人觉得这个翻译不太好，<strong>其实它就是在训练阶段对激活函数输出值进行放大，即是放大1/p倍，而测试阶段则保持不变。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_step</span><span class="params">(X)</span>:</span></div><div class="line">  <span class="comment"># 3层neural network的前向传播</span></div><div class="line">  H1 = np.maximum(<span class="number">0</span>, np.dot(W1, X) + b1)</div><div class="line">  U1 = (np.random.rand(*H1.shape) &lt; p) / p <span class="comment"># 第一个随机失活遮罩. 注意/p!</span></div><div class="line">  H1 *= U1 <span class="comment"># drop!</span></div><div class="line">  H2 = np.maximum(<span class="number">0</span>, np.dot(W2, H1) + b2)</div><div class="line">  U2 = (np.random.rand(*H2.shape) &lt; p) / p <span class="comment"># 第二个随机失活遮罩. 注意/p!</span></div><div class="line">  H2 *= U2 <span class="comment"># drop!</span></div><div class="line">  out = np.dot(W3, H2) + b3</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(X)</span>:</span></div><div class="line">  <span class="comment"># 前向传播时模型集成</span></div><div class="line">  H1 = np.maximum(<span class="number">0</span>, np.dot(W1, X) + b1) <span class="comment"># 不用数值范围调整了</span></div><div class="line">  H2 = np.maximum(<span class="number">0</span>, np.dot(W2, H1) + b2)</div><div class="line">  out = np.dot(W3, H2) + b3</div></pre></td></tr></table></figure>
<h2 id="损失函数的选择"><a href="#损失函数的选择" class="headerlink" title="损失函数的选择"></a>损失函数的选择</h2><p>  我们知道在<strong>分类问题中</strong>两个最常见的分类器对应的损失计算：</p>
<p>  SVM-&gt;折页损失/平方折页损失（下图没列出）</p>
<p>  Softmax-&gt;交叉熵损失</p>
<p><img src="\img\loss.jpg" alt="loss"></p>
<p>  如果我们面对的不是一个一般的分类问题，怎么办呢？上面的几种损失公式都只正确作用在每个样本只有一个正确的标签yi的假设成立的情况之下。但是你可以看到，在hexo博客中的一篇文章是可以打几个标签的，亦或者是新浪微博上的一张图片，比如你的女神正在日本旅游，发了一张在清水寺前不知道谁给它拍了一张照，可以打上美女，日本旅游，快乐等等几个标签。我们可以采取下面的一种损失评分策略：</p>
<p><img src="\img\loss2.png" alt="loss2"></p>
<p>其中yij的值为1或者-1，它表示第i个样本是否被贴上第j个标签，如果是就是1，如果不是就是-1，这样的话，可以发现，当一个正样本的得分小于+1，或者一个负样本得分大于-1的时候，算法就会累计损失值。</p>
<p>  再比如回归问题，比如你要预测北京的空气质量pm2.5的值，一般我们考虑计算预测值和真实值之间的损失，再用L2或者L1范式度量差异。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  从上一篇博文，我们知道，神经网络其实就是一个一系列线性映射和非线性激活函数交织起来的评分函数，我们在输入层输入我们的数据，经过隐层的一系列点积和激活函数计算在输出层得到一个类型评分，然而要比较好地训练一个神经网络，我们需要更多的考虑，比如数据预处理，我们还需要考虑权重的初始值以及如何选择激活函数。&lt;/p&gt;
&lt;h2 id=&quot;数据预处理&quot;&gt;&lt;a href=&quot;#数据预处理&quot; class=&quot;headerlink&quot; title=&quot;数据预处理&quot;&gt;&lt;/a&gt;数据预处理&lt;/h2&gt;&lt;p&gt;  我们通常会对&lt;strong&gt;训练集&lt;/strong&gt;数据进行预处理，当然这可能有很多种形式，比如我们如果要去除一些噪声可能要进行数据清洗，这一部分这里先不介绍了，我们这里主要介绍归一化，归一化可以有利于避免模型训练时出现数值问题，还有利于网络快速收敛，更具体的优点你可以查看&lt;a href=&quot;http://nnetinfo.com/nninfo/showText.jsp?id=37&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;  归一化（Normalization）即把数据的所有维度都归一化，使其数值范围都近似相等，这个种预处理操作只在确信不同输入特征有不同的输入范围时才有意义，对于图像处理中，像素的范围都是0-255，所以这样做对于图片数据意义不大，但是数据如果是表示一个人，（体重（kg），身高（m），年龄）,这样的数据显然60Kg的体重和1.7m的身高不太对等，这会产生一些数值问题，我们有必要进行归一化。这里有两种方式进行&lt;strong&gt;归一化&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;先假设数据矩阵M，尺寸是N*D,N为样本数目，D是数据维度&lt;/p&gt;
&lt;p&gt;第一种：对数据先做零中心化(zero-centered)，如果用numpy表示：M-=np.mean(X,axis=0)，然后我们对每个维度都除以它的标准差就可以了，M/=np.std(X,axis=0)。&lt;/p&gt;
&lt;p&gt;第二种：对每个维度归一化使得每个维度的最大和最小值是1和-1。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Notes of CS231n:Neural network 1</title>
    <link href="http://yoursite.com/2018/02/28/Notes-of-Deep-Learning-Neural-network-1/"/>
    <id>http://yoursite.com/2018/02/28/Notes-of-Deep-Learning-Neural-network-1/</id>
    <published>2018-02-28T07:17:09.000Z</published>
    <updated>2018-03-12T08:37:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="人工神经元"><a href="#人工神经元" class="headerlink" title="人工神经元"></a>人工神经元</h2><p>  其实神经元这个翻译有点唬人，有些学者也不喜欢借用某些生物词语来蹭热度，他们直接就把所谓的人工神经元称之为单元（unit），结合人工神经网络来看的话，你可以很容易的推测出，它是由这个所谓的人工神经元组成的。在一个人工神经网络中，神经元间会有一种单向的影响，因为人工神经网络可以看做是一张有向无环图。下图是一个常见的粗糙模型：</p>
<div align="center"><br><br><img width="600px" src="\img\QQ图片20180214181505.png"><br><br><img src="\img\QQ图片20180214180333.jpg"><br><br></div>

<p>从这张图中你可以看到，一个人工神经元有几个主要的部分，如果你把它看做是有向无环图里的一个节点，那么你可以观察到它的每一个入度，分别对应一个不同的输入和一个自身权重的乘积（w和x都是向量或者矩阵，这里准确来说应该是<strong>点积</strong>），所有入度的点积的累加加上节点对应的偏差值（偏置）(Σwixi+b）代入所入节点的激活函数，图中就是f，对应为f(Σwixi+b),然后这个输出结果（<strong>激活率</strong>）顺着节点的出度流入下一层网络中的神经元。</p>
<p>  现在你大概知道什么是所谓的人工神经元，如果硬要跟生物神经元扯上一毛钱关系的话，你学过高中生物，大概会知道突触，树突，突触小泡之类的，你也许能把这个和两个神经细胞里通过突触来传递兴奋的机制联系起来…然后对别人吹嘘一波，但是我是做不到的，可能是我不怎么了解生物吧。 </p>
<a id="more"></a>
<h2 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h2><p>  认识了人工神经元之后，我们就知道了这里面有一个叫做<strong>激活函数（activation function）</strong>的重要概念，激活函数的选择对最终训练出来的模型影响是很大的，如果你以前看过一些公众号中推送的文章，可能会经常看到Sigmoid和Tanh这样的字眼，这是都是激活函数的名称，但是你不要看着这些名字这么奇怪就觉得这个函数会不会很复杂啊，其实稍微用点脑子思考一下就知道激活函数不能是多么复杂的函数，因为我们最后需要通过反向传播这样的算法去计算梯度，从而进行参数调优，如果这个激活函数是非常复杂的，这个梯度就不太好算了，激活函数通常都是非线性函数，目的是为了模型有更强的表达能力，详情可以<a href="https://www.zhihu.com/question/22334626" target="_blank" rel="external">参考这里</a>，排名前几的答案基本上把这个问题讲清楚了。这里我记录3个激活函数：</p>
<h3 id="S型函数"><a href="#S型函数" class="headerlink" title="S型函数"></a>S型函数</h3><p>  S型函数就是Sigmoid，如果在你学高等数学或者微积分的时候，肯定是接触过这个函数的，这个函数由于它在平面直角坐标系上的曲线而得名。即：</p>
<blockquote>
<p>σ（x）=1/(1+e^(-x))</p>
</blockquote>
<p><img src="\img\QQ图片20180214194819.png" alt="QQ图片20180214194819"></p>
<h3 id="Tanh函数"><a href="#Tanh函数" class="headerlink" title="Tanh函数"></a>Tanh函数</h3><p>  Tanh函数是有S型函数转化过来的零中心函数，Tanh比S型函数更受欢迎，但是他们存在着饱和问题，即在接近极值的区间，梯度几乎为0，训练模型的时候使用反向传播算法，一个接近0的梯度反向传播下去，小数相乘会以指数形式收缩到0。</p>
<blockquote>
<p>tanh=2σ(2x)-1=2/(1+e^(-2x))-1</p>
</blockquote>
<p><img src="\img\QQ图片20180214195043.png" alt="QQ图片20180214195043"></p>
<h3 id="ReLU函数"><a href="#ReLU函数" class="headerlink" title="ReLU函数"></a>ReLU函数</h3><p>目前最流行的激活函数,非常简单粗暴有效,名字的由来是Rectified Linear Unit-&gt;ReLU</p>
<blockquote>
<p>ReLu(x)=max(0,x)</p>
</blockquote>
<p><img src="\img\QQ图片20180214200631.png" alt="QQ图片20180214200631"></p>
<h2 id="神经网络结构"><a href="#神经网络结构" class="headerlink" title="神经网络结构"></a>神经网络结构</h2><p>我们通过一个普通的神经网络来展开对它的层结构认知，比如下面这个两层的网络：</p>
<p><img src="\img\NN.jpg" alt="NN"></p>
<p>  一般来说输入层是不算做层数的，所以说这个网络是2层，即一个隐层和输出层，当然有些网络有很多隐层，我们在这个图片上看到的是一个有向无环图，但是经过前面的理解，你知道实际上它是一个做矩阵点积的数学函数。</p>
<p>  在这个普通的网络中，它的层都是<strong>全连接层</strong>，全连接层中的神经元与其前后两层的神经元是完全成对连接的，但是在同一个全连接层内的神经元之间没有连接。</p>
<p>  在神经网络中，输出层是没有激活函数的，因为它用来完成分类的打分。有时候我们要表示一个神经网络的尺寸，比如上面那个神经网络是怎么样的尺寸呢，它有着4（隐层）+2（输出层）=6个神经元，因为是全连接的，它有着3*4+4*2=20个权重，以及4+2=6个偏置，权重和偏置都是可学习的，那么我们训练这个神经网络的时候需要学习这个26个参数，以最优化算法求得他们的最优值。这样看起来似乎比较清晰了，但是一般的卷积神经网络有着10-20层，1亿个可学习参数，要求这个1一个参数的最优值可不是一个简单的工程，这也是为什么大部分做深度学习的同学都处在调参的路上的原因了。</p>
<p>  是不是层数越多的神经网络越好呢?视情况而定，一般的神经网络就是3层网络，再增加层数很难增强它的表达力度，而卷积神经网络则不同，因为要提取层次化特征，所以深度就是一个很重要的问题，一般都是数十层之多，谈到这个问题，我们又有新的问题，如何设置神经网络的层数和尺寸。我们知道神经网络其实是一个函数，如果在有着相同激活函数的情况下，整个函数更为复杂，则函数的表达能力就能更强，但是也会引起<strong>过拟合</strong>等问题，<strong>过拟合</strong>是指网络对数据中的噪点拟合过甚，导致整个模型的泛化能力不强。</p>
<p>  即便大的网络会有过拟合问题，我们还是会使用更大一点的网络作为模型，因为防止过拟合还有其他的方法，比如<strong>L2正则化或者dropout</strong>，特别是正则化。因此我们没有必要去牺牲整个网络模型的表达能力去换去泛化能力。另外小网络的极小值很容易收敛到，但是这些极值的损失值一般都很高，不利于我们构建一个优秀的模型，而大的网络极小值更多，虽然更不容易收敛，但是我们可以有更多的选择，从而得到一个更好的模型。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;人工神经元&quot;&gt;&lt;a href=&quot;#人工神经元&quot; class=&quot;headerlink&quot; title=&quot;人工神经元&quot;&gt;&lt;/a&gt;人工神经元&lt;/h2&gt;&lt;p&gt;  其实神经元这个翻译有点唬人，有些学者也不喜欢借用某些生物词语来蹭热度，他们直接就把所谓的人工神经元称之为单元（unit），结合人工神经网络来看的话，你可以很容易的推测出，它是由这个所谓的人工神经元组成的。在一个人工神经网络中，神经元间会有一种单向的影响，因为人工神经网络可以看做是一张有向无环图。下图是一个常见的粗糙模型：&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;img width=&quot;600px&quot; src=&quot;\img\QQ图片20180214181505.png&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;\img\QQ图片20180214180333.jpg&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;/div&gt;

&lt;p&gt;从这张图中你可以看到，一个人工神经元有几个主要的部分，如果你把它看做是有向无环图里的一个节点，那么你可以观察到它的每一个入度，分别对应一个不同的输入和一个自身权重的乘积（w和x都是向量或者矩阵，这里准确来说应该是&lt;strong&gt;点积&lt;/strong&gt;），所有入度的点积的累加加上节点对应的偏差值（偏置）(Σwixi+b）代入所入节点的激活函数，图中就是f，对应为f(Σwixi+b),然后这个输出结果（&lt;strong&gt;激活率&lt;/strong&gt;）顺着节点的出度流入下一层网络中的神经元。&lt;/p&gt;
&lt;p&gt;  现在你大概知道什么是所谓的人工神经元，如果硬要跟生物神经元扯上一毛钱关系的话，你学过高中生物，大概会知道突触，树突，突触小泡之类的，你也许能把这个和两个神经细胞里通过突触来传递兴奋的机制联系起来…然后对别人吹嘘一波，但是我是做不到的，可能是我不怎么了解生物吧。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Junit(4):Mock</title>
    <link href="http://yoursite.com/2018/02/01/Junit-4-Mock/"/>
    <id>http://yoursite.com/2018/02/01/Junit-4-Mock/</id>
    <published>2018-02-01T08:29:46.000Z</published>
    <updated>2018-02-01T15:39:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>  就像上篇文章所说，我们还可以用mock方式模拟一个没有完成的模块，从而完成测试，事实上如果测试的业务比较繁琐，比如涉及到输入啥的，我们也可以mock一个假的输入对象，mock object是在极限编程里提出的，而今天它已经广泛用于软件测试领域。</p>
<p>  就如mock这个单词的词义一样，mock object即是一个模制的对象，但这个对象的行为是人为故意给定的，不包含实际的业务。这样说可能非常抽象，如果让我们考虑用<strong>Scala</strong>写一个在商店里用pos机刷卡的例子,比如我们刷卡并且输入密码后会构造出这样的一个CreditCard对象：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">CreditCard</span>(<span class="params">val cardId:<span class="type">String</span>,val password:<span class="type">String</span></span>)</span></div></pre></td></tr></table></figure>
<p> 而我们的Pos机要负责转账处理：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pos</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">transfer</span></span>(amount:<span class="type">Double</span>,creditCard: <span class="type">CreditCard</span>, creditCard2: <span class="type">CreditCard</span>, accountManager: <span class="type">AccountManager</span>): <span class="type">Unit</span> = &#123;</div><div class="line">    <span class="keyword">val</span> account1: <span class="type">Account</span> = accountManager.findAccount(creditCard.cardId, creditCard.password);</div><div class="line">    <span class="keyword">val</span> account2: <span class="type">Account</span> = accountManager.findAccount(creditCard2.cardId, creditCard2.password);</div><div class="line">    accountManager.saveAccount(account1.copy(account1.balance - amount,account1.creditCard))</div><div class="line">    accountManager.saveAccount(account2 copy(account2.balance + amount, account2.creditCard))</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>，但是问题是此时我们根本没有构造号银行卡账户数据库，甚至我们连dao对象都只是一个接口，那么为了测试Pos代码逻辑能不能正确执行我们该怎么办呢？</p>
<a id="more"></a>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">AccountManager</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">saveAccount</span></span>(account: <span class="type">Account</span>)</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">findAccount</span></span>(cardId: <span class="type">String</span>, password: <span class="type">String</span>): <span class="type">Account</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>答案是我么可以建立一个mock object，这不仅可以很容易的测试Pos的代码逻辑，而且节省了很大的开销，设想一下，如果真正的去测试，我们不仅要确定整个容器环境无误，还要不断地去访问数据库，这肯定是不可以忍受的。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MockAccountManager</span>(<span class="params"></span>) <span class="keyword">extends</span> <span class="title">AccountManager</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> accounMap = <span class="type">Map</span> (</div><div class="line">      (<span class="string">"1001"</span>, <span class="type">Account</span>(<span class="number">1000</span>, <span class="type">CreditCard</span>(<span class="string">"1001"</span>, <span class="string">"123"</span>)))</div><div class="line">      , (<span class="string">"1002"</span>, <span class="type">Account</span>(<span class="number">1000</span>, <span class="type">CreditCard</span>(<span class="string">"1002"</span>, <span class="string">"123"</span>)))</div><div class="line">      )</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">findAccount</span></span>(cardId: <span class="type">String</span>, password: <span class="type">String</span>): <span class="type">Account</span> = &#123;</div><div class="line">      <span class="keyword">val</span> x=accounMap(cardId)</div><div class="line">      x <span class="keyword">match</span> &#123;</div><div class="line">        <span class="keyword">case</span> <span class="type">Account</span>(_,password)=&gt;x</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">saveAccount</span></span>(account: <span class="type">Account</span>): <span class="type">Unit</span> = &#123;</div><div class="line">      accounMap = accounMap ++ <span class="type">Map</span> (</div><div class="line">        (account.creditCard.cardId, account)</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样我们就可以利用这个，简单的mock object去测试我们的Pos逻辑了：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">testTransfer</span></span>(): <span class="type">Unit</span> = &#123;</div><div class="line">  <span class="keyword">val</span> pos = <span class="keyword">new</span> <span class="type">Pos</span>();</div><div class="line">  <span class="keyword">val</span> card = <span class="keyword">new</span> <span class="type">CreditCard</span>(<span class="string">"1001"</span>, <span class="string">"123"</span>)</div><div class="line">  <span class="keyword">val</span> card2 = <span class="keyword">new</span> <span class="type">CreditCard</span>(<span class="string">"1002"</span>, <span class="string">"123"</span>)</div><div class="line">  <span class="keyword">val</span> acm = <span class="keyword">new</span> <span class="type">MockAccountManager</span>()</div><div class="line">  pos.transfer(<span class="number">100.2</span>, card, card2, acm)</div><div class="line">  assertEquals(acm.findAccount(card2.cardId, card2.password).balance,<span class="number">1100.2</span>d,<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  我在这里手动写了一个mock object仅仅是为了演示一下大概的思想，实际上我们不需要手动写mock object，有大量的框架帮助我们完成这一点，比如在jvm平台上就有Jmock，EasyMock,Mockito等等，它们借助jvm的反射机制，以代理模式动态的生成了一个新的对象，我们可以给定这个对象特定方法的特定输入输出，十分方便，比如对于猜数字游戏：</p>
<p>随机给定一个4位数字，且每一位的数字都不重复，然后玩家在不知道这个数字的情况下输入一个4位数字每一位都不重复，如果位置相同且数字也相同就得到一个A，如果数字存在但是位置不同就得到B。</p>
<p>如：</p>
<p>给定1234,玩家猜测为1256，则结果为2A0B</p>
<p>给定1234，玩家猜测为3412，则结果为0A4B</p>
<p>如果玩家在6次之内得到了4A0B结果，就输出玩家胜利。</p>
<p>这样的话，我们可以来写一个简单的程序：</p>
<p>首先我们需要输入和输出,以下两个类用来读取数字和输出一个字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//输入</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberReader</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        String inputNumber = scanner.next();</div><div class="line">        <span class="keyword">if</span> (StringUtils.isNumeric(inputNumber) &amp;&amp; inputNumber.length() == <span class="number">4</span>) &#123;</div><div class="line">            <span class="keyword">return</span> inputNumber;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Invalid Input"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//输出</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Printer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String message)</span> </span>&#123;</div><div class="line">        System.out.println(message);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们需要一个随机数字生成器,它可以随机生成一个4位不同数字组成的字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberGenerator</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generate</span><span class="params">()</span> </span>&#123;</div><div class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>);</div><div class="line">        Collections.shuffle(list);</div><div class="line">        <span class="keyword">return</span> String.join(<span class="string">""</span>, list.subList(<span class="number">0</span>, <span class="number">4</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们需要一种数字类,它有一个比较方法，输出xAxB这样的表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Number</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMBER_LENGTH = <span class="number">4</span>;</div><div class="line">    <span class="keyword">private</span> String value;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Number</span><span class="params">(String value)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">compare</span><span class="params">(String stringToCompare)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUMBER_LENGTH; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (value.charAt(i) == stringToCompare.charAt(i)) &#123;</div><div class="line">                a++;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value.contains(stringToCompare.substring(i, i + <span class="number">1</span>))) &#123;</div><div class="line">                b++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> a + <span class="string">"A"</span> + b + <span class="string">"B"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后我们把上面的组件组成一个游戏：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Game</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String WIN_CODE = <span class="string">"4A0B"</span>;</div><div class="line">    <span class="keyword">private</span> Printer printer;</div><div class="line">    <span class="keyword">private</span> Number generatedNumber;</div><div class="line">    <span class="keyword">private</span> NumberReader reader;</div><div class="line"></div><div class="line">    <span class="comment">//我们有6次机会</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> remainingGuessCount = <span class="number">6</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Game</span><span class="params">(NumberGenerator numberGenerator, Printer printer, NumberReader reader)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.printer = printer;</div><div class="line">        <span class="keyword">this</span>.reader = reader;</div><div class="line">        <span class="keyword">this</span>.generatedNumber = <span class="keyword">new</span> Number(numberGenerator.generate());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">        printer.print(<span class="string">"please input a 4 digit number:"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (remainingGuessCount &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">              <span class="comment">//比较数字输入和生成的随机数</span></div><div class="line">                String result = generatedNumber.compare(reader.read());</div><div class="line">                <span class="keyword">if</span> (WIN_CODE.equals(result)) &#123;</div><div class="line">                    printer.print(<span class="string">"you win"</span>);</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                printer.print(result);</div><div class="line">                <span class="keyword">this</span>.remainingGuessCount--;<span class="comment">//机会使用了一次，所以减少</span></div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                printer.print(e.getMessage());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        printer.print(<span class="string">"Game Over"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们有一个简单的游戏了，如果玩家6次内猜对了4A0B，那么就输出you win,否则输出Game Over。现在我们要对这个游戏进行测试，但是我们可能会遇到以下的问题：</p>
<p>1.我们需要自动测试，而不是每次都手动输入</p>
<p>这是一个问题，我们的输入类NumberReader，调用的是系统的System.in但是我们却要求自动化测试，而不是每次手动输入，既然如此，我们就需要一种mock object，以代理的手段自动返回我们想输入的数字，我们可以自己手写字段反射，覆盖掉输入流，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberReaderTest</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> NumberReader reader = <span class="keyword">new</span> NumberReader();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setInputStream</span><span class="params">(String input)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</div><div class="line">        Field scannerField = reader.getClass().getDeclaredField(<span class="string">"scanner"</span>);</div><div class="line">        scannerField.setAccessible(<span class="keyword">true</span>);</div><div class="line">        Scanner scannerWithMockedStream = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> ByteArrayInputStream(input.getBytes()));</div><div class="line">        scannerField.set(reader, scannerWithMockedStream);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldReadNumber</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        setInputStream(<span class="string">"1234"</span>);</div><div class="line">        assertEquals(<span class="string">"1234"</span>, reader.read());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span>(expected = Exception.class)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldThrowExceptionForNonNumberInput</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        setInputStream(<span class="string">"123d"</span>);</div><div class="line">        reader.read();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>手写是一种手段，我们可以理解框架大概是怎么做到的，当然其实可以用代理来做，现实情况中我们能够使用mock框架，这里我用的是<a href="https://github.com/mockito/mockito" target="_blank" rel="external">mockito</a>,当然你也可以用其他的框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.junit.Before;</div><div class="line"><span class="keyword">import</span> org.junit.Test;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.Mockito.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameTest</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> NumberGenerator numberGenerator;</div><div class="line">    <span class="keyword">private</span> NumberReader numberReader;</div><div class="line">    <span class="keyword">private</span> Printer printer;</div><div class="line">    <span class="keyword">private</span> Game game;</div><div class="line"></div><div class="line">    <span class="meta">@Before</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="comment">//我们以mock方式生成了:</span></div><div class="line">        numberGenerator = mock(NumberGenerator.class);</div><div class="line">        numberReader = mock(NumberReader.class);</div><div class="line">        printer = mock(Printer.class);</div><div class="line">      <span class="comment">//我们给定generate的返回值必须是4879，因为随机生成一个数字可就不好写expected值了</span></div><div class="line">        when(numberGenerator.generate()).thenReturn(<span class="string">"4879"</span>);</div><div class="line">        game = <span class="keyword">new</span> Game(numberGenerator, printer, numberReader);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们可以写一些简单测试，来体验一下mock的作用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldPrintYouWin</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    when(numberReader.read()).thenReturn(<span class="string">"4879"</span>);</div><div class="line">    game.start();</div><div class="line">  <span class="comment">//使用verify可以在白盒情况下审视代码逻辑是不是正常运转</span></div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"please input a 4 digit number:"</span>);</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"you win"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldPrintYouWinAfterFifthAttempts</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  <span class="comment">//mockito支持我们每次返回不同的值</span></div><div class="line">    when(numberReader.read()).thenReturn(<span class="string">"7849"</span>,<span class="string">"7849"</span>,<span class="string">"7849"</span>,<span class="string">"7849"</span>,<span class="string">"7849"</span>,<span class="string">"4879"</span>);</div><div class="line">    game.start();</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"please input a 4 digit number:"</span>);</div><div class="line">    verify(printer, times(<span class="number">5</span>)).print(<span class="string">"2A2B"</span>);</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"you win"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldPrintYouWinAfterSecondAttempts</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    when(numberReader.read()).thenReturn(<span class="string">"7849"</span>,<span class="string">"4879"</span>);</div><div class="line">    game.start();</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"please input a 4 digit number:"</span>);</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"2A2B"</span>);</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"you win"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldPrintGameOver</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    when(numberReader.read()).thenReturn(<span class="string">"7849"</span>);</div><div class="line">    game.start();</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"please input a 4 digit number:"</span>);</div><div class="line">    verify(printer, times(<span class="number">6</span>)).print(<span class="string">"2A2B"</span>);</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"Game Over"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldRunNormallyAfterThrowsException</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  <span class="comment">//我们还可以设定抛出异常</span></div><div class="line">    when(numberReader.read()).thenThrow(<span class="keyword">new</span> IOException(<span class="string">"IO Exception Test"</span>))</div><div class="line">            .thenReturn(<span class="string">"7849"</span>,<span class="string">"7849"</span>,<span class="string">"7849"</span>,<span class="string">"7849"</span>,<span class="string">"7849"</span>,<span class="string">"4879"</span>);</div><div class="line">    game.start();</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"please input a 4 digit number:"</span>);</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"IO Exception Test"</span>);</div><div class="line">    verify(printer, times(<span class="number">5</span>)).print(<span class="string">"2A2B"</span>);</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"you win"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然上面这些简单的mock，我们也可以手动给它以代理方式写出来，有利于我们理解mockito这类框架的实际工作方式，感兴趣的朋友可以写写看，我这里就不写了~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  就像上篇文章所说，我们还可以用mock方式模拟一个没有完成的模块，从而完成测试，事实上如果测试的业务比较繁琐，比如涉及到输入啥的，我们也可以mock一个假的输入对象，mock object是在极限编程里提出的，而今天它已经广泛用于软件测试领域。&lt;/p&gt;
&lt;p&gt;  就如mock这个单词的词义一样，mock object即是一个模制的对象，但这个对象的行为是人为故意给定的，不包含实际的业务。这样说可能非常抽象，如果让我们考虑用&lt;strong&gt;Scala&lt;/strong&gt;写一个在商店里用pos机刷卡的例子,比如我们刷卡并且输入密码后会构造出这样的一个CreditCard对象：&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CreditCard&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;val cardId:&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;,val password:&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; 而我们的Pos机要负责转账处理：&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Pos&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;transfer&lt;/span&gt;&lt;/span&gt;(amount:&lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;,creditCard: &lt;span class=&quot;type&quot;&gt;CreditCard&lt;/span&gt;, creditCard2: &lt;span class=&quot;type&quot;&gt;CreditCard&lt;/span&gt;, accountManager: &lt;span class=&quot;type&quot;&gt;AccountManager&lt;/span&gt;): &lt;span class=&quot;type&quot;&gt;Unit&lt;/span&gt; = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; account1: &lt;span class=&quot;type&quot;&gt;Account&lt;/span&gt; = accountManager.findAccount(creditCard.cardId, creditCard.password);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; account2: &lt;span class=&quot;type&quot;&gt;Account&lt;/span&gt; = accountManager.findAccount(creditCard2.cardId, creditCard2.password);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    accountManager.saveAccount(account1.copy(account1.balance - amount,account1.creditCard))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    accountManager.saveAccount(account2 copy(account2.balance + amount, account2.creditCard))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;，但是问题是此时我们根本没有构造号银行卡账户数据库，甚至我们连dao对象都只是一个接口，那么为了测试Pos代码逻辑能不能正确执行我们该怎么办呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="软件测试" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
      <category term="TDD" scheme="http://yoursite.com/tags/TDD/"/>
    
      <category term="Junit" scheme="http://yoursite.com/tags/Junit/"/>
    
  </entry>
  
  <entry>
    <title>Junit(3):桩测试</title>
    <link href="http://yoursite.com/2018/01/29/Junit-3-Build-a-stub/"/>
    <id>http://yoursite.com/2018/01/29/Junit-3-Build-a-stub/</id>
    <published>2018-01-29T14:45:51.000Z</published>
    <updated>2018-01-30T15:40:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>  如果我们只是单纯测试一个类里的公共方法，那么使用简单的断言，就能满足我们的需求，可是我们的<strong>测试很多时候要依赖其他的类，或者说环境</strong>，比如你测试的方法可能要访问一些服务器获取资源，或者访问数据库获取数据，此时我们必须需要一个真实的环境么？实际上很多情况下，你根本拿不到真实的环境，比如你测试的是一个还没有完成的服务模块。既然有这种需求，我们就得想办法在开发环境中模拟一个模块来测试，这有两种策略，一种就是stub，还一种就是mock，<strong>这两种方法都是为了代替依赖部分，不同的是mock是构建一个假的对象，而stub是真实地简单实现一个对象</strong>，这一节我先讲这个stub，我们将以stub的方式，模拟一个对一个服务器发送http请求测试。</p>
<a id="more"></a>
<p>  stub是一段代码，常在运行期间代替真实的代码，它的目的在于模拟一个简单的行为，因为真实的代码可能过于复杂，或者根本不可得，使用stub技术就可以允许独立的测试真实代码中的一部分行为，<strong>其实你可以把stub代码理解为是对真实代码一部分行为的简单实现</strong>。</p>
<p>  有时候stub代码很难写，因为他可能要再现真实代码的复杂逻辑，你知道有的系统中即使是以小块功能逻辑也是非常复杂的，所以一般情况下stub只适合代码中的粗粒度部分的测试，以stub代码来代替成熟的外部系统，比如服务器的连接或者数据库。</p>
<p>比如我们要测试下面这个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> xin.saul;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.InputStream;</div><div class="line"><span class="keyword">import</span> java.net.HttpURLConnection;</div><div class="line"><span class="keyword">import</span> java.net.URL;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClient</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">(URL url)</span> </span>&#123;</div><div class="line">        StringBuffer content = <span class="keyword">new</span> StringBuffer();</div><div class="line">        HttpURLConnection connection = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            InputStream stream = url.openStream();</div><div class="line">            <span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2049</span>];</div><div class="line">            <span class="keyword">int</span> len;</div><div class="line">            <span class="keyword">while</span> ((len = stream.read(bs)) != -<span class="number">1</span>) &#123;</div><div class="line">                content.append(<span class="keyword">new</span> String(bs, <span class="number">0</span>, len));</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> content.toString();</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假如这个Myclient就是我们所构造应用的客户端，它可以通过url获取一个web资源，我们应该如何去测试它呢？这里会出现几种情况，一种就是我们的服务器已经构建完毕了，那么我们可以直接去测试它，但是很多时候我们的客户端开发完成后，我们的服务器并没有开发完成，那么我们测试前必须去先架构一个apache或者tomcat服务器么？答案肯定是否定的，apache和tomcat启动速度并不是很快，我们有一些代替方案，比如我们以Jetty来写一段stub代码，以模拟我们的客户端和服务器交互过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> xin.saul;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.eclipse.jetty.server.Handler;</div><div class="line"><span class="keyword">import</span> org.eclipse.jetty.server.Request;</div><div class="line"><span class="keyword">import</span> org.eclipse.jetty.server.Server;</div><div class="line"><span class="keyword">import</span> org.junit.Assert;</div><div class="line"><span class="keyword">import</span> org.junit.BeforeClass;</div><div class="line"><span class="keyword">import</span> org.junit.Test;</div><div class="line"></div><div class="line"><span class="keyword">import</span> javax.servlet.ServletException;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.PrintWriter;</div><div class="line"><span class="keyword">import</span> java.net.MalformedURLException;</div><div class="line"><span class="keyword">import</span> java.net.URL;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientTest</span></span>&#123;</div><div class="line">    <span class="meta">@BeforeClass</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initClass</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Server server = <span class="keyword">new</span> Server(<span class="number">8080</span>);</div><div class="line">        MyClientTest test = <span class="keyword">new</span> MyClientTest();</div><div class="line">        server.setHandler(test.new SayHelloHandler());</div><div class="line">        server.setStopAtShutdown(<span class="keyword">true</span>);</div><div class="line">        server.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClient</span><span class="params">()</span> <span class="keyword">throws</span> MalformedURLException </span>&#123;</div><div class="line">        MyClient client = <span class="keyword">new</span> MyClient();</div><div class="line">        String content = client.getContent(<span class="keyword">new</span> URL(<span class="string">"http://127.0.0.1:8080"</span>));</div><div class="line">        Assert.assertEquals(<span class="string">"Server response"</span>,content);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SayHelloHandler</span> <span class="keyword">implements</span> <span class="title">Handler</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</div><div class="line">            response.setContentType(<span class="string">"text/plain; charset=utf-8"</span>);</div><div class="line">            response.setStatus(HttpServletResponse.SC_OK);</div><div class="line">            PrintWriter writer = response.getWriter();</div><div class="line">            writer.append(<span class="string">"Server response"</span>);</div><div class="line">            writer.close();</div><div class="line">        &#125;</div><div class="line">      <span class="comment">//注：此处省略了其他的方法重新，直接是ide自动生成的重写，我本人并没有改动</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  可以看到stub代码其实就是很傻乎乎的直接实现一个小模块小功能，当然这里是基于servlet服务,这里我以嵌入式服务器jetty来实现了这段stub，原因是它启动的很快，代码很简单。这里提一点，<strong>我们知道对于单元测试来说每个测试的不相干性是必要的，你不能因为上一个测试的执行而改变了服务器某些状态，于是我们希望没执行一个新的测试都能够拥有一个干净的环境</strong>，这也是诸如@Before这样的注解会做的，但是在打桩测试中你会发现一个jetty嵌入式服务器的启动时间可能是0.5秒，如果你要执行很多个stub测试，那就很有意思了，我不觉得你想在按下测试按钮以后在屏幕前等待十几分钟甚至几十分钟，然后发现某个地方测试没通过，重构之后又等一遍，于是我们可以尝试使用@BeforeClass注解，它只会执行一次，当然<strong>你得保证我们的服务器执行的具体逻辑和测试的执行顺序无关，测试之间不会相互影响</strong>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  如果我们只是单纯测试一个类里的公共方法，那么使用简单的断言，就能满足我们的需求，可是我们的&lt;strong&gt;测试很多时候要依赖其他的类，或者说环境&lt;/strong&gt;，比如你测试的方法可能要访问一些服务器获取资源，或者访问数据库获取数据，此时我们必须需要一个真实的环境么？实际上很多情况下，你根本拿不到真实的环境，比如你测试的是一个还没有完成的服务模块。既然有这种需求，我们就得想办法在开发环境中模拟一个模块来测试，这有两种策略，一种就是stub，还一种就是mock，&lt;strong&gt;这两种方法都是为了代替依赖部分，不同的是mock是构建一个假的对象，而stub是真实地简单实现一个对象&lt;/strong&gt;，这一节我先讲这个stub，我们将以stub的方式，模拟一个对一个服务器发送http请求测试。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="软件测试" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
      <category term="TDD" scheme="http://yoursite.com/tags/TDD/"/>
    
      <category term="Junit" scheme="http://yoursite.com/tags/Junit/"/>
    
  </entry>
  
  <entry>
    <title>冯诺依曼：《数学家》（下）</title>
    <link href="http://yoursite.com/2017/12/20/Von-Neumann-The-Mathematician-part-2/"/>
    <id>http://yoursite.com/2017/12/20/Von-Neumann-The-Mathematician-part-2/</id>
    <published>2017-12-20T08:09:29.000Z</published>
    <updated>2017-12-20T13:20:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>本文作者是冯诺依曼，英文名为《The Mathematician》，该文章在1947年发表在《Works of the Mind》上，后来也记录在《von Neumann’s Collected Works》中，这篇文章是我听讲座时偶然得知的，于是看了一下后翻译了出来，才疏学浅，只源于爱好，如有不对多多包涵——2017.12.20</em>  </p>
<p>本文接<a href="http://saul.xin/2017/12/13/Von-Neumann-The-Mathematician-part-1/#more" target="_blank" rel="external">上一部分</a></p>
<a id="more"></a>
<p>  然而，我不想进一步讨论这个问题，我将转向一个完全清晰的案例，即“数学基础”的讨论。在19世纪末和20世纪初，抽象数学的一个新分支——<strong>康托尔</strong>的集合论陷入了困境，某些理论导致了矛盾的结果，虽然这些推论不是集合论的核心”有用“的部分，而且很容易被某些正式标准识别，不过这些都不足以去阐明为什么这些理论的意义要低于集合论的“成功”部分。除了事后洞察到这些理论导致了灾难，但这说不清是什么样的先验动机，以及这种情况下的一致性理论，会允许人们把这些理论与想保留他们的集合论的那部分中分离开来。一个由<strong>罗素和外尔</strong>主导，后由<strong>布劳威尔</strong>总结的详细研究表明，不仅仅是集合论，而是大多数现代数学理论都反感“普遍有效”和“存在”的概念。<strong>布劳威尔</strong>发展了一个没有这些不受欢迎的特点的，被称为“直觉主义”的数学系统，在这个系统中上文提到的集合论困境和矛盾不复存在。然而，现代数学的半壁江山，在其不容置疑的最重要的部分，尤其是在分析方面，也受到这此“净化”的影响：它们要么变得无效，要么在证明时伴随次要的考虑非常复杂。在后一个过程中，会使理论明显丧失有效的普遍性和证明的优雅。然而，<strong>布劳威尔和外尔</strong>依然认为有必要根据这些观点修改数学严谨的概念。</p>
<p>  很难估量这些事件的重要性。在20世纪20年代，两个对数学有着深刻认识的顶级数学家，他们都提出了构成确切证明的数学严谨是概念应该被改变。随后的事态发展同样值得注意。</p>
<p>  1.只有少部分数学家愿意在日常使用中接受这种新的，迫切被采用的标准。很多人承认<strong>外尔</strong>和<strong>布劳威尔</strong>的理论咋看是正确的，但是他们自己却继续违背，用旧的，容易的方式来配合自己的数学工作。也许他们自己也希望有人能够在某个时间找到一个答案去应答这些直觉的批评，从而在事后证明这些理论的正确性。</p>
<p>  2.<strong>希尔伯特</strong>提出了以下巧妙的观点来证明“古典”数学的正当性：即使在直觉系统中也可能给出古典数学如何运作的严谨描述，即人们可以描述古典系统是如何工作的，虽然他们不能证明这种运作。因此，也许可以直观地证明，古典过程永远不会导致矛盾（相互冲突）。很明显这样一个证明是很难，不过有某些迹象表明它们是如何尝试的。一旦该方案有效，它将提供一个古典数学以与其相反的直觉系统为基础的最好的理由！至少，在大多数数学家愿意接受的数学哲学体系中，这种解释是合法的。</p>
<p>  3.在经历了十年的不断的尝试后，<strong>哥德尔</strong>得到了最好的结果。该结果三言两语无法完全准确地表述，而且该说明过于技术性，以至于无法在此表述。然而，它的本质含义是：如果一个数学系统没有导致矛盾，那么这个事实就不能用该系统的程序来证明。（哥德尔不完备定理）哥德尔的证明满足了数学严谨性的最严格标准–直观标准。这个结论对<strong>希尔伯特</strong>的计划影响存在争议（理由之与这篇文章显得太过技术性，我们不在此展开讨论）。我的个人和大多数人认同的观点相同，哥德尔已经证明希尔伯特的计划已经破灭。</p>
<p>  4.古典数学证明的主要希望已经消失（希尔伯特，或者布劳威尔和外尔那种意义上的），虽然人民再也无法确定古典数学的可靠性，但大多数数学家还是决定使用该体系，毕竟，古典数学产出的结果即优雅又有用，且至少建立在一个健全的基础上，就好像电子客观存在那样可靠。因此一个人愿意接受科学，就可以接受经典数学体系。即便直觉体系的一些原始参与者，也转而开始接受这种观点。目前，关于“基础”的争论还没有结束，但是除开少数人，摒弃古典体系变得不太可能。</p>
<p>  我如此详细的讲述了关于这场论战的故事，因为我认为它是不要把数学的严谨性的不可变性看得太过理所当然的最好的警示。这件事发生在我们的有生之年，我知道这段时间中我对于绝对数学真理的认知的改变，让我频繁地丢脸，我也知道他们是怎么样连续地改变了三次。</p>
<p>  我希望以上三个例子充分的说明了我的论文观点的一半，即最卓越数学灵感来自于经验，第二点是很难相信世上存在一个绝对的，不变的数学严谨性概念，且它完全和人类经验没有联系。在这个问题上，我试着抱着及其庸俗的态度。在这方面，无论人们在哲学或认识论上有什么偏好，数学家们的主体的实际经验几乎不支持存在一个先验的数学严谨概念的假设。然而，我的论文还有第二部分，现在我将转到这一部分。</p>
<p>  任何数学家都难以相信数学是一种纯经验主义科学或所有的数学观点源自于经验主义科学。让我们思考一下这句话的第二部分。现代数学的各个重要组成部分其经验性来源往往是不可追溯的。即使可以追溯也要回溯到很久以前，这些观点明显从它斩断经验性源头以来已经经历了完全的蜕变.几何符号是为了国内的数学用途而发明的，不过可能有理由断言它有很强的经验性瓜葛。然而，现代，“抽象”几何越来越多地往弱经验关联方向上发展，拓扑学也与其一样。在所有的这些领域中，数学家对于成功的主观标准和他们努力的价值体现，都是非常独立，优雅且自由（几乎自由）的经验性联系（我在后面会详细的讲）。在集合论中这一点一直很明显。无限集的“幂”和“序”的概念可能是有限集的数值概念的推广，不过在无限集形式中（特别是“幂”）他们几乎和真实世界没有关系。要不是我想避免技术性讨论，我可以用几个集合论的例子来描述这一点，这些例子诸如选择公理问题，无穷幂的可比性，连续性问题，等等。这同样适用于实函数理论和实点集理论。用微分几何和群论分别给出了两个奇怪的例子：它们被认为是抽象的、不实用的学科，而且几乎总是在这种态度中培养出来的.前者下经历了十年，后者经历了一个世纪，它们才在物理学中变得非常有用。并且它们仍然主要以指示性的、抽象的、不实用的态度来进行。</p>
<p>  所有这些条件及其各种组合的例子可以被成倍增加。但是，我更倾向于转到上面提到的第一点：数学是一门经验性科学吗？或者，更清晰的说：数学实际上是以经验科学的方式实践的吗？或者，更宽泛的说：数学家同他们学科的最基本关系是什么？他的成功的标准是什么，可取吗？怎么样的影响和考虑控制并引导着他的工作？</p>
<p>​    让我们来看看，在哪些方面数学家的日常工作方式和自然科学家的方式不同。一方面，在它们之间存在着区别，另一方面，随着数学不断发展，从理论学科向经验学科，再从经验学科向描述性学科的转变，这种区显著增大。因此，让我们把数学和最接近于它的范畴——理论学科，作一下比较。接着我们选出所有理论学科中最接近于数学的那个学科（如果我无法控制数学家的狂妄，而且说道：因为它是所有学科中最理论科学中发达的，请你不要对于批评的太过严厉）。这个学科就是理论物理学，数学和理论物理实际上有很多共同点。正如我前面指出的，欧几里德几何系统是经典力学公理化表述的原型，类似还支配着唯象热力学以及麦克斯韦电动力学系统的某些阶段以及狭义相对论。而且，理论物理学的作派是不解释现象，只做分类和关联，这种作派已经被当今大多数物理学家接受。这就意味着这种理论的成功标准仅仅是：能不能用一种简洁优美的分类关联方案，在使方案看起来不复杂混淆的情况下，覆盖大多数现象，无论在方案被演进时是否覆盖了没有被考虑或甚至不知道的现象（后两种说法当然表现了一种理论的统一性和预测力）。如前所述，现在，这种标准，明显在很大程度上具有美学性质。正因为如此，它非常接近于数学的成功标准，正如你所看到的，这些标准几乎完全是符合美学的。因此，我们现在把数学与最接近它的经验科学——理论物理学，进行比较，正如我希望我所展示的那样，它与数学有许多共同之处。然而，实际方法程序（modus procedendi）上的差异依然巨大且根本。理论物理学的目标主要是由“外部”给出，在大多数情况服从实验物理学的需要。它们几乎总是源于解决困难的需要。预先和统一的成就通常在随后出现。我们可以做一个比喻，进步（预测和统一）在工作从诞生，但在此之前必须与一些预先存在的困难作斗争（通常是现有体系中存在的明显矛盾）。有一部分物理学家的工作是寻找预示着“突破”的可能性的障碍。就如我所说，这些障碍通常源自于实验，不过有时候他们是各种被接受的理论主体中一些部分的矛盾。例子有很多。</p>
<p>  <strong>迈克尔逊</strong>的实验引出了狭义相对论，某些电离势和某些光谱结构的困难导致量子力学即使第一种情况的典型；狭义相对论和牛顿引力理论导致广义相对论之间的冲突就是第二种更罕见的情况的典型。至少，理论物理学中的问题都是客观给出；而且，正如我前面所说，指导成功开发的标准，主要是美学，而且该问题的一部分，即我上面提到的开创性的“突破”，是有力的客观事实。因此，理论物理学的学科几乎任何时候都是非常集中的，几乎所有时候，所有理论物理学家的大部分工作都集中在不超过一两个非常高度受限的领域–比如1920年代和1930年代早期的量子理论和1930年代中期以来的原子核的基本粒子和结构。</p>
<p>  对于数学来说，情况完全不同。数学被分为了大量子领域，他们彼此在特性，风格，目标和影响上广泛不同。这显得它和理论物理学极度的集中正好相反。一个好的理论物理学家可能今天仍然掌握这它的学科的一半以上的工作知识。我能不确定任何的现存的数学家都与超过四分之一的学科知识有大量关联。客观的说，一个重要的问题一般会出现在一个数学的子领域已经有了深远的发展且在某个难点上严重停滞之后。不过即便如此，数学家基本上可以自由的选择尝试解决它或者放弃转而去做其他的领域，一个理论物理学上的重要问题一般是一个必须解决的冲突或者矛盾。数学家有着很多领域可以转而从事，而且他在从事的这些领域上享有非常大自由。但是要说决定性的一点：我认为可以确切的说美学是他们选择的标准，同时也是成功的标准。我知道此断言是有争议的，在没有大量具体的技术案例分析的情况下，它不能够被“证明”，或者说真正的详细地去证实。所以我们就此打住吧，不然这会带来不适合于现在这篇文章场合下的高技术性讨论。只要知道美学特征甚至比在我上面提到的理论物理学的例子中更显著就够了。人们希望数学定理或者数学理论不仅可以以一种简单而优雅的方式描述和分类，而且要有很多先验的不同的特例，并且还希望“优雅”能融于它的“建筑”结构组成中。陈述这个问题的时候很容易，最大的难点在于在握住它，在每一次处理它的尝试中，获得一些惊喜的扭转，使得是在这次处理过程或部分处理过程中变得简单。当然，如果结论复杂而冗长，就应该引入一些简单的基本原则，这些原则能阐述那些绕脑的难题，将一些貌似的随意性转变为一些简单的指导动机。在一些潜在经验主义的世俗主题存在的背景之下，这些准则显然是创造性艺术标准。很多时候是一种非常久远的背景，随着美学的野蛮发展产生了大量的错综复杂的类型，这些类型都更贴近于纯粹和简单的艺术风格而不是经验科学氛围。</p>
<p>  你会注意到，我甚至没有提到数学与经验或描述性科学的比较。这里的方法的差异和总体氛围太明显。</p>
<p>  我认为虽然数学科学的谱系冗长而清晰，但数学观点源自于经验主义是比较近似于事实的（这个事实情况太复杂了，以至于只能说是近似于）。不过，一旦这些数学观点被构想出来，该主题就开始经历自己独特的存在方式，这种存在方式更近似与一个完全由美学动机驱动的创造性学科，而不是其他的学科，尤其不可能是经验科学学科。然而，我认为，还有一点需要强调。如果一门数学学科与它的经验性来源相距甚远，更甚如果只是在它的第二，三代间接地受到来自“现实”的思想的启发，那么它就面临巨大的危险。它变得越来越纯粹地美学化，越来越纯粹地艺术化（ I’art pour I’art）。如果该领域被相关主题包围，而这些学科仍然有着更紧密的经验联系，或者这个学科在有着特殊超前的鉴赏力的人的影响之下，这不一定是坏的。不过有一种情况很危险，就是这个学科独立的顺着最小阻力的路线发展，这个远离学科源头的流派，将会分成很多不重要的分支，以至于把这个学科弄成一大堆复杂的杂乱无章的细节。换句话说，在与它的经验性来源有着很大的距离或者在过多“抽象”的综错后，数学学科处于退化的危险之中。一开始这种风格很传统，当他显示出奇怪的迹象时，危险的信号就出现了。很容易给出一些例子，来探索导致风格变得奇怪或者非常奇怪的特定变化，但这又是太过技术了，我们不在这讨论。</p>
<p>  无论如何，一旦发展到这种情况，在我看来，唯一的解决办法是恢复到原点：重新注入或多或少直接的经验思想。我相信，这是一个保护该学科的新颖与活力的必要条件，该方法在未来同样适用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;本文作者是冯诺依曼，英文名为《The Mathematician》，该文章在1947年发表在《Works of the Mind》上，后来也记录在《von Neumann’s Collected Works》中，这篇文章是我听讲座时偶然得知的，于是看了一下后翻译了出来，才疏学浅，只源于爱好，如有不对多多包涵——2017.12.20&lt;/em&gt;  &lt;/p&gt;
&lt;p&gt;本文接&lt;a href=&quot;http://saul.xin/2017/12/13/Von-Neumann-The-Mathematician-part-1/#more&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;上一部分&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="译文" scheme="http://yoursite.com/tags/%E8%AF%91%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>JVM(5):字节码执行引擎</title>
    <link href="http://yoursite.com/2017/12/14/JVM-5-Execution-engine-of-bytecode/"/>
    <id>http://yoursite.com/2017/12/14/JVM-5-Execution-engine-of-bytecode/</id>
    <published>2017-12-14T05:41:54.000Z</published>
    <updated>2017-12-15T16:12:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>  经历过类加载以后，类文件结构就以JVM定义的形式存储在JVM的方法区中。但是程序如何执行的描述存储在我们前面介绍的方法表的Code属性中的字节码指令，字节码执行引擎，即是执行那些直接码指令，以至于让程序“跑”起来。字节码执行引擎相当于JVM的“处理器”。</p>
<p>  实际上JVM规范只定义了字节码执行引擎的概念模型，具体的实现可能是解释执行也可能是编译执行，或者混合起来。但是从外面看，所有的字节码执行引擎输入都是字节码文件，处理后输出的都是执行结果。</p>
<h2 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><p>  JVM的直接码指令是基于栈操作的，我们也知道在JVM的内存结构里，线程私有的3种内存，即虚拟机栈，本地方法栈，和程序计数器。Hotspot中没有本地方法栈和虚拟机栈的区别，在JVM里，这两种栈中的元素都被称之为<strong>栈帧</strong>。栈帧是VM进行方法调用和方法执行的数据结构，它存储了方法的<strong>局部变量表，操作数栈，动态链接和方法返回地址和一些附加信息</strong>。</p>
<a id="more"></a>
<p>  我们之前介绍过方法表的Code属性，你知道它是干嘛的，现在我要说的是，栈帧就是来源于Code属性，我们在这里再看一遍Code属性的具体结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">Code_attribute &#123;</div><div class="line">    u2 attribute_name_index;//固定指向值为Code的一个CONSTANT_Utf8_info</div><div class="line">    u4 attribute_length;</div><div class="line">    /*info部分*/</div><div class="line">    u2 max_stack;//操作数栈的最大深度</div><div class="line">    u2 max_locals;//局部变量表的存储空间，单位Slot(4个字节)</div><div class="line">    /*代码部分*/</div><div class="line">    u4 code_length;</div><div class="line">    u1 code[code_length];</div><div class="line">    /*显示异常处理表部分*/</div><div class="line">    u2 exception_table_length;</div><div class="line">    exception_info exception_table[exception_table_length];</div><div class="line">    /*属性表部分*/</div><div class="line">    u2 attributes_count;</div><div class="line">    attribute_info attributes[attributes_count];</div><div class="line">&#125;</div><div class="line"></div><div class="line">exception_info&#123;</div><div class="line">	u2 start_pc;</div><div class="line">	u2 end_pc;</div><div class="line">	u2 handler_pc;</div><div class="line">	u2 catch_type;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  仔细一看你可以发现Code属性中，把属于它的操作数栈的一些信息都给定死了，实际上却是如此，这些已经定下来的信息会映射到该方法在VM栈中对应的栈帧中。一个栈帧要分配多少内存，仅取决虚拟机的实现，因为运行期的变量所需的具体内存啥的，Code属性已经给你确定好了。</p>
<p>  你已经知道VM栈是一种<strong>线程私有</strong>的内存结构，每个线程一个，而当前线程执行的方法是由它的VM栈的栈顶元素决定的，栈顶元素又称为<strong>当前方法</strong>。执行引擎运行的所有字节码指令都是针对该线程的VM栈栈顶元素进行操作，准确来说是根据那个栈帧的<strong>局部变量表，操作数栈，动态链接和方法返回地址和一些附加信息</strong>进行操作。所以我们迫切需要知道五种数据结构是什么，介绍完之后我们才能来解释一个方法的调用过程。</p>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>  局部变量表和操作数栈其实我们在介绍Code的属性表里的StackMapTable属性时有过一些接触。另外Code属性中的max_locals字段限制的就是局部变量表的最大容量。</p>
<p>  局部变量表的最小容量单位也是Slot，我们在前面的文章中介绍过它，一个Slot一般是32位（这与虚拟机，操作系统有关）,既然是最小单位，那么像boolean，short这种定义上是低于32位的类型，其实在局部变量表中也是按一个Slot来分配的，64位的数据则以连续的两个Slot来表示。</p>
<p>  在介绍<strong>类加载</strong>的时候我们提到了<strong>准备阶段</strong>，这个阶段即是按类型对类变量赋默认值，相信如果你看了我的前一篇文章，应该还记得这一点，准备阶段的存在可以让类变量在没有赋值的情况下有一个默认值，但是方法中的局部变量可没有准备阶段这种东西。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">		<span class="keyword">int</span> m;</div><div class="line">		System.out.println(m);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>  现在我们知道在哪里存储我们的局部变量了，如果你写过一个逆波兰式的计算程序，那你肯定会接触到基于栈的一个计算方式，或许你当时并没有想太多，但是现在我可以告诉你<strong>操作数栈</strong>这个东西就和你当时做的那个小程序里的栈意义上是一样的，只不过我们我们的运算符已经是jvm直接码指令罢了，”基于栈的执行引擎”的名字由来就是操作数栈。</p>
<p>  操作数栈的单位容量也是32位的，如果一个数据类型是64位的那么就栈两个单位容量，这个我在介绍StackMapTable属性时也提到过，操作数栈的最大深度由Code属性中的max_stacks数据项给定。</p>
<p>  在周志明的书中提到过一个<strong>VM栈帧（是虚拟机栈，不是操作数栈，注意）共享的概念</strong>，就是在概念上完全独立的两个方法的VM栈帧，实际实现时，可能会出现前面一个栈帧的局部变量表与后面一个栈帧的操作数栈共用一部分内存区域的情况，这种情况发生在方法调用变量的传递时。</p>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>  栈帧中存在一个指向运行池常量池的该栈帧所属方法的引用 ，这个引用的目的是为了支持<strong>动态链接</strong>。这个我们在类加载的解析阶段提到过，类的解析过程中并非所有的对类文件常量池的符号引用都转化为了直接引用，还有一部分是在运 行时转化，即<strong>动态链接</strong>。</p>
<h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>  在方法中调用另一个方法，被调用的方法无论是异常退出还是正常的完成都会涉及到一个返回之后，调用者方法从哪里继续的问题，如果是异常退出，则VM可以通过异常处理表来确定执行下一条指令的位置，如果是正常退出则就需要<strong>方法返回地址</strong>这个东西了，它主要是保存了调用时的线程的PC计数器的值。</p>
<p>  方法退出时当前帧出栈，然后恢复上层方法的局部变量表和操作数栈，有返回值的话还要把这个返回值压入操作数栈（如果是前面提到的<strong>VM栈帧共享</strong>，也可能不是这样做），然后要把PC计数器按照方法返回地址调整。</p>
<h3 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h3><p>  当然以上是JVM规范中强制要求的几个数据结构，有可能JVM自己需要添加一些信息，用于调试之类的操作，这类信息通通成为附加信息。</p>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>  <strong>方法调用阶段的唯一目的是确定被调用方法的版本。</strong></p>
<p>  在讨论<strong>类文件结构</strong>的时候你就已经知道，在Class文件中方法是以符号引用方式存在的，在类加载的解析过程中，一部分符号引用转化为了直接引用，但是还有一部分动态链接的方法只有等到运行时才能确定直接引用。为了在这些情况都能使得方法成功正确的调用，就有了这个<strong>方法调用</strong>阶段。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>  在类加载的解析阶段，能确定下来“编译期可知，运行期不可变”这个要求的方法，主要包括<strong>静态方法</strong>和<strong>私有方法</strong>两大类。聪明的人稍微想一下就知道了，静态方法是不可以重写的，而私有方法只能在内部访问，所以这两种方法根本不需要考虑会有什么动态变化之类的事情发生，对这两种方法的“版本”只有一种可能，在类编译期就可以确定，在解析阶段直接由符号引用变成直接引用。解析是一个静态过程。</p>
<h3 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h3><p>  首先我要说解析和分派并不是互斥的两个过程，然后我们讨论分派过程，<strong>这个过程涉及到重载和重写在jvm中的实现，总的来说这个过程就是在进一步确定具体要调用那个方法</strong>，我们首先来看看jvm中的方法调用指令。</p>
<p>  虚拟机调用方法的字节码有5条：</p>
<ol>
<li>invokestatic：调用静态方法</li>
<li>invokespecial:调用实例构造器&lt;init&gt;,私有和父类方法。</li>
<li>invokevirtual：调用<strong>虚方法</strong></li>
<li>invokeinterface：调用接口方法，运行期确定一个接口的实现对象</li>
<li><p>invokedynamic：在运行期对调用点限定符动态解析，然后执行该方法，该指令的<strong>分派逻辑</strong>由用户设定的引导方法决定。</p>
<p>上面提到了两个说法：分派逻辑和虚方法，我们先来解释一下虚方法。</p>
<p>invokestatic和invokespecial这两个指令调用的方法，都是在类解析阶段就可以确定其版本。除了上面说明的方法以外，final修饰的方法也是可以唯一确定的，稍微思考一下就知道。这些方法都称之为<strong>非虚方法</strong>，进行指令调用时你不需要考虑多态选择，一个方法不是<strong>非虚的</strong>就是<strong>虚方法</strong>。</p>
</li>
</ol>
<p>分派，分派可以是<strong>静态的也可以是动态的</strong>。</p>
<h4 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h4><p>静态分派是指依赖<strong>静态类型</strong> 来定位目标方法的分派动作。</p>
<p>静态类型的概念我们可以用一句代码来解释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Car car=<span class="keyword">new</span> Benz();</div></pre></td></tr></table></figure>
<p>上面的这句代码中Car就是静态类型，也称之为<strong>外观类型</strong>，外观类型这个词语可能更能让你有一个理解。而Benz则是<strong>实际类型</strong>。</p>
<p>那么什么是依赖静态类型来定位目标方法呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blue</span> </span>&#123;</div><div class="line">		  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startUp</span><span class="params">(Car car)</span></span>&#123;</div><div class="line">		    System.out.println(<span class="string">"You startup a car"</span>);</div><div class="line">		  &#125;</div><div class="line"></div><div class="line">		  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startUp</span><span class="params">(Benz benz)</span></span>&#123;</div><div class="line">		    System.out.println(<span class="string">"You startup a benz"</span>);</div><div class="line">		  &#125;</div><div class="line">		  </div><div class="line">		  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">		      Car benz=<span class="keyword">new</span> Benz();</div><div class="line">		      startUp(benz);</div><div class="line">		  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Benz</span> <span class="keyword">extends</span> <span class="title">Car</span></span>&#123;&#125;;</div></pre></td></tr></table></figure>
<p>对于上面的代码我们输出了”You startup a car”，即它是按照静态类型Car来确定该调用哪个方法的，所以这就是<strong>静态分派</strong>。</p>
<p>静态类型是编译器可知的，在编译期间编译器就会根据静态类型来决定使用哪个重载版本，如果你学过C++的话，那么那本基础书上应该非常明白的翻来覆去的讲过“运行期多态”和“编译期多态”。</p>
<p>  实际上不同的jvm上语言对静态分派的态度也不同，有时候，特别是用了…符号的变长参数的时候，有可能会产生多个分派结果都符合要求的情况，javac往往会用自己定义的规则来选择一个分派，然而scalac就直接报错了，会提示一个不允许混淆的错误，实际上javac的做法我个人认为有时会让编程者感到很疑惑。</p>
<h4 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h4><p>  动态分派涉及到重写，这个应该是常见面试题了，我们这里就不列出代码了。</p>
<p>  动态分派根据实际类型来确定方法，现在我要说明的就是具体的执行过程。首先我们先来认识一下jvm中的多态查找，该过程实际上就是invokevirtual指令的执行过程，也是java语言中重写的本质：</p>
<ol>
<li>首先找到操作数栈栈顶元素所指向对象的<strong>实际类型</strong> ：C。</li>
<li>如果在C中找到与常量中的<strong>描述符和简单名称</strong> 都相同的方法，就验证访问权限，如果通过就返回该方法的直接引用，不通过者抛出java.lang.IllegalAccessError异常</li>
<li>否则递归的寻找父类中的对应方法，如果递归到最后的Object还没有找到就抛出java.lang.AbstractMethodError异常。</li>
</ol>
<h4 id="单分派与多分派"><a href="#单分派与多分派" class="headerlink" title="单分派与多分派"></a>单分派与多分派</h4><p>  我们把目标方法的所有者类型，称之为方法的<strong>接收者</strong>。</p>
<p>  接受者和方法的参数统称为方法的宗量。多分派和单分派的区别就在于是不是方法选择是否是根据多个总量而定的，若不是则为单分派。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Benz</span> <span class="keyword">extends</span> <span class="title">Car</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Car car)</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"hello,Benz"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Benz benz)</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"hi,benz"</span>);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Car car=<span class="keyword">new</span> Benz();</div><div class="line">		car.sayHello(car);</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>  比如对于这样的一段代码，在静态分派时，编译器根据静态类型和方法参数确定了方法为Car.sayHello(Car);。并生成了相应的invokevirtual指令，这里就是属于多分派。</p>
<p>  在程序实际执行过程中，编译器已经决定了方法必须是sayHello(Car),在invokevirtual执行时，jvm只判断方法的实际接收者类型是Benz还是Car，这就是一个典型的单分派过程。</p>
<p>  到java1.8为止，java依然是动态单分派语言。</p>
<h4 id="分派的实现"><a href="#分派的实现" class="headerlink" title="分派的实现"></a>分派的实现</h4><p>  仔细考虑一下就能想到，用一个遍历元数据的方法去实现对方法版本的查找肯定不是一个商业虚拟机的实现方式。为了使性能更加优越，虚拟机常用手段是以建立虚方法表的方式来加快搜索。虚方法表一般是存储在方法区中，每个表对应一个类，里面存储了各个方法的实际入口地址，如果一个子类没有重写父类的方法，那么它的虚方法表中的地址就是父类方法表中的那个对应方法的地址，且在父子类虚方法表中相同签名的方法有同样的索引号。（回忆一下的话，class文件中是不会包含未重写的父类方法的，虚方法表和class文件的存储method_info的数据区不同）</p>
<p>  虚方法表在类加载的准备阶段（类变量默认值赋值完成后）初始化。</p>
<p>  虚方法表只是一种优化方式，商用虚拟机为了保证最高的效率肯定做了其他优化。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  经历过类加载以后，类文件结构就以JVM定义的形式存储在JVM的方法区中。但是程序如何执行的描述存储在我们前面介绍的方法表的Code属性中的字节码指令，字节码执行引擎，即是执行那些直接码指令，以至于让程序“跑”起来。字节码执行引擎相当于JVM的“处理器”。&lt;/p&gt;
&lt;p&gt;  实际上JVM规范只定义了字节码执行引擎的概念模型，具体的实现可能是解释执行也可能是编译执行，或者混合起来。但是从外面看，所有的字节码执行引擎输入都是字节码文件，处理后输出的都是执行结果。&lt;/p&gt;
&lt;h2 id=&quot;运行时栈帧结构&quot;&gt;&lt;a href=&quot;#运行时栈帧结构&quot; class=&quot;headerlink&quot; title=&quot;运行时栈帧结构&quot;&gt;&lt;/a&gt;运行时栈帧结构&lt;/h2&gt;&lt;p&gt;  JVM的直接码指令是基于栈操作的，我们也知道在JVM的内存结构里，线程私有的3种内存，即虚拟机栈，本地方法栈，和程序计数器。Hotspot中没有本地方法栈和虚拟机栈的区别，在JVM里，这两种栈中的元素都被称之为&lt;strong&gt;栈帧&lt;/strong&gt;。栈帧是VM进行方法调用和方法执行的数据结构，它存储了方法的&lt;strong&gt;局部变量表，操作数栈，动态链接和方法返回地址和一些附加信息&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>冯诺依曼：《数学家》（上）</title>
    <link href="http://yoursite.com/2017/12/13/Von-Neumann-The-Mathematician-part-1/"/>
    <id>http://yoursite.com/2017/12/13/Von-Neumann-The-Mathematician-part-1/</id>
    <published>2017-12-13T10:56:43.000Z</published>
    <updated>2017-12-13T15:11:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>本文作者是冯诺依曼，英文名为《The Mathematician》，该文章在1947年发表在《Works of the Mind》上，后来也记录在《von Neumann’s Collected Works》中，这篇文章是我听讲座时偶然得知的，于是看了一下后翻译了出来，才疏学浅，只源于爱好，如有不对多多包涵——2017.12.13</em>  </p>
<a id="more"></a>
<p>  对于脑力工作的本质的论述在任何领域都是一项艰巨的任务，即使是在数学这样一个接近于人类智慧共同努力的中心地带的领域一样如此。无论如何，对于知识成果的本质的论述都是困难的，远远难于对特定领域的知识的运用。比如理解飞机的结构，以及它的升力和推力理论，比纯粹地去驾驶和乘坐，即便是比之控制航向，前者都要难的多。庆幸的是，一个人在通过直觉和经验深刻理解一个流程之前，就应当能够在没有事先很熟悉运转和使用的情况下，获得对这个流程的理解。</p>
<p>  因此，除了本身设定就是简单或者日常的领域，对所有知识成果的论述都是困难的，在数学中，如果讨论停留在非数学层次上，这种限制就变得非常严重,然后讨论将必然表现出一些非常坏的特征；指出这是永远不能正确证明，然后某种完全肤浅的讨论变得不可避免。</p>
<p>  我很清楚在我将要说的这些话中存在的缺陷，所以我提前道歉。此外，我要表达的观点可能并不是很多其他数学家完全同意的，你会得到一个人不太系统化的印象和解释，而我只能给你一点帮助，来裁决他们到底有多中肯。</p>
<p>  尽管存在一些障碍，然而，我必须承认尝试向你解释数学研究的本质是一件有趣而又富有挑战性的任务。我只希望这件事情上我不会太失败。</p>
<p>  在我看来，数学最本质的特点是，它与自然科学有着非常特殊的关系，更普遍地说，应该是任何阐释实践高于纯粹描述的科学。</p>
<p>  很多人，包括数学家，会同意数学不是一门以观察或实验为依据的科学（经验科学），至少在实践上，它的决定性层面和很多经验科学不同。当然，它的发展和很多自然科学有着紧密联系。它的一个主要分支——几何学，实际上是起源于自然科学，或者说经验科学。现代数学中一些最精妙的灵感（我相信是最精妙的）源于自然科学。数学中的一些方法遍及和支配着自然科学的“理论性”分支。在现代经验科学中，这些方法已成为越来越重要的成功标准，无论它们变得接近数学方法还是近似数学的物理方法。 事实上，在整个自然科学中，一连串连续不断的学科交叉现象已经变得越来越明显，所有这些学科交叉现象都与数学沾点边，且几乎与科学进步的理念一致。生物学日益弥漫着化学和物理，化学串着实验和理论物理，物理学中又串着非常数学形式化的理论物理学。 </p>
<p>  数学本质上有一种非常特别的两面性，一个人必须认识到这种两面性，然后接受它，并将它融入到他对这个问题的思考中去。数学本身就是两面的，我不相信能够在不牺牲本质的情况下做出简化的，统一的观点。</p>
<p>  因此，我将不会呈现给你一个统一的版本。我将尽可能地用多种现象去描述数学。</p>
<p>  不可否认的是，数学（我们能想到的纯粹数学中）中的一些最优秀的灵感源于自然科学。我们将提到两个最重要的事实。</p>
<p>  第一个例子，显然应该是几何。几何是古代数学的重要部分。它的几个分支，至今仍是现代数学的几个主要分支之一。毫无疑问，它起源于古代，是经验性的，今天的它开始成为一门学科，就像理论物理学那样。除开所有其他的证据，单单是“几何”这个名字也指明的这一点。欧几里得的公设法（postulational treatment）是远离经验主义的一大步。但捍卫这一立场并不简单，这是具备决定性的，也是最后一步，这伴随着与经验主义完全分离。欧几里得的公理化在少数地方不符合现代公理的严谨性要求，但是在该方面显得不那么重要。更关键的是：其他的无疑是经验性的学科，如力学和热力学，通常表现为或多或少的公设，在一些作者的表现方法很难与欧几里得的那种过程区分开来。我们这个时代的理论物理学的经典——牛顿定理，在它的文学形式和一些最关键部分的核心上，很像欧几里得的手法。当然，在所有这些例子中，在所呈现的假设的背后，都能通过物理洞察力来证实假设，通过实验验证来证明定理，在几何学获得至今数千年的稳定性和现代的理论物理学体系明显缺失的那种权威性之前，有人可能会认为类似欧几里得这种说法是可以接受的，尤其那种古代的观点。</p>
<p>  进一步来说，从欧几里得时代开始几何学的去经验主义逐步发展，但它没有变得更加完备，直到现代依然如此。关于非欧几里得几何学的讨论正好说明了这一点，它也说明了数学思想的矛盾性。讨论早已集中在一个高度抽象层面上，它处理的是一个纯粹的逻辑问题，即欧几里得的“第五公设”能不能由其他公设的引出。形式冲突被<strong>克莱因</strong>的纯数学范例所终结，这个范例展示了欧几里得平面可以利用重新定义的某些基本概念在非欧几里得理论中构建出来。然而经验主义阴霾从始至终都存在。在所有的欧几里得公设中，第五个受到了质疑的原因很明显只能来自于整个无限平面概念的这种非经验主义特点。最伟大数学家<strong>高斯</strong>的脑海里肯定存在着这个至少有重要意义的观点，尽管所有决定性的数学逻辑分析表明欧几里得几何学可能必须是经验主义的。在<strong>波尔约，罗巴切夫斯基，黎曼，克莱因</strong>取得更多的抽象结论之后，今天我们考虑原争论的结论，经验主义，更确切的说是物理学，依然有着最终的话语权。广义相对论的提出，迫使我们在新的设定下重新审视我们的几何学观点，它也带来了纯粹数学重点的全新的分配。最后我们来做一个完全的对比，最后这次发展发生在同一代人中，这一代人目睹了在现代公理逻辑数学家手中，欧几里得公理化方法的完全去经验化和去抽象化。，这两种矛盾的态度在一个数学家的脑中很好的相容了；可以看出，希尔伯特在公理化和广义相对论中都做出了巨大的共享。</p>
<p>  第二例子是微积分，可以说所有的解析，都是由它产生。微积分是现代数学的第一个成就，它的重要性大到难以估计，我认为它比任何其他东西都更明确的定义现代数学的开端，它的逻辑推导铸就了数学分析系统，现仍然是精确思想中最伟大的技术进步。</p>
<p>  微积分的显然起源于经验主义，开普勒首次正式尝试就是定义被称为“dolichometry”的方法，即对带有曲面的物体进行体积测量的方法。这是几何，但不是欧几里得几何，在那个时代，它是非公理化的经验主义几何。关于这点，开普勒非常清楚。牛顿和莱布尼茨的主要成果和发现，都明确的源自于物理。牛顿发明了“流数法”微积分，本质上是为了力学目的。实际上对于微积分和力学，这两个学科或多或少的一起发展，微积分的第一个公式在数学上是不严谨的。在牛顿之后的150年里这样一个不严谨的半物理公式是唯一的可选项。与这个不严谨，数学发展也不充分的时代背景相反，在这期间，解析学发生了很多重大的突破。这个时代的一些主要的数学思想肯定是不严谨的，比如<strong>欧拉</strong>；当然另外一些人，总体上是严谨的，比如<strong>高斯</strong>或者<strong>雅可比</strong>。虽然没有数学家会忽略那个时代（那个时代的数学获得了空前的发展），但是这一发展过程既混乱又模糊，它与经验主义的关系显然不是根据我们当前(或欧几里得的)抽象和严谨的思想而定的。甚至是在<strong>柯西</strong>重新从根本上确立统治地位之后，一个非常特殊的从新回归半物理方法的倒退却随着黎曼而生，黎曼的学术个性本身就是数学双重本质的一个最具说明性的例子，正如<strong>黎曼和魏尔斯特拉斯</strong>的论战，我们就此打住吧，如果我再深入研究下去的话就是技术细节了。从魏尔斯特拉斯开始，分析看起来变得完全抽象，严谨且不再经验性。即便不是绝对正确。关于数理和逻辑“基础”的论战，发生在过去的两代人里，消除了很多关于真相的错误观念。</p>
<p>  这给我带来了第三个例子，这个例子和判断有关，它所涉及的是数学与哲学或者认知论的关系，而非数学与自然科学的关系。这个例子以一种非常新颖的方式说明了“完全”的数学严谨性的绝对观念并非是不可变的。严谨这一概念的多变性表明除了数学抽象以外的一些东西必定参与到了数学的构成中。在分析关于“基础”的论战中，我无法说服自己接受必须迎合其他因素的经验性质的结论。虽然至少在某些阶段的讨论中，赞成这些解释的理由是非常有力的。但我不认为它是完全让人信服的。然而，有两件事是清楚地。首先，一些非数学的东西，某种程度上与经验性科学或哲学联系在一起，或者两者兼而有之，确实从本质上进入了，他们的非经验特征能够维持下去，取决于一个人是否认为哲学（或者认识论）可以独立的存在（这种假设是必要的，但是不够充分）。第二，一些例子强力支持着数学的经验性起源，比如我们上面提到的两种例子（集合和微积分），这与“基础”论战的最佳解释是什么无关。</p>
<p>  在分析数学严谨性概念的易变性时，我想强调上文所提到的“基础”论战，然而，我会先简要地细想一下这个问题的次要方面，这个方面加强了我的论点，但是我认为它的次要的，因为比之“基础”论战的分析，它可能不那么确切。我指的是数学“风格”的变化。众所周知，数学证明的写作风格已经经历了相当大的波动。这里讨论波动而不是某种趋势是因为在某些方面上十八、十九世纪的某些作者和现在之间的风格差异比现在和欧几里得时代更大。但是，在其他方面却具有非常显著的稳定性。在存在差异的领域中，主要差异是存在于表现上，这些差异可以再不引入任何新思想的情况下消除。然而，在很多情况下这些差异大到让人怀疑在不需要考虑他们是否真的对数学的严谨性有同样的想法，仅仅通过不同的风格，品味和教育水平，就可以把不同方式展现它们的作者给区分开来。结果，在极端情况下（例如，在上面提到的，18世纪晚期的分析工作），差异无法避免，即便可以补救，也要在全新而重要的理论的帮助下才行得通，而这些理论的发展需要数百年。一些在那种于今天而言是不严谨的方式（当时有一些同僚批评）下工作的数学家已经很清楚的意识到他们自身的工作方式缺乏严谨性。更客观的说，他们自身渴望数学处理方法应该和我们今天的观点一样，而不是只拘于他们手头上做的那种。不过那个时代的一些大师，比如欧拉，显得对于那种方法十分信任且对他们自己的标准很满意。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;本文作者是冯诺依曼，英文名为《The Mathematician》，该文章在1947年发表在《Works of the Mind》上，后来也记录在《von Neumann’s Collected Works》中，这篇文章是我听讲座时偶然得知的，于是看了一下后翻译了出来，才疏学浅，只源于爱好，如有不对多多包涵——2017.12.13&lt;/em&gt;  &lt;/p&gt;
    
    </summary>
    
    
      <category term="译文" scheme="http://yoursite.com/tags/%E8%AF%91%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>ES6(2):Destructuring assignment</title>
    <link href="http://yoursite.com/2017/12/08/ES6-2-Destructuring-assignment/"/>
    <id>http://yoursite.com/2017/12/08/ES6-2-Destructuring-assignment/</id>
    <published>2017-12-08T15:57:12.000Z</published>
    <updated>2017-12-09T07:13:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>  本世纪以来的很多新语言都提供了各种赋值或者模式匹配判断的语法糖，es6也提供了对解构赋值的一系列支持使得我们可以在很多情况下节省很多行代码。但是对一个复杂模式的解构赋值很可能让维护代码的人员感到很疑惑，所以这里记录的解构赋值没有那么多奇技淫巧。</p>
<a id="more"></a>
<h2 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h2><p>我们在es6中，可以向scala中操作元组和集合那样，用模式匹配的方式来对数组进行解构赋值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> [a, [b, c], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</div><div class="line">    alert(c);<span class="comment">//输出3</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> [a, b] = [, <span class="number">2</span>];</div><div class="line">    alert(a);<span class="comment">//a没有匹配项，解构不成功，输出undefined</span></div><div class="line">    alert(b);<span class="comment">//输出2</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> [a, b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">    alert(b);<span class="comment">//输出2</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">    <span class="comment">// 我们可以用...来表示一个多值匹配</span></div><div class="line">    <span class="keyword">let</span> [a, [...b], c] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>];</div><div class="line">    alert(b);<span class="comment">//输出2,3,4</span></div><div class="line">    alert(c);<span class="comment">//输出5</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line">    alert(b);<span class="comment">//输出2,3,4</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="提供默认值的解构"><a href="#提供默认值的解构" class="headerlink" title="提供默认值的解构"></a>提供默认值的解构</h3><p>我们可以为解构需要的变量赋默认值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> [a, b = <span class="number">4</span>] = [<span class="number">1</span>];</div><div class="line">    alert(b);<span class="comment">//输出4</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> [a, b = <span class="number">4</span>] = [<span class="number">1</span>, <span class="literal">undefined</span>];<span class="comment">//不严格等于undefined，所以赋默认值</span></div><div class="line">    <span class="keyword">let</span> [c,d=<span class="number">4</span>]=[<span class="number">1</span>,<span class="literal">null</span>];</div><div class="line">    alert(b);<span class="comment">//输出4</span></div><div class="line">    alert(d);<span class="comment">//输出null</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> [a, b = a] = [<span class="number">1</span>];<span class="comment">//你甚至可以这样</span></div><div class="line">    alert(b);<span class="comment">//输出1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h3><p>es6中也有惰性求值这种东西的存在，比如如果结构中默认值是一个表达式那么，默认值其实是惰性求值的，即如果结构成功这个表达式根本不执行<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">lazy</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(<span class="string">"execute lazy"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="string">"abc"</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> [m = lazy(), k] = [<span class="number">1</span>, <span class="number">2</span>];<span class="comment">//不出现弹窗</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="数组结构与可遍历性"><a href="#数组结构与可遍历性" class="headerlink" title="数组结构与可遍历性"></a>数组结构与可遍历性</h3><p>数组解构赋值的进行实际上是利用了右边集合的可遍历性，如果右边的集合不具有可遍历性则直接报错<br>相反的，如果右边的集合是一个可遍历的结构，当然就是可以解构的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> [k] = <span class="literal">NaN</span>;<span class="comment">//Uncaught TypeError: NaN is not iterable</span></div><div class="line">    <span class="comment">// let [k]=1;</span></div><div class="line">    <span class="comment">// let [k]=&#123;&#125;;</span></div><div class="line">    <span class="comment">// let [k]=null;</span></div><div class="line">    <span class="comment">// let [k]=false;</span></div><div class="line">    <span class="comment">// let [k]=undefined;</span></div><div class="line">  <span class="comment">//全部报类似错误</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><p>对象也可以使用解构方式来赋值，不过对象不再要求右边的值是一个可遍历的解构了<br>这种方式类似于scala中的函数传参<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> &#123;tom, jack&#125; = &#123;<span class="attr">jack</span>: <span class="string">"jack"</span>, <span class="attr">tom</span>: <span class="string">"tom"</span>&#125;;</div><div class="line">    <span class="comment">//相当于 let &#123;tom:tom, jack:jack&#125; = &#123;jack: "jack", tom: "tom"&#125;;</span></div><div class="line">    alert(tom);<span class="comment">//输出tom</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="对象结构中的默认值使用"><a href="#对象结构中的默认值使用" class="headerlink" title="对象结构中的默认值使用"></a>对象结构中的默认值使用</h3><p>当然我们可以赋默认值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> &#123;tom=<span class="string">"TOM"</span>,mary, jack&#125; = &#123;<span class="attr">jack</span>: <span class="string">"jack"</span>&#125;;</div><div class="line">    alert(tom);</div><div class="line">    alert(mary);<span class="comment">//输出undefined</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这种语法糖更是提供了我们对对象属性的赋值，和将对象属性直接转化为变量<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">   <span class="keyword">let</span> man=&#123;<span class="attr">clz</span>:<span class="string">"Man"</span>,<span class="attr">old</span>:<span class="number">18</span>&#125;;</div><div class="line">   <span class="keyword">let</span> &#123;<span class="attr">clz</span>:clz,<span class="attr">old</span>:od&#125;=man;<span class="comment">//以属性名:变量名的方式来确定赋值</span></div><div class="line">    alert(clz);</div><div class="line">    alert(od);</div><div class="line"></div><div class="line">   <span class="keyword">let</span> woman=&#123;<span class="attr">clz</span>:<span class="string">"woman"</span>,<span class="attr">old</span>:od&#125;;<span class="comment">//变量作为实际值</span></div><div class="line">   alert(woman.old);<span class="comment">//输出18</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="嵌套匹配结构"><a href="#嵌套匹配结构" class="headerlink" title="嵌套匹配结构"></a>嵌套匹配结构</h3><p>嵌套的匹配<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> course=&#123;</div><div class="line">        <span class="attr">name</span>:<span class="string">"Operation System"</span>,</div><div class="line">        <span class="attr">detail</span>:&#123;</div><div class="line">            <span class="attr">score</span>:<span class="number">3.5</span>,</div><div class="line">            <span class="attr">teacher</span>:[<span class="string">"Mark Watson"</span>,<span class="string">"John Joy"</span>]</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">let</span> &#123;name,<span class="attr">detail</span>:&#123;score,<span class="attr">teacher</span>:[t1,t2]&#125;&#125;=course;</div><div class="line">    <span class="comment">//如果你想获取整个detail的值，可以这样let &#123;name,detail,detail:&#123;score,teacher:[t1,t2]&#125;&#125;=course;</span></div><div class="line">    alert(name);</div><div class="line">    alert(score);</div><div class="line">    alert(t2);<span class="comment">//正确输出了John joy，可见新的语法糖给我们带来的便利是很明显的，虽然很少会用到</span></div><div class="line">&#125;</div><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> k=[];</div><div class="line">    (&#123;<span class="attr">z</span>:k[<span class="number">1</span>],<span class="attr">m</span>:k[<span class="number">0</span>]&#125;=&#123;<span class="attr">m</span>:<span class="number">2</span>,<span class="attr">z</span>:<span class="number">1</span>&#125;);<span class="comment">//加小括号的理由是&#123;开头会被解释器认为是一个代码块的开始</span></div><div class="line">    alert(k[<span class="number">0</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="提取函数和转化字符串"><a href="#提取函数和转化字符串" class="headerlink" title="提取函数和转化字符串"></a>提取函数和转化字符串</h3><p>我们可以这样讲对象中的函数提取出来<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> &#123;sin,cos,log,tan&#125;=<span class="built_in">Math</span>;</div><div class="line">    alert(tan);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于字符串，我们可以将它解构为一个个字符<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">   <span class="keyword">let</span> [a,b,c]=<span class="string">"abc"</span>;</div><div class="line">   alert(a+<span class="string">"~"</span>+b+<span class="string">"~"</span>+c);<span class="comment">//输出a~b~c</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="函数解构"><a href="#函数解构" class="headerlink" title="函数解构"></a>函数解构</h2><p>对函数的数组参数进行解构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    function hello([x,y]) &#123;</div><div class="line">        alert(x+&quot; &quot;+y);</div><div class="line">    &#125;</div><div class="line">    let v=[&quot;hello&quot;,&quot;world&quot;];</div><div class="line">    hello(v);//输出hello world</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>提供默认值和默认参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    function halo(&#123;x=&quot;halo&quot;,y=&quot;world&quot;&#125;=&#123;&#125;) &#123;</div><div class="line">        alert(x+&quot; &quot;+y);</div><div class="line">    &#125;</div><div class="line">    halo(&#123;x:&quot;hello&quot;&#125;);</div><div class="line">    halo(&#123;y:&quot;Jack&quot;&#125;);</div><div class="line">    function hi(&#123;x,y&#125;=&#123;x:&quot;hi&quot;,y:&quot;world&quot;&#125;) &#123;</div><div class="line">        alert(x+&quot; &quot;+y);</div><div class="line">    &#125;</div><div class="line">    hi(&#123;x:&quot;hello&quot;&#125;);//提供了参数&#123;x:&quot;hello&quot;&#125;，不使用默认参数，输出hello undefined</div><div class="line">    hi();//使用默认参数，输出hello world</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="解构的应用"><a href="#解构的应用" class="headerlink" title="解构的应用"></a>解构的应用</h2><p>用于交换<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> [x,y]=[<span class="number">1</span>,<span class="number">2</span>];</div><div class="line">    [x,y]=[y,x];</div><div class="line">    alert(y);<span class="comment">//输出1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>用于解构函数的返回值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnArray</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnObj</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;<span class="attr">x</span>:<span class="string">"hey"</span>,<span class="attr">y</span>:<span class="string">"Daisy"</span>&#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> [a,b,c]=returnArray();</div><div class="line"><span class="keyword">let</span> &#123;<span class="attr">x</span>:m,<span class="attr">y</span>:k&#125;=returnObj();</div><div class="line">alert(k);<span class="comment">//Daisy</span></div><div class="line">alert(b);<span class="comment">//2</span></div></pre></td></tr></table></figure></p>
<p>快速提取json对象中的数据<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> json=&#123;<span class="attr">name</span>:<span class="string">"Jack"</span>,<span class="attr">score</span>:[<span class="number">83</span>,<span class="number">91</span>],<span class="attr">old</span>:<span class="number">15</span>&#125;;</div><div class="line"><span class="keyword">let</span> &#123;<span class="attr">name</span>:x,<span class="attr">score</span>:s,<span class="attr">old</span>:o&#125;=json</div><div class="line">alert(s[<span class="number">1</span>]);<span class="comment">//91</span></div></pre></td></tr></table></figure></p>
<p>提取map中的键值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</div><div class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</div><div class="line">    alert(key + <span class="string">" is "</span> + value);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  本世纪以来的很多新语言都提供了各种赋值或者模式匹配判断的语法糖，es6也提供了对解构赋值的一系列支持使得我们可以在很多情况下节省很多行代码。但是对一个复杂模式的解构赋值很可能让维护代码的人员感到很疑惑，所以这里记录的解构赋值没有那么多奇技淫巧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Learning ES6(1):块作用域</title>
    <link href="http://yoursite.com/2017/12/06/Learning-ES6-1-Block-scope/"/>
    <id>http://yoursite.com/2017/12/06/Learning-ES6-1-Block-scope/</id>
    <published>2017-12-06T06:46:19.000Z</published>
    <updated>2017-12-06T08:42:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>  最近主要是在学习3个东西，一个就是单元测试，第二个就是jvm，还有一个就是es6了，目前的话jvm已经学完了，就差把笔记搬运从笔记本上到博客上，单元测试和es6的话都是正在进行，es6的是阮一峰的<a href="https://github.com/ruanyf/es6tutorial" target="_blank" rel="external">ECMAScript 6 入门</a>，大神已经把书开源道github上了，推荐大家去看那本书，博客这里主要用于我个人用于以后回忆某些知识用的。</p>
<p>  至于es6是什么可以自行使用搜索引擎，或看上面那本书的第1章，这里我就不介绍了。</p>
<hr>
<p>  在ES6之前，js中是没有<strong>块级作用域</strong>这个东西的，只有<strong>函数</strong>和<strong>全局</strong>作用域<br>  ES6中的第一个特性，即以let来声明一个变量，这个变量只在当前代码块中有效，比如对于如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">let</span> k = <span class="number">3</span>;<span class="comment">//k作用域只在当前代码块中</span></div><div class="line">    &#125;</div><div class="line">    alert(k); <span class="comment">//报错，外层代码不能去引用内层代码块中的k，如果上面是var则输出3</span></div><div class="line">&#125;();</div><div class="line"></div><div class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> k = <span class="number">3</span>;</div><div class="line">    &#123;</div><div class="line">        alert(k);<span class="comment">//正常输出3</span></div><div class="line">    &#125;</div><div class="line">&#125;();</div><div class="line"></div><div class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> k = <span class="number">4</span>;</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">let</span> k = <span class="number">5</span>;</div><div class="line">        alert(k);<span class="comment">//输出k=5</span></div><div class="line">    &#125;</div><div class="line">    alert(k);<span class="comment">//输出k=4</span></div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="let变量特性"><a href="#let变量特性" class="headerlink" title="let变量特性"></a>let变量特性</h2><h3 id="变量提升和暂时性死区"><a href="#变量提升和暂时性死区" class="headerlink" title="变量提升和暂时性死区"></a>变量提升和暂时性死区</h3><p>  对于var声明的变量会有变量提升问题，即是在作用域开头变量已经存在但是没有赋值，<strong>var定义的变量只能是函数或者全局作用域有效的，没有块这个概念</strong>。比如对于以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(f);<span class="comment">//输出undefined，var声明的变量标识在函数作用域有效，有变量提升</span></div><div class="line">    <span class="keyword">var</span> f = <span class="number">1</span>;</div><div class="line">&#125;();</div><div class="line"></div><div class="line"><span class="comment">//实际相当于执行代码：</span></div><div class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  	<span class="keyword">var</span> f = <span class="literal">undefined</span>;</div><div class="line">    alert(f);</div><div class="line">    f = <span class="number">1</span>;</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>但是对于let来说，这样声明就报错，<strong>let声明的变量没有变量提升</strong>，作用域是块级。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">//TDZ开始</span></div><div class="line">    alert(k);<span class="comment">//报错:Uncaught ReferenceError: k is not defined</span></div><div class="line">    <span class="keyword">let</span> k = <span class="number">1</span>;<span class="comment">//TDZ结束</span></div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>现在我们来引入一个概念：暂时性死区(temporl dead zone,TDZ),这个概念是对于let和const变量而言的，es6引入它的目的在于，让js程序员养成使用前先定义的好习惯。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">* 在阮一峰的《ECMAScript 6 入门》中提到</div><div class="line">* ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。</div><div class="line">* 凡是在声明之前就使用这些变量（任何操作），就会报错。</div><div class="line">*</div><div class="line">* 在块中，let定义一个变量n之前的区域，都称之为“展暂时性死区”</div></pre></td></tr></table></figure>
<p>总之，暂时性死区的本质就是，<strong>只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</strong></p>
<h3 id="不可重复声明"><a href="#不可重复声明" class="headerlink" title="不可重复声明"></a>不可重复声明</h3><p>在同一个作用域中，var声明的变量可以重复声明，会取后声明的值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//正常运行</span></div><div class="line">    <span class="keyword">var</span> f = <span class="number">1</span>;</div><div class="line">    <span class="keyword">var</span> f = <span class="number">2</span>;</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>而在同一个作用域中，let声明的变量不可以重复声明，会报错</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//报错</span></div><div class="line">    <span class="keyword">let</span> k = <span class="number">4</span>;</div><div class="line">    <span class="keyword">let</span> k = <span class="number">5</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//如果同一个变量已经被var声明，那么如果它再用let声明同样报错</span></div><div class="line">    <span class="comment">//let f=3;</span></div><div class="line">&#125;();</div><div class="line"></div><div class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> f = <span class="number">4</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//如果同一个变量已经被var声明，那么如果它再用let声明同样报错</span></div><div class="line">    <span class="comment">//相反一样</span></div><div class="line">    <span class="keyword">let</span> f=<span class="number">3</span>;<span class="comment">//这一行报错</span></div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<h3 id="用let做for循环参数"><a href="#用let做for循环参数" class="headerlink" title="用let做for循环参数"></a>用let做for循环参数</h3><p>ES5中由于闭包关系，我们不得不用一段不太漂亮的代码来实现for循环中i的不同取值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">!function () &#123;</div><div class="line">    var a = &#123;&#125;;</div><div class="line">    for (let i = 0; i &lt; 10; i++) &#123;</div><div class="line">        a[i] = function (arg) &#123;//闭包函数，以变量arg来保存当前i的值，从而传递给内部的返回函数</div><div class="line">            return function () &#123;</div><div class="line">                alert(arg)</div><div class="line">            &#125;</div><div class="line">        &#125;(i);</div><div class="line">    &#125;</div><div class="line">    a[6]()</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>在ES6中我们可以这样做:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> a = &#123;&#125;;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">        a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            alert(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    a[<span class="number">6</span>]()</div><div class="line">&#125;();</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> 这里很多人可能会理解错误，因为for语句和&#123;&#125;代码块其实是两个作用域</div><div class="line"> 而let只能在当前作用域有效，那么&#123;&#125;代码块里的数据是怎么来的呢？</div><div class="line"> 其实这里每次循环都创建了一个新的i，这个新的i的值在旧的i的基础上计算</div><div class="line"> */</div><div class="line"> </div><div class="line"><span class="comment">//类似于执行一个这样的，过程</span></div><div class="line"><span class="keyword">var</span> a = &#123;&#125;;</div><div class="line">&#123; <span class="keyword">let</span> k = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">for</span> (;k &lt; <span class="number">10</span>;) &#123;</div><div class="line">      <span class="keyword">let</span> i = k; </div><div class="line">      a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        alert(i);</div><div class="line">      &#125;;</div><div class="line">      k++;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></div><div class="line"></div><div class="line"><span class="comment">//在babel中转成es代码是这样的：</span></div><div class="line"><span class="keyword">var</span> a = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> _loop = <span class="function"><span class="keyword">function</span> <span class="title">_loop</span>(<span class="params">i</span>) </span>&#123;</div><div class="line">    a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        alert(i);</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    _loop(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="const变量"><a href="#const变量" class="headerlink" title="const变量"></a>const变量</h2><p>  const声明常量，一旦声明就不能被改变，所以const声明时必须立刻赋值<br>如果下代码不赋值就抛出：Uncaught SyntaxError: Missing initializer in const declaration</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> k;</div><div class="line">alert(k);</div></pre></td></tr></table></figure>
<p><strong>const同样只在块作用域内有效，不可重复声明，且存在暂时性死区</strong></p>
<p>  const只能保证它所指向的地址不可变，但是这个地址的数据结构怎么变它管不了，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> man=&#123;&#125;;</div><div class="line">man.name=<span class="string">"Tom"</span>;</div><div class="line">man.name=<span class="string">"Jack"</span>;</div><div class="line">alert(man.name);<span class="comment">//输出jack</span></div></pre></td></tr></table></figure>
<p>  如果要保证对象不可变，还是必须用Object.freeze去冻结一个对象，比如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> man=<span class="built_in">Object</span>.freeze(&#123;<span class="attr">name</span>:<span class="string">"Tom"</span>&#125;);</div><div class="line">man.name=<span class="string">"Jack"</span>;<span class="comment">//不报错，但是不起作用，如果是严格模式就报错了</span></div><div class="line">alert(man.name);</div></pre></td></tr></table></figure>
<p>这种冻结方式对对象的对象引用属性没效果，但是你可以以递归去写一个冻结函数。</p>
<h2 id="块级作用域和函数"><a href="#块级作用域和函数" class="headerlink" title="块级作用域和函数"></a>块级作用域和函数</h2><p>在es5浏览器中，下面的代码是可以正常运行的，并输出I am inside，因为function声明会提升到函数作用域顶端</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>); &#125;</div><div class="line">    !<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</div><div class="line">            <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>); &#125;</div><div class="line">        &#125;</div><div class="line">        f();</div><div class="line">    &#125;();</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>  在es5浏览器中，上面的代码是可以正常运行的，并输出I am inside，因为function声明会提升到函数作用域顶端，实际上执行下面这段：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>); &#125;</div><div class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>); &#125;</div><div class="line">        <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</div><div class="line">        &#125;</div><div class="line">        f();</div><div class="line">    &#125;());</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>  在es6浏览器中，在块级作用域中声明函数，类似var声明变量，下面这段代码会抛出错误:Uncaught TypeError: f is not a function<br>实际上es6浏览器执行的代码，是类似于下面这段：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>); &#125;</div><div class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> f = <span class="literal">undefined</span>;</div><div class="line">        <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</div><div class="line">            f=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>); &#125;</div><div class="line">        &#125;</div><div class="line">        f();</div><div class="line">    &#125;());</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>  最佳实践是：避免在块级作用域内声明函数，在有必要的情况下，也应该写成函数表达式，而不是函数声明语句。</p>
<h2 id="全局作用域的let和const"><a href="#全局作用域的let和const" class="headerlink" title="全局作用域的let和const"></a>全局作用域的let和const</h2><p>在es5中，我们知道浏览器中的顶层对象指的是window和self对象(Node中是global)</p>
<p>浏览器中对于var和function命令声明的全局变量，其实就是window的属性</p>
<p>es6为了改变这种含糊的表达方式，但是又不得不得向以前的代码妥协，于是它做出了以下区分：<br>首先它对于var和function命令声明的全局变量意义不变<br>对于let,const,class声明的全局变量，不再是顶层对象的属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">abc</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">"abc"</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">window</span>.abc();</div><div class="line"></div><div class="line"><span class="keyword">var</span> k=<span class="string">"kkk"</span>;</div><div class="line">alert(<span class="built_in">window</span>.k);</div><div class="line"></div><div class="line"><span class="keyword">let</span> i=<span class="string">"iii"</span>;</div><div class="line">alert(<span class="built_in">window</span>.i);<span class="comment">//undefinded</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  最近主要是在学习3个东西，一个就是单元测试，第二个就是jvm，还有一个就是es6了，目前的话jvm已经学完了，就差把笔记搬运从笔记本上到博客上，单元测试和es6的话都是正在进行，es6的是阮一峰的&lt;a href=&quot;https://github.com/ruanyf/es6tutorial&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ECMAScript 6 入门&lt;/a&gt;，大神已经把书开源道github上了，推荐大家去看那本书，博客这里主要用于我个人用于以后回忆某些知识用的。&lt;/p&gt;
&lt;p&gt;  至于es6是什么可以自行使用搜索引擎，或看上面那本书的第1章，这里我就不介绍了。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;  在ES6之前，js中是没有&lt;strong&gt;块级作用域&lt;/strong&gt;这个东西的，只有&lt;strong&gt;函数&lt;/strong&gt;和&lt;strong&gt;全局&lt;/strong&gt;作用域&lt;br&gt;  ES6中的第一个特性，即以let来声明一个变量，这个变量只在当前代码块中有效，比如对于如下代码：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;!&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; k = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//k作用域只在当前代码块中&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    alert(k); &lt;span class=&quot;comment&quot;&gt;//报错，外层代码不能去引用内层代码块中的k，如果上面是var则输出3&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;!&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; k = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        alert(k);&lt;span class=&quot;comment&quot;&gt;//正常输出3&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;!&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; k = &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; k = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        alert(k);&lt;span class=&quot;comment&quot;&gt;//输出k=5&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    alert(k);&lt;span class=&quot;comment&quot;&gt;//输出k=4&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
