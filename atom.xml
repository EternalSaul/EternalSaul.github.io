<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog of Saul</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-03T08:53:17.384Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Saul</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Notes of Deep Learning:Neural network 2</title>
    <link href="http://yoursite.com/2018/03/01/Notes-of-Deep-Learning-Neural-network-2/"/>
    <id>http://yoursite.com/2018/03/01/Notes-of-Deep-Learning-Neural-network-2/</id>
    <published>2018-03-01T02:26:43.000Z</published>
    <updated>2018-03-03T08:53:17.384Z</updated>
    
    <content type="html"><![CDATA[<p>  从上一篇博文，我们知道，神经网络其实就是一个一系列线性映射和非线性激活函数交织起来的评分函数，我们在输入层输入我们的数据，经过隐层的一系列点积和激活函数计算在输出层得到一个类型评分，然而要比较好地训练一个神经网络，我们需要更多的考虑，比如数据预处理，我们还需要考虑权重的初始值以及如何选择激活函数。‘</p>
<h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>  我们通常会对<strong>训练集</strong>数据进行预处理，当然这可能有很多种形式，比如我们如果要去除一些噪声可能要进行数据清洗，这一部分这里先不介绍了，我们这里主要介绍归一化，归一化可以有利于避免模型训练时出现数值问题，还有利于网络快速收敛，更具体的优点你可以查看<a href="http://nnetinfo.com/nninfo/showText.jsp?id=37" target="_blank" rel="external">这里</a>。</p>
<p>  归一化（Normalization）即把数据的所有维度都归一化，使其数值范围都近似相等，这个种预处理操作只在确信不同输入特征有不同的输入范围时才有意义，对于图像处理中，像素的范围都是0-255，所以这样做对于图片数据意义不大，但是数据如果是表示一个人，（体重（kg），身高（m），年龄）,这样的数据显然60Kg的体重和1.7m的身高不太对等，这会产生一些数值问题，我们有必要进行归一化。这里有两种方式进行<strong>归一化</strong>：</p>
<p>先假设数据矩阵M，尺寸是N*D,N为样本数目，D是数据维度</p>
<p>第一种：对数据先做零中心化(zero-centered)，如果用numpy表示：M-=np.mean(X,axis=0)，然后我们对每个维度都除以它的标准差就可以了，M/=np.std(X,axis=0)。</p>
<p>第二种：对每个维度归一化使得每个维度的最大和最小值是1和-1。</p>
<p>  实际上零中心化单独也可以看成是一种预处理操作，被称作是<strong>均值减法</strong>在实际中用的也比较多，另外由于近来BN层的引入，归一化在有BN层的情况下也就没有必要了，因为每次卷积后BN层会把数据拉到0均值1方差的分布（标准高斯分布）上，并且这个均值和方差还是更加精确的动态统计出来的，而非原始输入上统计，因此在BN引入后归一化没什么必要。</p>
<p>  我在前面就说过，数据预处理，归一化只是一种情况，还可能进行数据清洗，数据增强，白化和PCA等等操作，图片处理中有时候我们还会转换图片的格式，这也是一种预处理。预处理在模型训练中非常重要，有时候甚至决定着学习算法本身的好坏。</p>
<h2 id="权重初始化"><a href="#权重初始化" class="headerlink" title="权重初始化"></a>权重初始化</h2><p>  要训练我们的网络，我们确定好我们需要一个怎么样的模型，然后构建一个最开始的网络，这样的话，网络中各种参数的初始值就显得非常重要，权重就是其中之一。</p>
<p>  一些人可能会认为把权重都设置为0比较好，然而仔细思考一下，如果一开始整个网络中每一个神经元的输出都是一样的（权重相同），那么反向传播中他们会输出同样的梯度，从而进行同样的更新，这显然就是不对的，你相当于复制了神经元。</p>
<p>  因为数据进行了适当的归一化，又要避免相同的参数更新，我们可以让权重的初始值接近于0，但是却又不等于0，为了得到不同的权重，我们可以以随机数产生器器来初始化我们的权重，这里我们产生的随机数可以服从正态分布或者均匀分布。需要注意的时，最好不要让随机值太小，因为太小的权重值会导致计算出的额梯度非常小，以至于一致我们在反向传播中的梯度信号。</p>
<p>  为了保证神经元起始时有近似相同的输出分布，我们必须想办法校准方差，一般的方法是采用1/sqrt(N)，来做校准，其中N是输入数据的数量，这样我们可以把输出数据的分布的方差校准到1，如果用numpy表示，即：w=np.random.randn(N)/sqrt(n)。</p>
<p>  有一种被称作<strong>稀疏初始化</strong> 的方法，将索引权重设置为0，但是为了避免相同的参数更新，每个神经元都同下一层固定数目的神经元随机连接，连接权重的数值由一个小的高斯分布生成。</p>
<p>  当前比较推荐的方法是在激活函数是ReLU的情况下使用，w=np.random.randn(N)/sqrt(2/n)来进行权重初始化，另外我们一般把偏置设置为0。</p>
<p>  上面介绍数据预处理的时候我们提到过一个被称为BN层(Batch Normalization)的东西，中文翻译是：<strong>批量归一化</strong>，它不仅可以避免<strong>归一化</strong>操作，也可以帮助我们解决初始化神经网络这个问题，我们通常会在全连接或者卷积层与激活函数之间添加一个BN层，让数据服从标准高斯分布，详细操作可以看这篇<a href="https://arxiv.org/abs/1502.03167" target="_blank" rel="external">文章</a>。</p>
<h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><p>  我们在上一篇文章中知道了，正则化是避免过拟合的好方法，正则化也有很多种,比如最常见的L2正则化，以及你听的非常多的随机失活(dropout)方法。</p>
<h3 id="L1，L2正则化"><a href="#L1，L2正则化" class="headerlink" title="L1，L2正则化"></a>L1，L2正则化</h3><p>1.L2正则化</p>
<p>  <strong>L2正则化的思想是对大数值的权重向量进行严厉的惩罚，从而倾向于权重向量更加分散，即使网络更倾向于使用所有的特征。</strong>实际操作是对网络中的每个权重w，向目标函数中增加一个<strong>1/2（λ*w^2)</strong>,λ是正则化强度，而乘上常数1/2是数学上的小技巧，即让求导后梯度变成λw，而非2λw。在梯度下降和参数更新的时候，使用L2正则化意味着所有的权重都以<strong>w += -lambda * W</strong>向着0线性下降。</p>
<p>2.L1正则化</p>
<p>  <strong>L1正则化则倾向于让神经元最后使用它们最重要输入数据的稀疏子集，可看做特征选择</strong>，它的实际操作是对每个w都像目标函数增加一个λ*|w|，这样的话，你可以知道求导的时候，附加项的导数就与w的符号有关，如果w为正，最优化更新后的w变小（相比与没有添加L1正则项时），如果为负则更新后的w变大，即尽可能使权重值为0。在w为0时，我们把取符号的sgn(w）看作是0，即sgn(0)=0,sgn(w&gt;0)=1,sgn(w&lt;0)=-1。</p>
<p>一般来说，实践更倾向于使用L2正则化，除非我们需要特征选择。</p>
<h3 id="随机失活"><a href="#随机失活" class="headerlink" title="随机失活"></a>随机失活</h3><p>  目前我们经常看到随机失活(dropout)的字眼，<strong>其与L1，L2正则化，以及最大范式约束的方法互为补充</strong>，实际操作过程中，随机失活即是让神经元以超参数p为概率被设置为0或者被激活,<strong>p一般设置为0.5</strong>，这样我们可以看做对完整的神经网络抽样出一些子集，每次基于输入数据只更新子网络的参数。</p>
<p><img src="\img\dropout.jpg" alt="dropout"></p>
<p>  但实际上我们更倾向于使用Inverted dropout，这是因为如果我们在训练网络时使用前向随机失活，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_step</span><span class="params">(X)</span>:</span></div><div class="line">  <span class="comment"># 3层neural network的前向传播</span></div><div class="line">  H1 = np.maximum(<span class="number">0</span>, np.dot(W1, X) + b1)</div><div class="line">  U1 = np.random.rand(*H1.shape) &lt; p <span class="comment"># 第一个随机失活遮罩</span></div><div class="line">  H1 *= U1 <span class="comment"># drop!</span></div><div class="line">  H2 = np.maximum(<span class="number">0</span>, np.dot(W2, H1) + b2)</div><div class="line">  U2 = np.random.rand(*H2.shape) &lt; p <span class="comment"># 第二个随机失活遮罩</span></div><div class="line">  H2 *= U2 <span class="comment"># drop!</span></div><div class="line">  out = np.dot(W3, H2) + b3</div></pre></td></tr></table></figure>
<p>  上面这段代码中有p的概率，神经元会被激活，而又1-p的概率神经元会被设置为0，然后流向下一层，那么我们可以知道在随机失活进行后，输出为px，而在我们的测试过程中并不存在随机失活层，所以神经元对输入都是可见的，那么为了保持同样的预期输出，我们必须在测试时把输出结果乘以p,来缩放激活函数输出结果，以防止测试输出数值范围大于训练输出，如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(X)</span>:</span></div><div class="line">  <span class="comment"># 前向传播时模型集成</span></div><div class="line">  H1 = np.maximum(<span class="number">0</span>, np.dot(W1, X) + b1) * p <span class="comment"># 注意：激活数据要乘以p</span></div><div class="line">  H2 = np.maximum(<span class="number">0</span>, np.dot(W2, H1) + b2) * p <span class="comment"># 注意：激活数据要乘以p</span></div><div class="line">  out = np.dot(W3, H2) + b3</div></pre></td></tr></table></figure>
<p>  这样的话测试时要多乘一次p显得非常麻烦，为了让我们的测试效率更高，各种深度学习框架中实践的其实是inverted dropout,有翻译为<strong>反向随机失活</strong>，个人觉得这个翻译不太好，<strong>其实它就是在训练阶段对激活函数输出值进行放大，即是放大1/p倍，而测试阶段则保持不变。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_step</span><span class="params">(X)</span>:</span></div><div class="line">  <span class="comment"># 3层neural network的前向传播</span></div><div class="line">  H1 = np.maximum(<span class="number">0</span>, np.dot(W1, X) + b1)</div><div class="line">  U1 = (np.random.rand(*H1.shape) &lt; p) / p <span class="comment"># 第一个随机失活遮罩. 注意/p!</span></div><div class="line">  H1 *= U1 <span class="comment"># drop!</span></div><div class="line">  H2 = np.maximum(<span class="number">0</span>, np.dot(W2, H1) + b2)</div><div class="line">  U2 = (np.random.rand(*H2.shape) &lt; p) / p <span class="comment"># 第二个随机失活遮罩. 注意/p!</span></div><div class="line">  H2 *= U2 <span class="comment"># drop!</span></div><div class="line">  out = np.dot(W3, H2) + b3</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(X)</span>:</span></div><div class="line">  <span class="comment"># 前向传播时模型集成</span></div><div class="line">  H1 = np.maximum(<span class="number">0</span>, np.dot(W1, X) + b1) <span class="comment"># 不用数值范围调整了</span></div><div class="line">  H2 = np.maximum(<span class="number">0</span>, np.dot(W2, H1) + b2)</div><div class="line">  out = np.dot(W3, H2) + b3</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  从上一篇博文，我们知道，神经网络其实就是一个一系列线性映射和非线性激活函数交织起来的评分函数，我们在输入层输入我们的数据，经过隐层的一系列点积和激活函数计算在输出层得到一个类型评分，然而要比较好地训练一个神经网络，我们需要更多的考虑，比如数据预处理，我们还需要考虑权重的
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Notes of Deep Learning:神经网络(1)</title>
    <link href="http://yoursite.com/2018/02/28/Notes-of-Deep-Learning-Neural-network-1/"/>
    <id>http://yoursite.com/2018/02/28/Notes-of-Deep-Learning-Neural-network-1/</id>
    <published>2018-02-28T07:17:09.000Z</published>
    <updated>2018-02-28T08:34:00.422Z</updated>
    
    <content type="html"><![CDATA[<h2 id="人工神经元"><a href="#人工神经元" class="headerlink" title="人工神经元"></a>人工神经元</h2><p>  其实神经元这个翻译有点唬人，有些学者也不喜欢借用某些生物词语来蹭热度，他们直接就把所谓的人工神经元称之为单元（unit），结合人工神经网络来看的话，你可以很容易的推测出，它是由这个所谓的人工神经元组成的。在一个人工神经网络中，神经元间会有一种单向的影响，因为人工神经网络可以看做是一张有向无环图。下图是一个常见的粗糙模型：</p>
<div align="center"><br><br><img width="600px" src="\img\QQ图片20180214181505.png"><br><br><img src="\img\QQ图片20180214180333.jpg"><br><br></div>

<p>从这张图中你可以看到，一个人工神经元有几个主要的部分，如果你把它看做是有向无环图里的一个节点，那么你可以观察到它的每一个入度，分别对应一个不同的输入和一个自身权重的乘积（w和x都是向量或者矩阵，这里准确来说应该是<strong>点积</strong>），所有入度的点积的累加加上节点对应的偏差值（偏置）(Σwixi+b）代入所入节点的激活函数，图中就是f，对应为f(Σwixi+b),然后这个输出结果（<strong>激活率</strong>）顺着节点的出度流入下一层网络中的神经元。</p>
<p>  现在你大概知道什么是所谓的人工神经元，如果硬要跟生物神经元扯上一毛钱关系的话，你学过高中生物，大概会知道突触，树突，突触小泡之类的，你也许能把这个和两个神经细胞里通过突触来传递兴奋的机制联系起来…然后对别人吹嘘一波，但是我是做不到的，可能是我不怎么了解生物吧。 </p>
<a id="more"></a>
<h2 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h2><p>  认识了人工神经元之后，我们就知道了这里面有一个叫做<strong>激活函数（activation function）</strong>的重要概念，激活函数的选择对最终训练出来的模型影响是很大的，如果你以前看过一些公众号中推送的文章，可能会经常看到Sigmoid和Tanh这样的字眼，这是都是激活函数的名称，但是你不要看着这些名字这么奇怪就觉得这个函数会不会很复杂啊，其实稍微用点脑子思考一下就知道激活函数不能是多么复杂的函数，因为我们最后需要通过反向传播这样的算法去计算梯度，从而进行参数调优，如果这个激活函数是非常复杂的，这个梯度就不太好算了，激活函数通常都是非线性函数，目的是为了模型有更强的表达能力，详情可以<a href="https://www.zhihu.com/question/22334626" target="_blank" rel="external">参考这里</a>，排名前几的答案基本上把这个问题讲清楚了。这里我记录3个激活函数：</p>
<h3 id="S型函数"><a href="#S型函数" class="headerlink" title="S型函数"></a>S型函数</h3><p>  S型函数就是Sigmoid，如果在你学高等数学或者微积分的时候，肯定是接触过这个函数的，这个函数由于它在平面直角坐标系上的曲线而得名。即：</p>
<blockquote>
<p>σ（x）=1/(1+e^(-x))</p>
</blockquote>
<p><img src="\img\QQ图片20180214194819.png" alt="QQ图片20180214194819"></p>
<h3 id="Tanh函数"><a href="#Tanh函数" class="headerlink" title="Tanh函数"></a>Tanh函数</h3><p>  Tanh函数是有S型函数转化过来的零中心函数，Tanh比S型函数更受欢迎，但是他们存在着饱和问题，即在接近极值的区间，梯度几乎为0，训练模型的时候使用反向传播算法，一个接近0的梯度反向传播下去，小数相乘会以指数形式收缩到0。</p>
<blockquote>
<p>tanh=2σ(2x)-1=2/(1+e^(-2x))-1</p>
</blockquote>
<p><img src="\img\QQ图片20180214195043.png" alt="QQ图片20180214195043"></p>
<h3 id="ReLU函数"><a href="#ReLU函数" class="headerlink" title="ReLU函数"></a>ReLU函数</h3><p>目前最流行的激活函数,非常简单粗暴有效,名字的由来是Rectified Linear Unit-&gt;ReLU</p>
<blockquote>
<p>ReLu(x)=max(0,x)</p>
</blockquote>
<p><img src="\img\QQ图片20180214200631.png" alt="QQ图片20180214200631"></p>
<h2 id="神经网络结构"><a href="#神经网络结构" class="headerlink" title="神经网络结构"></a>神经网络结构</h2><p>我们通过一个普通的神经网络来展开对它的层结构认知，比如下面这个两层的网络：</p>
<p><img src="\img\NN.jpg" alt="NN"></p>
<p>  一般来说输入层是不算做层数的，所以说这个网络是2层，即一个隐层和输出层，当然有些网络有很多隐层，我们在这个图片上看到的是一个有向无环图，但是经过前面的理解，你知道实际上它是一个做矩阵点积的数学函数。</p>
<p>  在这个普通的网络中，它的层都是<strong>全连接层</strong>，全连接层中的神经元与其前后两层的神经元是完全成对连接的，但是在同一个全连接层内的神经元之间没有连接。</p>
<p>  在神经网络中，输出层是没有激活函数的，因为它用来完成分类的打分。有时候我们要表示一个神经网络的尺寸，比如上面那个神经网络是怎么样的尺寸呢，它有着4（隐层）+2（输出层）=6个神经元，因为是全连接的，它有着3*4+4*2=20个权重，以及4+2=6个偏置，权重和偏置都是可学习的，那么我们训练这个神经网络的时候需要学习这个26个参数，以最优化算法求得他们的最优值。这样看起来似乎比较清晰了，但是一般的卷积神经网络有着10-20层，1亿个可学习参数，要求这个1一个参数的最优值可不是一个简单的工程，这也是为什么大部分做深度学习的同学都处在调参的路上的原因了。</p>
<p>  是不是层数越多的神经网络越好呢?视情况而定，一般的神经网络就是3层网络，再增加层数很难增强它的表达力度，而卷积神经网络则不同，因为要提取层次化特征，所以深度就是一个很重要的问题，一般都是数十层之多，谈到这个问题，我们又有新的问题，如何设置神经网络的层数和尺寸。我们知道神经网络其实是一个函数，如果在有着相同激活函数的情况下，整个函数更为复杂，则函数的表达能力就能更强，但是也会引起<strong>过拟合</strong>等问题，<strong>过拟合</strong>是指网络对数据中的噪点拟合过甚，导致整个模型的泛化能力不强。</p>
<p>  即便大的网络会有过拟合问题，我们还是会使用更大一点的网络作为模型，因为防止过拟合还有其他的方法，比如<strong>L2正则化或者dropout</strong>，特别是正则化。因此我们没有必要去牺牲整个网络模型的表达能力去换去泛化能力。另外小网络的极小值很容易收敛到，但是这些极值的损失值一般都很高，不利于我们构建一个优秀的模型，而大的网络极小值更多，虽然更不容易收敛，但是我们可以有更多的选择，从而得到一个更好的模型。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;人工神经元&quot;&gt;&lt;a href=&quot;#人工神经元&quot; class=&quot;headerlink&quot; title=&quot;人工神经元&quot;&gt;&lt;/a&gt;人工神经元&lt;/h2&gt;&lt;p&gt;  其实神经元这个翻译有点唬人，有些学者也不喜欢借用某些生物词语来蹭热度，他们直接就把所谓的人工神经元称之为单元（unit），结合人工神经网络来看的话，你可以很容易的推测出，它是由这个所谓的人工神经元组成的。在一个人工神经网络中，神经元间会有一种单向的影响，因为人工神经网络可以看做是一张有向无环图。下图是一个常见的粗糙模型：&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;img width=&quot;600px&quot; src=&quot;\img\QQ图片20180214181505.png&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;\img\QQ图片20180214180333.jpg&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;/div&gt;

&lt;p&gt;从这张图中你可以看到，一个人工神经元有几个主要的部分，如果你把它看做是有向无环图里的一个节点，那么你可以观察到它的每一个入度，分别对应一个不同的输入和一个自身权重的乘积（w和x都是向量或者矩阵，这里准确来说应该是&lt;strong&gt;点积&lt;/strong&gt;），所有入度的点积的累加加上节点对应的偏差值（偏置）(Σwixi+b）代入所入节点的激活函数，图中就是f，对应为f(Σwixi+b),然后这个输出结果（&lt;strong&gt;激活率&lt;/strong&gt;）顺着节点的出度流入下一层网络中的神经元。&lt;/p&gt;
&lt;p&gt;  现在你大概知道什么是所谓的人工神经元，如果硬要跟生物神经元扯上一毛钱关系的话，你学过高中生物，大概会知道突触，树突，突触小泡之类的，你也许能把这个和两个神经细胞里通过突触来传递兴奋的机制联系起来…然后对别人吹嘘一波，但是我是做不到的，可能是我不怎么了解生物吧。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Junit(4):Mock</title>
    <link href="http://yoursite.com/2018/02/01/Junit-4-Mock/"/>
    <id>http://yoursite.com/2018/02/01/Junit-4-Mock/</id>
    <published>2018-02-01T08:29:46.000Z</published>
    <updated>2018-02-01T15:39:50.653Z</updated>
    
    <content type="html"><![CDATA[<p>  就像上篇文章所说，我们还可以用mock方式模拟一个没有完成的模块，从而完成测试，事实上如果测试的业务比较繁琐，比如涉及到输入啥的，我们也可以mock一个假的输入对象，mock object是在极限编程里提出的，而今天它已经广泛用于软件测试领域。</p>
<p>  就如mock这个单词的词义一样，mock object即是一个模制的对象，但这个对象的行为是人为故意给定的，不包含实际的业务。这样说可能非常抽象，如果让我们考虑用<strong>Scala</strong>写一个在商店里用pos机刷卡的例子,比如我们刷卡并且输入密码后会构造出这样的一个CreditCard对象：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">CreditCard</span>(<span class="params">val cardId:<span class="type">String</span>,val password:<span class="type">String</span></span>)</span></div></pre></td></tr></table></figure>
<p> 而我们的Pos机要负责转账处理：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pos</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">transfer</span></span>(amount:<span class="type">Double</span>,creditCard: <span class="type">CreditCard</span>, creditCard2: <span class="type">CreditCard</span>, accountManager: <span class="type">AccountManager</span>): <span class="type">Unit</span> = &#123;</div><div class="line">    <span class="keyword">val</span> account1: <span class="type">Account</span> = accountManager.findAccount(creditCard.cardId, creditCard.password);</div><div class="line">    <span class="keyword">val</span> account2: <span class="type">Account</span> = accountManager.findAccount(creditCard2.cardId, creditCard2.password);</div><div class="line">    accountManager.saveAccount(account1.copy(account1.balance - amount,account1.creditCard))</div><div class="line">    accountManager.saveAccount(account2 copy(account2.balance + amount, account2.creditCard))</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>，但是问题是此时我们根本没有构造号银行卡账户数据库，甚至我们连dao对象都只是一个接口，那么为了测试Pos代码逻辑能不能正确执行我们该怎么办呢？</p>
<a id="more"></a>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">AccountManager</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">saveAccount</span></span>(account: <span class="type">Account</span>)</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">findAccount</span></span>(cardId: <span class="type">String</span>, password: <span class="type">String</span>): <span class="type">Account</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>答案是我么可以建立一个mock object，这不仅可以很容易的测试Pos的代码逻辑，而且节省了很大的开销，设想一下，如果真正的去测试，我们不仅要确定整个容器环境无误，还要不断地去访问数据库，这肯定是不可以忍受的。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MockAccountManager</span>(<span class="params"></span>) <span class="keyword">extends</span> <span class="title">AccountManager</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> accounMap = <span class="type">Map</span> (</div><div class="line">      (<span class="string">"1001"</span>, <span class="type">Account</span>(<span class="number">1000</span>, <span class="type">CreditCard</span>(<span class="string">"1001"</span>, <span class="string">"123"</span>)))</div><div class="line">      , (<span class="string">"1002"</span>, <span class="type">Account</span>(<span class="number">1000</span>, <span class="type">CreditCard</span>(<span class="string">"1002"</span>, <span class="string">"123"</span>)))</div><div class="line">      )</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">findAccount</span></span>(cardId: <span class="type">String</span>, password: <span class="type">String</span>): <span class="type">Account</span> = &#123;</div><div class="line">      <span class="keyword">val</span> x=accounMap(cardId)</div><div class="line">      x <span class="keyword">match</span> &#123;</div><div class="line">        <span class="keyword">case</span> <span class="type">Account</span>(_,password)=&gt;x</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">saveAccount</span></span>(account: <span class="type">Account</span>): <span class="type">Unit</span> = &#123;</div><div class="line">      accounMap = accounMap ++ <span class="type">Map</span> (</div><div class="line">        (account.creditCard.cardId, account)</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样我们就可以利用这个，简单的mock object去测试我们的Pos逻辑了：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">testTransfer</span></span>(): <span class="type">Unit</span> = &#123;</div><div class="line">  <span class="keyword">val</span> pos = <span class="keyword">new</span> <span class="type">Pos</span>();</div><div class="line">  <span class="keyword">val</span> card = <span class="keyword">new</span> <span class="type">CreditCard</span>(<span class="string">"1001"</span>, <span class="string">"123"</span>)</div><div class="line">  <span class="keyword">val</span> card2 = <span class="keyword">new</span> <span class="type">CreditCard</span>(<span class="string">"1002"</span>, <span class="string">"123"</span>)</div><div class="line">  <span class="keyword">val</span> acm = <span class="keyword">new</span> <span class="type">MockAccountManager</span>()</div><div class="line">  pos.transfer(<span class="number">100.2</span>, card, card2, acm)</div><div class="line">  assertEquals(acm.findAccount(card2.cardId, card2.password).balance,<span class="number">1100.2</span>d,<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  我在这里手动写了一个mock object仅仅是为了演示一下大概的思想，实际上我们不需要手动写mock object，有大量的框架帮助我们完成这一点，比如在jvm平台上就有Jmock，EasyMock,Mockito等等，它们借助jvm的反射机制，以代理模式动态的生成了一个新的对象，我们可以给定这个对象特定方法的特定输入输出，十分方便，比如对于猜数字游戏：</p>
<p>随机给定一个4位数字，且每一位的数字都不重复，然后玩家在不知道这个数字的情况下输入一个4位数字每一位都不重复，如果位置相同且数字也相同就得到一个A，如果数字存在但是位置不同就得到B。</p>
<p>如：</p>
<p>给定1234,玩家猜测为1256，则结果为2A0B</p>
<p>给定1234，玩家猜测为3412，则结果为0A4B</p>
<p>如果玩家在6次之内得到了4A0B结果，就输出玩家胜利。</p>
<p>这样的话，我们可以来写一个简单的程序：</p>
<p>首先我们需要输入和输出,以下两个类用来读取数字和输出一个字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//输入</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberReader</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        String inputNumber = scanner.next();</div><div class="line">        <span class="keyword">if</span> (StringUtils.isNumeric(inputNumber) &amp;&amp; inputNumber.length() == <span class="number">4</span>) &#123;</div><div class="line">            <span class="keyword">return</span> inputNumber;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Invalid Input"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//输出</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Printer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String message)</span> </span>&#123;</div><div class="line">        System.out.println(message);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们需要一个随机数字生成器,它可以随机生成一个4位不同数字组成的字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberGenerator</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generate</span><span class="params">()</span> </span>&#123;</div><div class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>);</div><div class="line">        Collections.shuffle(list);</div><div class="line">        <span class="keyword">return</span> String.join(<span class="string">""</span>, list.subList(<span class="number">0</span>, <span class="number">4</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们需要一种数字类,它有一个比较方法，输出xAxB这样的表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Number</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMBER_LENGTH = <span class="number">4</span>;</div><div class="line">    <span class="keyword">private</span> String value;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Number</span><span class="params">(String value)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">compare</span><span class="params">(String stringToCompare)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUMBER_LENGTH; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (value.charAt(i) == stringToCompare.charAt(i)) &#123;</div><div class="line">                a++;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value.contains(stringToCompare.substring(i, i + <span class="number">1</span>))) &#123;</div><div class="line">                b++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> a + <span class="string">"A"</span> + b + <span class="string">"B"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后我们把上面的组件组成一个游戏：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Game</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String WIN_CODE = <span class="string">"4A0B"</span>;</div><div class="line">    <span class="keyword">private</span> Printer printer;</div><div class="line">    <span class="keyword">private</span> Number generatedNumber;</div><div class="line">    <span class="keyword">private</span> NumberReader reader;</div><div class="line"></div><div class="line">    <span class="comment">//我们有6次机会</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> remainingGuessCount = <span class="number">6</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Game</span><span class="params">(NumberGenerator numberGenerator, Printer printer, NumberReader reader)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.printer = printer;</div><div class="line">        <span class="keyword">this</span>.reader = reader;</div><div class="line">        <span class="keyword">this</span>.generatedNumber = <span class="keyword">new</span> Number(numberGenerator.generate());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">        printer.print(<span class="string">"please input a 4 digit number:"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (remainingGuessCount &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">              <span class="comment">//比较数字输入和生成的随机数</span></div><div class="line">                String result = generatedNumber.compare(reader.read());</div><div class="line">                <span class="keyword">if</span> (WIN_CODE.equals(result)) &#123;</div><div class="line">                    printer.print(<span class="string">"you win"</span>);</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                printer.print(result);</div><div class="line">                <span class="keyword">this</span>.remainingGuessCount--;<span class="comment">//机会使用了一次，所以减少</span></div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                printer.print(e.getMessage());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        printer.print(<span class="string">"Game Over"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们有一个简单的游戏了，如果玩家6次内猜对了4A0B，那么就输出you win,否则输出Game Over。现在我们要对这个游戏进行测试，但是我们可能会遇到以下的问题：</p>
<p>1.我们需要自动测试，而不是每次都手动输入</p>
<p>这是一个问题，我们的输入类NumberReader，调用的是系统的System.in但是我们却要求自动化测试，而不是每次手动输入，既然如此，我们就需要一种mock object，以代理的手段自动返回我们想输入的数字，我们可以自己手写字段反射，覆盖掉输入流，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberReaderTest</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> NumberReader reader = <span class="keyword">new</span> NumberReader();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setInputStream</span><span class="params">(String input)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</div><div class="line">        Field scannerField = reader.getClass().getDeclaredField(<span class="string">"scanner"</span>);</div><div class="line">        scannerField.setAccessible(<span class="keyword">true</span>);</div><div class="line">        Scanner scannerWithMockedStream = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> ByteArrayInputStream(input.getBytes()));</div><div class="line">        scannerField.set(reader, scannerWithMockedStream);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldReadNumber</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        setInputStream(<span class="string">"1234"</span>);</div><div class="line">        assertEquals(<span class="string">"1234"</span>, reader.read());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span>(expected = Exception.class)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldThrowExceptionForNonNumberInput</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        setInputStream(<span class="string">"123d"</span>);</div><div class="line">        reader.read();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>手写是一种手段，我们可以理解框架大概是怎么做到的，当然其实可以用代理来做，现实情况中我们能够使用mock框架，这里我用的是<a href="https://github.com/mockito/mockito" target="_blank" rel="external">mockito</a>,当然你也可以用其他的框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.junit.Before;</div><div class="line"><span class="keyword">import</span> org.junit.Test;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.Mockito.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameTest</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> NumberGenerator numberGenerator;</div><div class="line">    <span class="keyword">private</span> NumberReader numberReader;</div><div class="line">    <span class="keyword">private</span> Printer printer;</div><div class="line">    <span class="keyword">private</span> Game game;</div><div class="line"></div><div class="line">    <span class="meta">@Before</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="comment">//我们以mock方式生成了:</span></div><div class="line">        numberGenerator = mock(NumberGenerator.class);</div><div class="line">        numberReader = mock(NumberReader.class);</div><div class="line">        printer = mock(Printer.class);</div><div class="line">      <span class="comment">//我们给定generate的返回值必须是4879，因为随机生成一个数字可就不好写expected值了</span></div><div class="line">        when(numberGenerator.generate()).thenReturn(<span class="string">"4879"</span>);</div><div class="line">        game = <span class="keyword">new</span> Game(numberGenerator, printer, numberReader);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们可以写一些简单测试，来体验一下mock的作用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldPrintYouWin</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    when(numberReader.read()).thenReturn(<span class="string">"4879"</span>);</div><div class="line">    game.start();</div><div class="line">  <span class="comment">//使用verify可以在白盒情况下审视代码逻辑是不是正常运转</span></div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"please input a 4 digit number:"</span>);</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"you win"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldPrintYouWinAfterFifthAttempts</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  <span class="comment">//mockito支持我们每次返回不同的值</span></div><div class="line">    when(numberReader.read()).thenReturn(<span class="string">"7849"</span>,<span class="string">"7849"</span>,<span class="string">"7849"</span>,<span class="string">"7849"</span>,<span class="string">"7849"</span>,<span class="string">"4879"</span>);</div><div class="line">    game.start();</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"please input a 4 digit number:"</span>);</div><div class="line">    verify(printer, times(<span class="number">5</span>)).print(<span class="string">"2A2B"</span>);</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"you win"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldPrintYouWinAfterSecondAttempts</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    when(numberReader.read()).thenReturn(<span class="string">"7849"</span>,<span class="string">"4879"</span>);</div><div class="line">    game.start();</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"please input a 4 digit number:"</span>);</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"2A2B"</span>);</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"you win"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldPrintGameOver</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    when(numberReader.read()).thenReturn(<span class="string">"7849"</span>);</div><div class="line">    game.start();</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"please input a 4 digit number:"</span>);</div><div class="line">    verify(printer, times(<span class="number">6</span>)).print(<span class="string">"2A2B"</span>);</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"Game Over"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldRunNormallyAfterThrowsException</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  <span class="comment">//我们还可以设定抛出异常</span></div><div class="line">    when(numberReader.read()).thenThrow(<span class="keyword">new</span> IOException(<span class="string">"IO Exception Test"</span>))</div><div class="line">            .thenReturn(<span class="string">"7849"</span>,<span class="string">"7849"</span>,<span class="string">"7849"</span>,<span class="string">"7849"</span>,<span class="string">"7849"</span>,<span class="string">"4879"</span>);</div><div class="line">    game.start();</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"please input a 4 digit number:"</span>);</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"IO Exception Test"</span>);</div><div class="line">    verify(printer, times(<span class="number">5</span>)).print(<span class="string">"2A2B"</span>);</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"you win"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然上面这些简单的mock，我们也可以手动给它以代理方式写出来，有利于我们理解mockito这类框架的实际工作方式，感兴趣的朋友可以写写看，我这里就不写了~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  就像上篇文章所说，我们还可以用mock方式模拟一个没有完成的模块，从而完成测试，事实上如果测试的业务比较繁琐，比如涉及到输入啥的，我们也可以mock一个假的输入对象，mock object是在极限编程里提出的，而今天它已经广泛用于软件测试领域。&lt;/p&gt;
&lt;p&gt;  就如mock这个单词的词义一样，mock object即是一个模制的对象，但这个对象的行为是人为故意给定的，不包含实际的业务。这样说可能非常抽象，如果让我们考虑用&lt;strong&gt;Scala&lt;/strong&gt;写一个在商店里用pos机刷卡的例子,比如我们刷卡并且输入密码后会构造出这样的一个CreditCard对象：&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CreditCard&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;val cardId:&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;,val password:&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; 而我们的Pos机要负责转账处理：&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Pos&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;transfer&lt;/span&gt;&lt;/span&gt;(amount:&lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;,creditCard: &lt;span class=&quot;type&quot;&gt;CreditCard&lt;/span&gt;, creditCard2: &lt;span class=&quot;type&quot;&gt;CreditCard&lt;/span&gt;, accountManager: &lt;span class=&quot;type&quot;&gt;AccountManager&lt;/span&gt;): &lt;span class=&quot;type&quot;&gt;Unit&lt;/span&gt; = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; account1: &lt;span class=&quot;type&quot;&gt;Account&lt;/span&gt; = accountManager.findAccount(creditCard.cardId, creditCard.password);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; account2: &lt;span class=&quot;type&quot;&gt;Account&lt;/span&gt; = accountManager.findAccount(creditCard2.cardId, creditCard2.password);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    accountManager.saveAccount(account1.copy(account1.balance - amount,account1.creditCard))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    accountManager.saveAccount(account2 copy(account2.balance + amount, account2.creditCard))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;，但是问题是此时我们根本没有构造号银行卡账户数据库，甚至我们连dao对象都只是一个接口，那么为了测试Pos代码逻辑能不能正确执行我们该怎么办呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="软件测试" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
      <category term="TDD" scheme="http://yoursite.com/tags/TDD/"/>
    
      <category term="Junit" scheme="http://yoursite.com/tags/Junit/"/>
    
  </entry>
  
  <entry>
    <title>Junit(3):桩测试</title>
    <link href="http://yoursite.com/2018/01/29/Junit-3-Build-a-stub/"/>
    <id>http://yoursite.com/2018/01/29/Junit-3-Build-a-stub/</id>
    <published>2018-01-29T14:45:51.000Z</published>
    <updated>2018-01-30T15:40:10.139Z</updated>
    
    <content type="html"><![CDATA[<p>  如果我们只是单纯测试一个类里的公共方法，那么使用简单的断言，就能满足我们的需求，可是我们的<strong>测试很多时候要依赖其他的类，或者说环境</strong>，比如你测试的方法可能要访问一些服务器获取资源，或者访问数据库获取数据，此时我们必须需要一个真实的环境么？实际上很多情况下，你根本拿不到真实的环境，比如你测试的是一个还没有完成的服务模块。既然有这种需求，我们就得想办法在开发环境中模拟一个模块来测试，这有两种策略，一种就是stub，还一种就是mock，<strong>这两种方法都是为了代替依赖部分，不同的是mock是构建一个假的对象，而stub是真实地简单实现一个对象</strong>，这一节我先讲这个stub，我们将以stub的方式，模拟一个对一个服务器发送http请求测试。</p>
<a id="more"></a>
<p>  stub是一段代码，常在运行期间代替真实的代码，它的目的在于模拟一个简单的行为，因为真实的代码可能过于复杂，或者根本不可得，使用stub技术就可以允许独立的测试真实代码中的一部分行为，<strong>其实你可以把stub代码理解为是对真实代码一部分行为的简单实现</strong>。</p>
<p>  有时候stub代码很难写，因为他可能要再现真实代码的复杂逻辑，你知道有的系统中即使是以小块功能逻辑也是非常复杂的，所以一般情况下stub只适合代码中的粗粒度部分的测试，以stub代码来代替成熟的外部系统，比如服务器的连接或者数据库。</p>
<p>比如我们要测试下面这个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> xin.saul;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.InputStream;</div><div class="line"><span class="keyword">import</span> java.net.HttpURLConnection;</div><div class="line"><span class="keyword">import</span> java.net.URL;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClient</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">(URL url)</span> </span>&#123;</div><div class="line">        StringBuffer content = <span class="keyword">new</span> StringBuffer();</div><div class="line">        HttpURLConnection connection = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            InputStream stream = url.openStream();</div><div class="line">            <span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2049</span>];</div><div class="line">            <span class="keyword">int</span> len;</div><div class="line">            <span class="keyword">while</span> ((len = stream.read(bs)) != -<span class="number">1</span>) &#123;</div><div class="line">                content.append(<span class="keyword">new</span> String(bs, <span class="number">0</span>, len));</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> content.toString();</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假如这个Myclient就是我们所构造应用的客户端，它可以通过url获取一个web资源，我们应该如何去测试它呢？这里会出现几种情况，一种就是我们的服务器已经构建完毕了，那么我们可以直接去测试它，但是很多时候我们的客户端开发完成后，我们的服务器并没有开发完成，那么我们测试前必须去先架构一个apache或者tomcat服务器么？答案肯定是否定的，apache和tomcat启动速度并不是很快，我们有一些代替方案，比如我们以Jetty来写一段stub代码，以模拟我们的客户端和服务器交互过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> xin.saul;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.eclipse.jetty.server.Handler;</div><div class="line"><span class="keyword">import</span> org.eclipse.jetty.server.Request;</div><div class="line"><span class="keyword">import</span> org.eclipse.jetty.server.Server;</div><div class="line"><span class="keyword">import</span> org.junit.Assert;</div><div class="line"><span class="keyword">import</span> org.junit.BeforeClass;</div><div class="line"><span class="keyword">import</span> org.junit.Test;</div><div class="line"></div><div class="line"><span class="keyword">import</span> javax.servlet.ServletException;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.PrintWriter;</div><div class="line"><span class="keyword">import</span> java.net.MalformedURLException;</div><div class="line"><span class="keyword">import</span> java.net.URL;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientTest</span></span>&#123;</div><div class="line">    <span class="meta">@BeforeClass</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initClass</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Server server = <span class="keyword">new</span> Server(<span class="number">8080</span>);</div><div class="line">        MyClientTest test = <span class="keyword">new</span> MyClientTest();</div><div class="line">        server.setHandler(test.new SayHelloHandler());</div><div class="line">        server.setStopAtShutdown(<span class="keyword">true</span>);</div><div class="line">        server.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClient</span><span class="params">()</span> <span class="keyword">throws</span> MalformedURLException </span>&#123;</div><div class="line">        MyClient client = <span class="keyword">new</span> MyClient();</div><div class="line">        String content = client.getContent(<span class="keyword">new</span> URL(<span class="string">"http://127.0.0.1:8080"</span>));</div><div class="line">        Assert.assertEquals(<span class="string">"Server response"</span>,content);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SayHelloHandler</span> <span class="keyword">implements</span> <span class="title">Handler</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</div><div class="line">            response.setContentType(<span class="string">"text/plain; charset=utf-8"</span>);</div><div class="line">            response.setStatus(HttpServletResponse.SC_OK);</div><div class="line">            PrintWriter writer = response.getWriter();</div><div class="line">            writer.append(<span class="string">"Server response"</span>);</div><div class="line">            writer.close();</div><div class="line">        &#125;</div><div class="line">      <span class="comment">//注：此处省略了其他的方法重新，直接是ide自动生成的重写，我本人并没有改动</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  可以看到stub代码其实就是很傻乎乎的直接实现一个小模块小功能，当然这里是基于servlet服务,这里我以嵌入式服务器jetty来实现了这段stub，原因是它启动的很快，代码很简单。这里提一点，<strong>我们知道对于单元测试来说每个测试的不相干性是必要的，你不能因为上一个测试的执行而改变了服务器某些状态，于是我们希望没执行一个新的测试都能够拥有一个干净的环境</strong>，这也是诸如@Before这样的注解会做的，但是在打桩测试中你会发现一个jetty嵌入式服务器的启动时间可能是0.5秒，如果你要执行很多个stub测试，那就很有意思了，我不觉得你想在按下测试按钮以后在屏幕前等待十几分钟甚至几十分钟，然后发现某个地方测试没通过，重构之后又等一遍，于是我们可以尝试使用@BeforeClass注解，它只会执行一次，当然<strong>你得保证我们的服务器执行的具体逻辑和测试的执行顺序无关，测试之间不会相互影响</strong>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  如果我们只是单纯测试一个类里的公共方法，那么使用简单的断言，就能满足我们的需求，可是我们的&lt;strong&gt;测试很多时候要依赖其他的类，或者说环境&lt;/strong&gt;，比如你测试的方法可能要访问一些服务器获取资源，或者访问数据库获取数据，此时我们必须需要一个真实的环境么？实际上很多情况下，你根本拿不到真实的环境，比如你测试的是一个还没有完成的服务模块。既然有这种需求，我们就得想办法在开发环境中模拟一个模块来测试，这有两种策略，一种就是stub，还一种就是mock，&lt;strong&gt;这两种方法都是为了代替依赖部分，不同的是mock是构建一个假的对象，而stub是真实地简单实现一个对象&lt;/strong&gt;，这一节我先讲这个stub，我们将以stub的方式，模拟一个对一个服务器发送http请求测试。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="软件测试" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
      <category term="TDD" scheme="http://yoursite.com/tags/TDD/"/>
    
      <category term="Junit" scheme="http://yoursite.com/tags/Junit/"/>
    
  </entry>
  
  <entry>
    <title>Touch ThoughtWorks,Be a ThoughtWorker</title>
    <link href="http://yoursite.com/2018/01/22/Touch-ThoughtWorks-Be-a-ThoughtWorker/"/>
    <id>http://yoursite.com/2018/01/22/Touch-ThoughtWorks-Be-a-ThoughtWorker/</id>
    <published>2018-01-22T09:25:36.000Z</published>
    <updated>2018-01-24T14:55:45.724Z</updated>
    
    <content type="html"><![CDATA[<p>  写下第一句话的时候，发现这好像是2018年第一篇博文，正好此文献给我的公司和即将共事的同事。</p>
<a id="more"></a>
<p>  对于同一期的小伙伴，思特沃克安排了一个文化培训，介绍思特沃克是一家怎么样的公司，而介绍是从同事的视角出发，由前辈自己讲述，领略他们与思特沃克的故事。在github上看到其他办公室的小伙伴好像把这个文化培训叫做思沃大讲堂。由于我个人原因不能去到现场，但是公司很贴心的为不能去到现场的同学准备了远程会议，这点是很值得称赞的。</p>
<p>  对于思特沃克，一定要介绍的肯定就是敏捷开发了，由于我本人是软件工程专业，这个词已经无限次的出现在我的各种书本上，但是事实上，我个人真的没有认认真真用过书上提到的各种开发模式，我相信也是大多数普通学生和我一样所做的都是非商业的练手软件，一般都是“佛性开发”。思特沃克肯定是敏捷方法论用的最出色的企业之一，所以在文化培训的第一天的有两节课讲的是敏捷开发，于我而言可以验证课本和工业界实际的应用有何异同。思特沃克的敏捷开发是有着自己的一套实践的，其的典型的敏捷开发团队角色一般有PM,BA,TL（Tech Lead）,QA,DEV以及UX。思特沃克对于敏捷的实践其实是融入了其骨髓之中，因为公司并不只是在开发时强调敏捷开发，而是整个公司的运作都是这种风格，比如公司很强调协作，回顾反馈，互动交流，甚至在我参加的这个文化培训的课程设置中也看的出来，培训的每一天最后都是一个回顾反馈环节。对于思特沃克有三大支柱，即1.可持续的商业（即首先要养活几千号人),2.卓越的技术(即有技术追求),3.拥护社会和经济正义(这个理由就很多了)。</p>
<div align="center"><br><img width="60%" src="\img\QQ图片20180122200726.jpg"><br><img width="60%" src="\img\mmexport1516621501982.jpg"><br></div><br>  上面第一张图里的小纸片是做回顾会议得出的一些反馈，后面这个板子普通版（叫普通板是因为它很普通，还有海星板等等），上面贴的纸张是回顾会议得到的一些结论，第一栏是well，代表了这次所要回顾的事件做的比较好的地方，第二栏是less well则表示了成员们觉得不太好的地方，可以看到less well还是挺多的，最后一个是puzzle，即不能确定的事情。如果把一个回顾会议开成表彰大会或者批斗大会就没什么意义了，所以在开回顾会议之前会有一个安全系数打分环节，这个打分环节的意义在于：如果小组成员觉得会议中有些人的存在将会影响自己的发言，就可以给一个低分，当组里的平均分低于某个数值的时候，“某些人”就需要被请出会议。这个环节大概意思我知道，但是实际上它是怎么确定哪些人是构成威胁的人，说实话我也不太清楚，因为我是远程参会，而且这次会议的打分并没有出现低于安全阈值的情况。右下角的action（补充完成后即图2），是这次回顾会议的产出物，这个产生出物应该是很明确的指明某个人应该以某个目标为改进的，这里的某个人指的是这个action的owner，你可以看到有些action右边是带名字的，团队在未来会跟踪这些action有没有实际的落实。个人觉得如果回顾会议以及根据action自我改进能够全部在理想情况下全部达到的话，团队的这种成长肯定是无法估量的，但是显然不存在这种理想状态，就像社会主义大概永远都是初级阶段一样，只求能达到社会主义初级阶段7%~12%的增长点也是很不错了。<br><br>  作为一个敏捷入了骨髓的公司，除了快速反馈之外，追求高效的协作也在这次文化培训中体现，主要的方式是通过几个游戏，当然对于一家软件公司，肯定要结合一些软件开发的形式在里面。其中一个游戏是以乐高积木来制造一个动物，以小组为单位，一共会有3轮需求，每轮需要完成一定量，积木材料并不是无限的，而不同轮的需求有可能是冲突的，这很像软件开发，人手有限而需求功能点却不断的变化。由于我是远程视频会议观战的，所以实际操作的小伙伴具体有什么感受我也不得而知了。<br><div align="center"><br><img width="60%" src="\img\mmexport1516621767905.jpg"><br><img width="60%" src="\img\mmexport1516621527004.jpg"><br><img width="60%" src="\img\mmexport1516621518022.jpg"><br><img width="60%" src="\img\mmexport1516621522872.jpg"><br><img width="60%" src="\img\mmexport1516621772621.jpg"><br><img width="60%" src="\img\mmexport1516621469111.jpg"><br><img width="60%" src="\img\mmexport1516621533091.jpg"><br></div><br>  在文化培训中还引入了测试驱动开发和重构的一些概念，当然这里需要完成两个小作业，分别是以mockito补充一个已经写好的小工程的部分单元测试，以及以TDD方式完成一个小工程，这个小工程必须是用git下小步提交的，以至于让检查的前辈知道你用的真的是TDD方式开发，为此写一个小程序我提交了39次。其实我并不很了解软件测试的，软件测试这门课应该是我在学校所有专业课里得分最低的，这源于当时我对软件测试的错误看法，思特沃克对代码质量非常看重，我估摸着也许我应该从新学一遍软件测试这本书。<br><div align="center"><br><img width="60%" src="\img\mmexport1516621460440.jpg"><br></div><br>  在思特沃克工作应该要有快速的学习能力，因为很可能你需要随时切换一种新的编程语言技术栈工作，像python,ruby，C#，Kotlin之类的国内还是用的很多的，有时候你可能要用诸如Sheme,Clojure，Scala这样的语言真刀真枪的实干，注意我这里说的是随时切换，也就是说可能你这个星期还在用java写着代码，下个星期你就要出差到另一个地方，比如深圳，北京，美国，印度，欧洲，用另一种编程语言写代码，当然对于用什么编程语言并不是什么大的问题，因为套路基本上是一样的。思特沃克需要员工能快速的适应新环境，最好能够用英语流利的交流，还希望你能够展现自己，在本次文化培训中也可以看出这一点，比如有个课程主题是演讲，鼓励大家作为一个主角来分享自己的知识和经验。另外由于思特沃克不是996上班，有大把的时间给职工自己把握，对于一个在大学和研究生生活中已经学会了自我驱动的人来说，无疑是一个喜讯，你可以学学诸如日语这样的编程以外的东西，对于那些本身并非计算机专业的应届同事，将有足够的时间去学习诸如编译原理，离散数学之类的重要的稍底层点的知识，你也可以参与很多社区活动，也可以加入公司的兴趣小组参与一些开源项目。当然，理想状态下时间的利用都是非常有价值的，高回报的，实际上可能因人而异，像我这种自我驱动能力比较弱的人，我指望能有30%就满足了。总的来说，思特沃克会给你机会去行万里路，在工作之外会给你时间去读万卷书，能不能利用好就是自己的事情了。<br><div align="center"><br><img width="60%" src="\img\mmexport1516706539552.jpg"><br><img width="60%" src="\img\mmexport1516621606612.jpg"><br><img width="100%" src="\img\mmexport1516621613035.jpg"><br></div>

<p>  好吧，最后祝我早日见到我的可爱的同事们吧，其实还有同一期的两个可爱的女同事也是远程的，没有在这张合照里，当然我也没有在这张合照里，但是为了让同一期同事都出现在一张照片里，我还是以一张我唯一的随意的截图p了一下，变成了下面这张照片。</p>
<p><img src="\img\QQ图片20180123202709_conew1.png" alt="QQ图片20180123202709_conew1"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  写下第一句话的时候，发现这好像是2018年第一篇博文，正好此文献给我的公司和即将共事的同事。&lt;/p&gt;
    
    </summary>
    
    
      <category term="闲谈" scheme="http://yoursite.com/tags/%E9%97%B2%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>冯诺依曼：《数学家》（下）</title>
    <link href="http://yoursite.com/2017/12/20/Von-Neumann-The-Mathematician-part-2/"/>
    <id>http://yoursite.com/2017/12/20/Von-Neumann-The-Mathematician-part-2/</id>
    <published>2017-12-20T08:09:29.000Z</published>
    <updated>2017-12-20T13:20:26.855Z</updated>
    
    <content type="html"><![CDATA[<p><em>本文作者是冯诺依曼，英文名为《The Mathematician》，该文章在1947年发表在《Works of the Mind》上，后来也记录在《von Neumann’s Collected Works》中，这篇文章是我听讲座时偶然得知的，于是看了一下后翻译了出来，才疏学浅，只源于爱好，如有不对多多包涵——2017.12.20</em>  </p>
<p>本文接<a href="http://saul.xin/2017/12/13/Von-Neumann-The-Mathematician-part-1/#more" target="_blank" rel="external">上一部分</a></p>
<a id="more"></a>
<p>  然而，我不想进一步讨论这个问题，我将转向一个完全清晰的案例，即“数学基础”的讨论。在19世纪末和20世纪初，抽象数学的一个新分支——<strong>康托尔</strong>的集合论陷入了困境，某些理论导致了矛盾的结果，虽然这些推论不是集合论的核心”有用“的部分，而且很容易被某些正式标准识别，不过这些都不足以去阐明为什么这些理论的意义要低于集合论的“成功”部分。除了事后洞察到这些理论导致了灾难，但这说不清是什么样的先验动机，以及这种情况下的一致性理论，会允许人们把这些理论与想保留他们的集合论的那部分中分离开来。一个由<strong>罗素和外尔</strong>主导，后由<strong>布劳威尔</strong>总结的详细研究表明，不仅仅是集合论，而是大多数现代数学理论都反感“普遍有效”和“存在”的概念。<strong>布劳威尔</strong>发展了一个没有这些不受欢迎的特点的，被称为“直觉主义”的数学系统，在这个系统中上文提到的集合论困境和矛盾不复存在。然而，现代数学的半壁江山，在其不容置疑的最重要的部分，尤其是在分析方面，也受到这此“净化”的影响：它们要么变得无效，要么在证明时伴随次要的考虑非常复杂。在后一个过程中，会使理论明显丧失有效的普遍性和证明的优雅。然而，<strong>布劳威尔和外尔</strong>依然认为有必要根据这些观点修改数学严谨的概念。</p>
<p>  很难估量这些事件的重要性。在20世纪20年代，两个对数学有着深刻认识的顶级数学家，他们都提出了构成确切证明的数学严谨是概念应该被改变。随后的事态发展同样值得注意。</p>
<p>  1.只有少部分数学家愿意在日常使用中接受这种新的，迫切被采用的标准。很多人承认<strong>外尔</strong>和<strong>布劳威尔</strong>的理论咋看是正确的，但是他们自己却继续违背，用旧的，容易的方式来配合自己的数学工作。也许他们自己也希望有人能够在某个时间找到一个答案去应答这些直觉的批评，从而在事后证明这些理论的正确性。</p>
<p>  2.<strong>希尔伯特</strong>提出了以下巧妙的观点来证明“古典”数学的正当性：即使在直觉系统中也可能给出古典数学如何运作的严谨描述，即人们可以描述古典系统是如何工作的，虽然他们不能证明这种运作。因此，也许可以直观地证明，古典过程永远不会导致矛盾（相互冲突）。很明显这样一个证明是很难，不过有某些迹象表明它们是如何尝试的。一旦该方案有效，它将提供一个古典数学以与其相反的直觉系统为基础的最好的理由！至少，在大多数数学家愿意接受的数学哲学体系中，这种解释是合法的。</p>
<p>  3.在经历了十年的不断的尝试后，<strong>哥德尔</strong>得到了最好的结果。该结果三言两语无法完全准确地表述，而且该说明过于技术性，以至于无法在此表述。然而，它的本质含义是：如果一个数学系统没有导致矛盾，那么这个事实就不能用该系统的程序来证明。（哥德尔不完备定理）哥德尔的证明满足了数学严谨性的最严格标准–直观标准。这个结论对<strong>希尔伯特</strong>的计划影响存在争议（理由之与这篇文章显得太过技术性，我们不在此展开讨论）。我的个人和大多数人认同的观点相同，哥德尔已经证明希尔伯特的计划已经破灭。</p>
<p>  4.古典数学证明的主要希望已经消失（希尔伯特，或者布劳威尔和外尔那种意义上的），虽然人民再也无法确定古典数学的可靠性，但大多数数学家还是决定使用该体系，毕竟，古典数学产出的结果即优雅又有用，且至少建立在一个健全的基础上，就好像电子客观存在那样可靠。因此一个人愿意接受科学，就可以接受经典数学体系。即便直觉体系的一些原始参与者，也转而开始接受这种观点。目前，关于“基础”的争论还没有结束，但是除开少数人，摒弃古典体系变得不太可能。</p>
<p>  我如此详细的讲述了关于这场论战的故事，因为我认为它是不要把数学的严谨性的不可变性看得太过理所当然的最好的警示。这件事发生在我们的有生之年，我知道这段时间中我对于绝对数学真理的认知的改变，让我频繁地丢脸，我也知道他们是怎么样连续地改变了三次。</p>
<p>  我希望以上三个例子充分的说明了我的论文观点的一半，即最卓越数学灵感来自于经验，第二点是很难相信世上存在一个绝对的，不变的数学严谨性概念，且它完全和人类经验没有联系。在这个问题上，我试着抱着及其庸俗的态度。在这方面，无论人们在哲学或认识论上有什么偏好，数学家们的主体的实际经验几乎不支持存在一个先验的数学严谨概念的假设。然而，我的论文还有第二部分，现在我将转到这一部分。</p>
<p>  任何数学家都难以相信数学是一种纯经验主义科学或所有的数学观点源自于经验主义科学。让我们思考一下这句话的第二部分。现代数学的各个重要组成部分其经验性来源往往是不可追溯的。即使可以追溯也要回溯到很久以前，这些观点明显从它斩断经验性源头以来已经经历了完全的蜕变.几何符号是为了国内的数学用途而发明的，不过可能有理由断言它有很强的经验性瓜葛。然而，现代，“抽象”几何越来越多地往弱经验关联方向上发展，拓扑学也与其一样。在所有的这些领域中，数学家对于成功的主观标准和他们努力的价值体现，都是非常独立，优雅且自由（几乎自由）的经验性联系（我在后面会详细的讲）。在集合论中这一点一直很明显。无限集的“幂”和“序”的概念可能是有限集的数值概念的推广，不过在无限集形式中（特别是“幂”）他们几乎和真实世界没有关系。要不是我想避免技术性讨论，我可以用几个集合论的例子来描述这一点，这些例子诸如选择公理问题，无穷幂的可比性，连续性问题，等等。这同样适用于实函数理论和实点集理论。用微分几何和群论分别给出了两个奇怪的例子：它们被认为是抽象的、不实用的学科，而且几乎总是在这种态度中培养出来的.前者下经历了十年，后者经历了一个世纪，它们才在物理学中变得非常有用。并且它们仍然主要以指示性的、抽象的、不实用的态度来进行。</p>
<p>  所有这些条件及其各种组合的例子可以被成倍增加。但是，我更倾向于转到上面提到的第一点：数学是一门经验性科学吗？或者，更清晰的说：数学实际上是以经验科学的方式实践的吗？或者，更宽泛的说：数学家同他们学科的最基本关系是什么？他的成功的标准是什么，可取吗？怎么样的影响和考虑控制并引导着他的工作？</p>
<p>​    让我们来看看，在哪些方面数学家的日常工作方式和自然科学家的方式不同。一方面，在它们之间存在着区别，另一方面，随着数学不断发展，从理论学科向经验学科，再从经验学科向描述性学科的转变，这种区显著增大。因此，让我们把数学和最接近于它的范畴——理论学科，作一下比较。接着我们选出所有理论学科中最接近于数学的那个学科（如果我无法控制数学家的狂妄，而且说道：因为它是所有学科中最理论科学中发达的，请你不要对于批评的太过严厉）。这个学科就是理论物理学，数学和理论物理实际上有很多共同点。正如我前面指出的，欧几里德几何系统是经典力学公理化表述的原型，类似还支配着唯象热力学以及麦克斯韦电动力学系统的某些阶段以及狭义相对论。而且，理论物理学的作派是不解释现象，只做分类和关联，这种作派已经被当今大多数物理学家接受。这就意味着这种理论的成功标准仅仅是：能不能用一种简洁优美的分类关联方案，在使方案看起来不复杂混淆的情况下，覆盖大多数现象，无论在方案被演进时是否覆盖了没有被考虑或甚至不知道的现象（后两种说法当然表现了一种理论的统一性和预测力）。如前所述，现在，这种标准，明显在很大程度上具有美学性质。正因为如此，它非常接近于数学的成功标准，正如你所看到的，这些标准几乎完全是符合美学的。因此，我们现在把数学与最接近它的经验科学——理论物理学，进行比较，正如我希望我所展示的那样，它与数学有许多共同之处。然而，实际方法程序（modus procedendi）上的差异依然巨大且根本。理论物理学的目标主要是由“外部”给出，在大多数情况服从实验物理学的需要。它们几乎总是源于解决困难的需要。预先和统一的成就通常在随后出现。我们可以做一个比喻，进步（预测和统一）在工作从诞生，但在此之前必须与一些预先存在的困难作斗争（通常是现有体系中存在的明显矛盾）。有一部分物理学家的工作是寻找预示着“突破”的可能性的障碍。就如我所说，这些障碍通常源自于实验，不过有时候他们是各种被接受的理论主体中一些部分的矛盾。例子有很多。</p>
<p>  <strong>迈克尔逊</strong>的实验引出了狭义相对论，某些电离势和某些光谱结构的困难导致量子力学即使第一种情况的典型；狭义相对论和牛顿引力理论导致广义相对论之间的冲突就是第二种更罕见的情况的典型。至少，理论物理学中的问题都是客观给出；而且，正如我前面所说，指导成功开发的标准，主要是美学，而且该问题的一部分，即我上面提到的开创性的“突破”，是有力的客观事实。因此，理论物理学的学科几乎任何时候都是非常集中的，几乎所有时候，所有理论物理学家的大部分工作都集中在不超过一两个非常高度受限的领域–比如1920年代和1930年代早期的量子理论和1930年代中期以来的原子核的基本粒子和结构。</p>
<p>  对于数学来说，情况完全不同。数学被分为了大量子领域，他们彼此在特性，风格，目标和影响上广泛不同。这显得它和理论物理学极度的集中正好相反。一个好的理论物理学家可能今天仍然掌握这它的学科的一半以上的工作知识。我能不确定任何的现存的数学家都与超过四分之一的学科知识有大量关联。客观的说，一个重要的问题一般会出现在一个数学的子领域已经有了深远的发展且在某个难点上严重停滞之后。不过即便如此，数学家基本上可以自由的选择尝试解决它或者放弃转而去做其他的领域，一个理论物理学上的重要问题一般是一个必须解决的冲突或者矛盾。数学家有着很多领域可以转而从事，而且他在从事的这些领域上享有非常大自由。但是要说决定性的一点：我认为可以确切的说美学是他们选择的标准，同时也是成功的标准。我知道此断言是有争议的，在没有大量具体的技术案例分析的情况下，它不能够被“证明”，或者说真正的详细地去证实。所以我们就此打住吧，不然这会带来不适合于现在这篇文章场合下的高技术性讨论。只要知道美学特征甚至比在我上面提到的理论物理学的例子中更显著就够了。人们希望数学定理或者数学理论不仅可以以一种简单而优雅的方式描述和分类，而且要有很多先验的不同的特例，并且还希望“优雅”能融于它的“建筑”结构组成中。陈述这个问题的时候很容易，最大的难点在于在握住它，在每一次处理它的尝试中，获得一些惊喜的扭转，使得是在这次处理过程或部分处理过程中变得简单。当然，如果结论复杂而冗长，就应该引入一些简单的基本原则，这些原则能阐述那些绕脑的难题，将一些貌似的随意性转变为一些简单的指导动机。在一些潜在经验主义的世俗主题存在的背景之下，这些准则显然是创造性艺术标准。很多时候是一种非常久远的背景，随着美学的野蛮发展产生了大量的错综复杂的类型，这些类型都更贴近于纯粹和简单的艺术风格而不是经验科学氛围。</p>
<p>  你会注意到，我甚至没有提到数学与经验或描述性科学的比较。这里的方法的差异和总体氛围太明显。</p>
<p>  我认为虽然数学科学的谱系冗长而清晰，但数学观点源自于经验主义是比较近似于事实的（这个事实情况太复杂了，以至于只能说是近似于）。不过，一旦这些数学观点被构想出来，该主题就开始经历自己独特的存在方式，这种存在方式更近似与一个完全由美学动机驱动的创造性学科，而不是其他的学科，尤其不可能是经验科学学科。然而，我认为，还有一点需要强调。如果一门数学学科与它的经验性来源相距甚远，更甚如果只是在它的第二，三代间接地受到来自“现实”的思想的启发，那么它就面临巨大的危险。它变得越来越纯粹地美学化，越来越纯粹地艺术化（ I’art pour I’art）。如果该领域被相关主题包围，而这些学科仍然有着更紧密的经验联系，或者这个学科在有着特殊超前的鉴赏力的人的影响之下，这不一定是坏的。不过有一种情况很危险，就是这个学科独立的顺着最小阻力的路线发展，这个远离学科源头的流派，将会分成很多不重要的分支，以至于把这个学科弄成一大堆复杂的杂乱无章的细节。换句话说，在与它的经验性来源有着很大的距离或者在过多“抽象”的综错后，数学学科处于退化的危险之中。一开始这种风格很传统，当他显示出奇怪的迹象时，危险的信号就出现了。很容易给出一些例子，来探索导致风格变得奇怪或者非常奇怪的特定变化，但这又是太过技术了，我们不在这讨论。</p>
<p>  无论如何，一旦发展到这种情况，在我看来，唯一的解决办法是恢复到原点：重新注入或多或少直接的经验思想。我相信，这是一个保护该学科的新颖与活力的必要条件，该方法在未来同样适用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;本文作者是冯诺依曼，英文名为《The Mathematician》，该文章在1947年发表在《Works of the Mind》上，后来也记录在《von Neumann’s Collected Works》中，这篇文章是我听讲座时偶然得知的，于是看了一下后翻译了出来，才疏学浅，只源于爱好，如有不对多多包涵——2017.12.20&lt;/em&gt;  &lt;/p&gt;
&lt;p&gt;本文接&lt;a href=&quot;http://saul.xin/2017/12/13/Von-Neumann-The-Mathematician-part-1/#more&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;上一部分&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="译文" scheme="http://yoursite.com/tags/%E8%AF%91%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>JVM(5):字节码执行引擎</title>
    <link href="http://yoursite.com/2017/12/14/JVM-5-Execution-engine-of-bytecode/"/>
    <id>http://yoursite.com/2017/12/14/JVM-5-Execution-engine-of-bytecode/</id>
    <published>2017-12-14T05:41:54.000Z</published>
    <updated>2017-12-15T16:12:00.831Z</updated>
    
    <content type="html"><![CDATA[<p>  经历过类加载以后，类文件结构就以JVM定义的形式存储在JVM的方法区中。但是程序如何执行的描述存储在我们前面介绍的方法表的Code属性中的字节码指令，字节码执行引擎，即是执行那些直接码指令，以至于让程序“跑”起来。字节码执行引擎相当于JVM的“处理器”。</p>
<p>  实际上JVM规范只定义了字节码执行引擎的概念模型，具体的实现可能是解释执行也可能是编译执行，或者混合起来。但是从外面看，所有的字节码执行引擎输入都是字节码文件，处理后输出的都是执行结果。</p>
<h2 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><p>  JVM的直接码指令是基于栈操作的，我们也知道在JVM的内存结构里，线程私有的3种内存，即虚拟机栈，本地方法栈，和程序计数器。Hotspot中没有本地方法栈和虚拟机栈的区别，在JVM里，这两种栈中的元素都被称之为<strong>栈帧</strong>。栈帧是VM进行方法调用和方法执行的数据结构，它存储了方法的<strong>局部变量表，操作数栈，动态链接和方法返回地址和一些附加信息</strong>。</p>
<a id="more"></a>
<p>  我们之前介绍过方法表的Code属性，你知道它是干嘛的，现在我要说的是，栈帧就是来源于Code属性，我们在这里再看一遍Code属性的具体结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">Code_attribute &#123;</div><div class="line">    u2 attribute_name_index;//固定指向值为Code的一个CONSTANT_Utf8_info</div><div class="line">    u4 attribute_length;</div><div class="line">    /*info部分*/</div><div class="line">    u2 max_stack;//操作数栈的最大深度</div><div class="line">    u2 max_locals;//局部变量表的存储空间，单位Slot(4个字节)</div><div class="line">    /*代码部分*/</div><div class="line">    u4 code_length;</div><div class="line">    u1 code[code_length];</div><div class="line">    /*显示异常处理表部分*/</div><div class="line">    u2 exception_table_length;</div><div class="line">    exception_info exception_table[exception_table_length];</div><div class="line">    /*属性表部分*/</div><div class="line">    u2 attributes_count;</div><div class="line">    attribute_info attributes[attributes_count];</div><div class="line">&#125;</div><div class="line"></div><div class="line">exception_info&#123;</div><div class="line">	u2 start_pc;</div><div class="line">	u2 end_pc;</div><div class="line">	u2 handler_pc;</div><div class="line">	u2 catch_type;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  仔细一看你可以发现Code属性中，把属于它的操作数栈的一些信息都给定死了，实际上却是如此，这些已经定下来的信息会映射到该方法在VM栈中对应的栈帧中。一个栈帧要分配多少内存，仅取决虚拟机的实现，因为运行期的变量所需的具体内存啥的，Code属性已经给你确定好了。</p>
<p>  你已经知道VM栈是一种<strong>线程私有</strong>的内存结构，每个线程一个，而当前线程执行的方法是由它的VM栈的栈顶元素决定的，栈顶元素又称为<strong>当前方法</strong>。执行引擎运行的所有字节码指令都是针对该线程的VM栈栈顶元素进行操作，准确来说是根据那个栈帧的<strong>局部变量表，操作数栈，动态链接和方法返回地址和一些附加信息</strong>进行操作。所以我们迫切需要知道五种数据结构是什么，介绍完之后我们才能来解释一个方法的调用过程。</p>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>  局部变量表和操作数栈其实我们在介绍Code的属性表里的StackMapTable属性时有过一些接触。另外Code属性中的max_locals字段限制的就是局部变量表的最大容量。</p>
<p>  局部变量表的最小容量单位也是Slot，我们在前面的文章中介绍过它，一个Slot一般是32位（这与虚拟机，操作系统有关）,既然是最小单位，那么像boolean，short这种定义上是低于32位的类型，其实在局部变量表中也是按一个Slot来分配的，64位的数据则以连续的两个Slot来表示。</p>
<p>  在介绍<strong>类加载</strong>的时候我们提到了<strong>准备阶段</strong>，这个阶段即是按类型对类变量赋默认值，相信如果你看了我的前一篇文章，应该还记得这一点，准备阶段的存在可以让类变量在没有赋值的情况下有一个默认值，但是方法中的局部变量可没有准备阶段这种东西。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">		<span class="keyword">int</span> m;</div><div class="line">		System.out.println(m);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>  现在我们知道在哪里存储我们的局部变量了，如果你写过一个逆波兰式的计算程序，那你肯定会接触到基于栈的一个计算方式，或许你当时并没有想太多，但是现在我可以告诉你<strong>操作数栈</strong>这个东西就和你当时做的那个小程序里的栈意义上是一样的，只不过我们我们的运算符已经是jvm直接码指令罢了，”基于栈的执行引擎”的名字由来就是操作数栈。</p>
<p>  操作数栈的单位容量也是32位的，如果一个数据类型是64位的那么就栈两个单位容量，这个我在介绍StackMapTable属性时也提到过，操作数栈的最大深度由Code属性中的max_stacks数据项给定。</p>
<p>  在周志明的书中提到过一个<strong>VM栈帧（是虚拟机栈，不是操作数栈，注意）共享的概念</strong>，就是在概念上完全独立的两个方法的VM栈帧，实际实现时，可能会出现前面一个栈帧的局部变量表与后面一个栈帧的操作数栈共用一部分内存区域的情况，这种情况发生在方法调用变量的传递时。</p>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>  栈帧中存在一个指向运行池常量池的该栈帧所属方法的引用 ，这个引用的目的是为了支持<strong>动态链接</strong>。这个我们在类加载的解析阶段提到过，类的解析过程中并非所有的对类文件常量池的符号引用都转化为了直接引用，还有一部分是在运 行时转化，即<strong>动态链接</strong>。</p>
<h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>  在方法中调用另一个方法，被调用的方法无论是异常退出还是正常的完成都会涉及到一个返回之后，调用者方法从哪里继续的问题，如果是异常退出，则VM可以通过异常处理表来确定执行下一条指令的位置，如果是正常退出则就需要<strong>方法返回地址</strong>这个东西了，它主要是保存了调用时的线程的PC计数器的值。</p>
<p>  方法退出时当前帧出栈，然后恢复上层方法的局部变量表和操作数栈，有返回值的话还要把这个返回值压入操作数栈（如果是前面提到的<strong>VM栈帧共享</strong>，也可能不是这样做），然后要把PC计数器按照方法返回地址调整。</p>
<h3 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h3><p>  当然以上是JVM规范中强制要求的几个数据结构，有可能JVM自己需要添加一些信息，用于调试之类的操作，这类信息通通成为附加信息。</p>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>  <strong>方法调用阶段的唯一目的是确定被调用方法的版本。</strong></p>
<p>  在讨论<strong>类文件结构</strong>的时候你就已经知道，在Class文件中方法是以符号引用方式存在的，在类加载的解析过程中，一部分符号引用转化为了直接引用，但是还有一部分动态链接的方法只有等到运行时才能确定直接引用。为了在这些情况都能使得方法成功正确的调用，就有了这个<strong>方法调用</strong>阶段。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>  在类加载的解析阶段，能确定下来“编译期可知，运行期不可变”这个要求的方法，主要包括<strong>静态方法</strong>和<strong>私有方法</strong>两大类。聪明的人稍微想一下就知道了，静态方法是不可以重写的，而私有方法只能在内部访问，所以这两种方法根本不需要考虑会有什么动态变化之类的事情发生，对这两种方法的“版本”只有一种可能，在类编译期就可以确定，在解析阶段直接由符号引用变成直接引用。解析是一个静态过程。</p>
<h3 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h3><p>  首先我要说解析和分派并不是互斥的两个过程，然后我们讨论分派过程，<strong>这个过程涉及到重载和重写在jvm中的实现，总的来说这个过程就是在进一步确定具体要调用那个方法</strong>，我们首先来看看jvm中的方法调用指令。</p>
<p>  虚拟机调用方法的字节码有5条：</p>
<ol>
<li>invokestatic：调用静态方法</li>
<li>invokespecial:调用实例构造器&lt;init&gt;,私有和父类方法。</li>
<li>invokevirtual：调用<strong>虚方法</strong></li>
<li>invokeinterface：调用接口方法，运行期确定一个接口的实现对象</li>
<li><p>invokedynamic：在运行期对调用点限定符动态解析，然后执行该方法，该指令的<strong>分派逻辑</strong>由用户设定的引导方法决定。</p>
<p>上面提到了两个说法：分派逻辑和虚方法，我们先来解释一下虚方法。</p>
<p>invokestatic和invokespecial这两个指令调用的方法，都是在类解析阶段就可以确定其版本。除了上面说明的方法以外，final修饰的方法也是可以唯一确定的，稍微思考一下就知道。这些方法都称之为<strong>非虚方法</strong>，进行指令调用时你不需要考虑多态选择，一个方法不是<strong>非虚的</strong>就是<strong>虚方法</strong>。</p>
</li>
</ol>
<p>分派，分派可以是<strong>静态的也可以是动态的</strong>。</p>
<h4 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h4><p>静态分派是指依赖<strong>静态类型</strong> 来定位目标方法的分派动作。</p>
<p>静态类型的概念我们可以用一句代码来解释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Car car=<span class="keyword">new</span> Benz();</div></pre></td></tr></table></figure>
<p>上面的这句代码中Car就是静态类型，也称之为<strong>外观类型</strong>，外观类型这个词语可能更能让你有一个理解。而Benz则是<strong>实际类型</strong>。</p>
<p>那么什么是依赖静态类型来定位目标方法呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blue</span> </span>&#123;</div><div class="line">		  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startUp</span><span class="params">(Car car)</span></span>&#123;</div><div class="line">		    System.out.println(<span class="string">"You startup a car"</span>);</div><div class="line">		  &#125;</div><div class="line"></div><div class="line">		  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startUp</span><span class="params">(Benz benz)</span></span>&#123;</div><div class="line">		    System.out.println(<span class="string">"You startup a benz"</span>);</div><div class="line">		  &#125;</div><div class="line">		  </div><div class="line">		  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">		      Car benz=<span class="keyword">new</span> Benz();</div><div class="line">		      startUp(benz);</div><div class="line">		  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Benz</span> <span class="keyword">extends</span> <span class="title">Car</span></span>&#123;&#125;;</div></pre></td></tr></table></figure>
<p>对于上面的代码我们输出了”You startup a car”，即它是按照静态类型Car来确定该调用哪个方法的，所以这就是<strong>静态分派</strong>。</p>
<p>静态类型是编译器可知的，在编译期间编译器就会根据静态类型来决定使用哪个重载版本，如果你学过C++的话，那么那本基础书上应该非常明白的翻来覆去的讲过“运行期多态”和“编译期多态”。</p>
<p>  实际上不同的jvm上语言对静态分派的态度也不同，有时候，特别是用了…符号的变长参数的时候，有可能会产生多个分派结果都符合要求的情况，javac往往会用自己定义的规则来选择一个分派，然而scalac就直接报错了，会提示一个不允许混淆的错误，实际上javac的做法我个人认为有时会让编程者感到很疑惑。</p>
<h4 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h4><p>  动态分派涉及到重写，这个应该是常见面试题了，我们这里就不列出代码了。</p>
<p>  动态分派根据实际类型来确定方法，现在我要说明的就是具体的执行过程。首先我们先来认识一下jvm中的多态查找，该过程实际上就是invokevirtual指令的执行过程，也是java语言中重写的本质：</p>
<ol>
<li>首先找到操作数栈栈顶元素所指向对象的<strong>实际类型</strong> ：C。</li>
<li>如果在C中找到与常量中的<strong>描述符和简单名称</strong> 都相同的方法，就验证访问权限，如果通过就返回该方法的直接引用，不通过者抛出java.lang.IllegalAccessError异常</li>
<li>否则递归的寻找父类中的对应方法，如果递归到最后的Object还没有找到就抛出java.lang.AbstractMethodError异常。</li>
</ol>
<h4 id="单分派与多分派"><a href="#单分派与多分派" class="headerlink" title="单分派与多分派"></a>单分派与多分派</h4><p>  我们把目标方法的所有者类型，称之为方法的<strong>接收者</strong>。</p>
<p>  接受者和方法的参数统称为方法的宗量。多分派和单分派的区别就在于是不是方法选择是否是根据多个总量而定的，若不是则为单分派。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Benz</span> <span class="keyword">extends</span> <span class="title">Car</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Car car)</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"hello,Benz"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Benz benz)</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"hi,benz"</span>);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Car car=<span class="keyword">new</span> Benz();</div><div class="line">		car.sayHello(car);</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>  比如对于这样的一段代码，在静态分派时，编译器根据静态类型和方法参数确定了方法为Car.sayHello(Car);。并生成了相应的invokevirtual指令，这里就是属于多分派。</p>
<p>  在程序实际执行过程中，编译器已经决定了方法必须是sayHello(Car),在invokevirtual执行时，jvm只判断方法的实际接收者类型是Benz还是Car，这就是一个典型的单分派过程。</p>
<p>  到java1.8为止，java依然是动态单分派语言。</p>
<h4 id="分派的实现"><a href="#分派的实现" class="headerlink" title="分派的实现"></a>分派的实现</h4><p>  仔细考虑一下就能想到，用一个遍历元数据的方法去实现对方法版本的查找肯定不是一个商业虚拟机的实现方式。为了使性能更加优越，虚拟机常用手段是以建立虚方法表的方式来加快搜索。虚方法表一般是存储在方法区中，每个表对应一个类，里面存储了各个方法的实际入口地址，如果一个子类没有重写父类的方法，那么它的虚方法表中的地址就是父类方法表中的那个对应方法的地址，且在父子类虚方法表中相同签名的方法有同样的索引号。（回忆一下的话，class文件中是不会包含未重写的父类方法的，虚方法表和class文件的存储method_info的数据区不同）</p>
<p>  虚方法表在类加载的准备阶段（类变量默认值赋值完成后）初始化。</p>
<p>  虚方法表只是一种优化方式，商用虚拟机为了保证最高的效率肯定做了其他优化。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  经历过类加载以后，类文件结构就以JVM定义的形式存储在JVM的方法区中。但是程序如何执行的描述存储在我们前面介绍的方法表的Code属性中的字节码指令，字节码执行引擎，即是执行那些直接码指令，以至于让程序“跑”起来。字节码执行引擎相当于JVM的“处理器”。&lt;/p&gt;
&lt;p&gt;  实际上JVM规范只定义了字节码执行引擎的概念模型，具体的实现可能是解释执行也可能是编译执行，或者混合起来。但是从外面看，所有的字节码执行引擎输入都是字节码文件，处理后输出的都是执行结果。&lt;/p&gt;
&lt;h2 id=&quot;运行时栈帧结构&quot;&gt;&lt;a href=&quot;#运行时栈帧结构&quot; class=&quot;headerlink&quot; title=&quot;运行时栈帧结构&quot;&gt;&lt;/a&gt;运行时栈帧结构&lt;/h2&gt;&lt;p&gt;  JVM的直接码指令是基于栈操作的，我们也知道在JVM的内存结构里，线程私有的3种内存，即虚拟机栈，本地方法栈，和程序计数器。Hotspot中没有本地方法栈和虚拟机栈的区别，在JVM里，这两种栈中的元素都被称之为&lt;strong&gt;栈帧&lt;/strong&gt;。栈帧是VM进行方法调用和方法执行的数据结构，它存储了方法的&lt;strong&gt;局部变量表，操作数栈，动态链接和方法返回地址和一些附加信息&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>冯诺依曼：《数学家》（上）</title>
    <link href="http://yoursite.com/2017/12/13/Von-Neumann-The-Mathematician-part-1/"/>
    <id>http://yoursite.com/2017/12/13/Von-Neumann-The-Mathematician-part-1/</id>
    <published>2017-12-13T10:56:43.000Z</published>
    <updated>2017-12-13T15:11:17.132Z</updated>
    
    <content type="html"><![CDATA[<p><em>本文作者是冯诺依曼，英文名为《The Mathematician》，该文章在1947年发表在《Works of the Mind》上，后来也记录在《von Neumann’s Collected Works》中，这篇文章是我听讲座时偶然得知的，于是看了一下后翻译了出来，才疏学浅，只源于爱好，如有不对多多包涵——2017.12.13</em>  </p>
<a id="more"></a>
<p>  对于脑力工作的本质的论述在任何领域都是一项艰巨的任务，即使是在数学这样一个接近于人类智慧共同努力的中心地带的领域一样如此。无论如何，对于知识成果的本质的论述都是困难的，远远难于对特定领域的知识的运用。比如理解飞机的结构，以及它的升力和推力理论，比纯粹地去驾驶和乘坐，即便是比之控制航向，前者都要难的多。庆幸的是，一个人在通过直觉和经验深刻理解一个流程之前，就应当能够在没有事先很熟悉运转和使用的情况下，获得对这个流程的理解。</p>
<p>  因此，除了本身设定就是简单或者日常的领域，对所有知识成果的论述都是困难的，在数学中，如果讨论停留在非数学层次上，这种限制就变得非常严重,然后讨论将必然表现出一些非常坏的特征；指出这是永远不能正确证明，然后某种完全肤浅的讨论变得不可避免。</p>
<p>  我很清楚在我将要说的这些话中存在的缺陷，所以我提前道歉。此外，我要表达的观点可能并不是很多其他数学家完全同意的，你会得到一个人不太系统化的印象和解释，而我只能给你一点帮助，来裁决他们到底有多中肯。</p>
<p>  尽管存在一些障碍，然而，我必须承认尝试向你解释数学研究的本质是一件有趣而又富有挑战性的任务。我只希望这件事情上我不会太失败。</p>
<p>  在我看来，数学最本质的特点是，它与自然科学有着非常特殊的关系，更普遍地说，应该是任何阐释实践高于纯粹描述的科学。</p>
<p>  很多人，包括数学家，会同意数学不是一门以观察或实验为依据的科学（经验科学），至少在实践上，它的决定性层面和很多经验科学不同。当然，它的发展和很多自然科学有着紧密联系。它的一个主要分支——几何学，实际上是起源于自然科学，或者说经验科学。现代数学中一些最精妙的灵感（我相信是最精妙的）源于自然科学。数学中的一些方法遍及和支配着自然科学的“理论性”分支。在现代经验科学中，这些方法已成为越来越重要的成功标准，无论它们变得接近数学方法还是近似数学的物理方法。 事实上，在整个自然科学中，一连串连续不断的学科交叉现象已经变得越来越明显，所有这些学科交叉现象都与数学沾点边，且几乎与科学进步的理念一致。生物学日益弥漫着化学和物理，化学串着实验和理论物理，物理学中又串着非常数学形式化的理论物理学。 </p>
<p>  数学本质上有一种非常特别的两面性，一个人必须认识到这种两面性，然后接受它，并将它融入到他对这个问题的思考中去。数学本身就是两面的，我不相信能够在不牺牲本质的情况下做出简化的，统一的观点。</p>
<p>  因此，我将不会呈现给你一个统一的版本。我将尽可能地用多种现象去描述数学。</p>
<p>  不可否认的是，数学（我们能想到的纯粹数学中）中的一些最优秀的灵感源于自然科学。我们将提到两个最重要的事实。</p>
<p>  第一个例子，显然应该是几何。几何是古代数学的重要部分。它的几个分支，至今仍是现代数学的几个主要分支之一。毫无疑问，它起源于古代，是经验性的，今天的它开始成为一门学科，就像理论物理学那样。除开所有其他的证据，单单是“几何”这个名字也指明的这一点。欧几里得的公设法（postulational treatment）是远离经验主义的一大步。但捍卫这一立场并不简单，这是具备决定性的，也是最后一步，这伴随着与经验主义完全分离。欧几里得的公理化在少数地方不符合现代公理的严谨性要求，但是在该方面显得不那么重要。更关键的是：其他的无疑是经验性的学科，如力学和热力学，通常表现为或多或少的公设，在一些作者的表现方法很难与欧几里得的那种过程区分开来。我们这个时代的理论物理学的经典——牛顿定理，在它的文学形式和一些最关键部分的核心上，很像欧几里得的手法。当然，在所有这些例子中，在所呈现的假设的背后，都能通过物理洞察力来证实假设，通过实验验证来证明定理，在几何学获得至今数千年的稳定性和现代的理论物理学体系明显缺失的那种权威性之前，有人可能会认为类似欧几里得这种说法是可以接受的，尤其那种古代的观点。</p>
<p>  进一步来说，从欧几里得时代开始几何学的去经验主义逐步发展，但它没有变得更加完备，直到现代依然如此。关于非欧几里得几何学的讨论正好说明了这一点，它也说明了数学思想的矛盾性。讨论早已集中在一个高度抽象层面上，它处理的是一个纯粹的逻辑问题，即欧几里得的“第五公设”能不能由其他公设的引出。形式冲突被<strong>克莱因</strong>的纯数学范例所终结，这个范例展示了欧几里得平面可以利用重新定义的某些基本概念在非欧几里得理论中构建出来。然而经验主义阴霾从始至终都存在。在所有的欧几里得公设中，第五个受到了质疑的原因很明显只能来自于整个无限平面概念的这种非经验主义特点。最伟大数学家<strong>高斯</strong>的脑海里肯定存在着这个至少有重要意义的观点，尽管所有决定性的数学逻辑分析表明欧几里得几何学可能必须是经验主义的。在<strong>波尔约，罗巴切夫斯基，黎曼，克莱因</strong>取得更多的抽象结论之后，今天我们考虑原争论的结论，经验主义，更确切的说是物理学，依然有着最终的话语权。广义相对论的提出，迫使我们在新的设定下重新审视我们的几何学观点，它也带来了纯粹数学重点的全新的分配。最后我们来做一个完全的对比，最后这次发展发生在同一代人中，这一代人目睹了在现代公理逻辑数学家手中，欧几里得公理化方法的完全去经验化和去抽象化。，这两种矛盾的态度在一个数学家的脑中很好的相容了；可以看出，希尔伯特在公理化和广义相对论中都做出了巨大的共享。</p>
<p>  第二例子是微积分，可以说所有的解析，都是由它产生。微积分是现代数学的第一个成就，它的重要性大到难以估计，我认为它比任何其他东西都更明确的定义现代数学的开端，它的逻辑推导铸就了数学分析系统，现仍然是精确思想中最伟大的技术进步。</p>
<p>  微积分的显然起源于经验主义，开普勒首次正式尝试就是定义被称为“dolichometry”的方法，即对带有曲面的物体进行体积测量的方法。这是几何，但不是欧几里得几何，在那个时代，它是非公理化的经验主义几何。关于这点，开普勒非常清楚。牛顿和莱布尼茨的主要成果和发现，都明确的源自于物理。牛顿发明了“流数法”微积分，本质上是为了力学目的。实际上对于微积分和力学，这两个学科或多或少的一起发展，微积分的第一个公式在数学上是不严谨的。在牛顿之后的150年里这样一个不严谨的半物理公式是唯一的可选项。与这个不严谨，数学发展也不充分的时代背景相反，在这期间，解析学发生了很多重大的突破。这个时代的一些主要的数学思想肯定是不严谨的，比如<strong>欧拉</strong>；当然另外一些人，总体上是严谨的，比如<strong>高斯</strong>或者<strong>雅可比</strong>。虽然没有数学家会忽略那个时代（那个时代的数学获得了空前的发展），但是这一发展过程既混乱又模糊，它与经验主义的关系显然不是根据我们当前(或欧几里得的)抽象和严谨的思想而定的。甚至是在<strong>柯西</strong>重新从根本上确立统治地位之后，一个非常特殊的从新回归半物理方法的倒退却随着黎曼而生，黎曼的学术个性本身就是数学双重本质的一个最具说明性的例子，正如<strong>黎曼和魏尔斯特拉斯</strong>的论战，我们就此打住吧，如果我再深入研究下去的话就是技术细节了。从魏尔斯特拉斯开始，分析看起来变得完全抽象，严谨且不再经验性。即便不是绝对正确。关于数理和逻辑“基础”的论战，发生在过去的两代人里，消除了很多关于真相的错误观念。</p>
<p>  这给我带来了第三个例子，这个例子和判断有关，它所涉及的是数学与哲学或者认知论的关系，而非数学与自然科学的关系。这个例子以一种非常新颖的方式说明了“完全”的数学严谨性的绝对观念并非是不可变的。严谨这一概念的多变性表明除了数学抽象以外的一些东西必定参与到了数学的构成中。在分析关于“基础”的论战中，我无法说服自己接受必须迎合其他因素的经验性质的结论。虽然至少在某些阶段的讨论中，赞成这些解释的理由是非常有力的。但我不认为它是完全让人信服的。然而，有两件事是清楚地。首先，一些非数学的东西，某种程度上与经验性科学或哲学联系在一起，或者两者兼而有之，确实从本质上进入了，他们的非经验特征能够维持下去，取决于一个人是否认为哲学（或者认识论）可以独立的存在（这种假设是必要的，但是不够充分）。第二，一些例子强力支持着数学的经验性起源，比如我们上面提到的两种例子（集合和微积分），这与“基础”论战的最佳解释是什么无关。</p>
<p>  在分析数学严谨性概念的易变性时，我想强调上文所提到的“基础”论战，然而，我会先简要地细想一下这个问题的次要方面，这个方面加强了我的论点，但是我认为它的次要的，因为比之“基础”论战的分析，它可能不那么确切。我指的是数学“风格”的变化。众所周知，数学证明的写作风格已经经历了相当大的波动。这里讨论波动而不是某种趋势是因为在某些方面上十八、十九世纪的某些作者和现在之间的风格差异比现在和欧几里得时代更大。但是，在其他方面却具有非常显著的稳定性。在存在差异的领域中，主要差异是存在于表现上，这些差异可以再不引入任何新思想的情况下消除。然而，在很多情况下这些差异大到让人怀疑在不需要考虑他们是否真的对数学的严谨性有同样的想法，仅仅通过不同的风格，品味和教育水平，就可以把不同方式展现它们的作者给区分开来。结果，在极端情况下（例如，在上面提到的，18世纪晚期的分析工作），差异无法避免，即便可以补救，也要在全新而重要的理论的帮助下才行得通，而这些理论的发展需要数百年。一些在那种于今天而言是不严谨的方式（当时有一些同僚批评）下工作的数学家已经很清楚的意识到他们自身的工作方式缺乏严谨性。更客观的说，他们自身渴望数学处理方法应该和我们今天的观点一样，而不是只拘于他们手头上做的那种。不过那个时代的一些大师，比如欧拉，显得对于那种方法十分信任且对他们自己的标准很满意。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;本文作者是冯诺依曼，英文名为《The Mathematician》，该文章在1947年发表在《Works of the Mind》上，后来也记录在《von Neumann’s Collected Works》中，这篇文章是我听讲座时偶然得知的，于是看了一下后翻译了出来，才疏学浅，只源于爱好，如有不对多多包涵——2017.12.13&lt;/em&gt;  &lt;/p&gt;
    
    </summary>
    
    
      <category term="译文" scheme="http://yoursite.com/tags/%E8%AF%91%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>ES6(2):Destructuring assignment</title>
    <link href="http://yoursite.com/2017/12/08/ES6-2-Destructuring-assignment/"/>
    <id>http://yoursite.com/2017/12/08/ES6-2-Destructuring-assignment/</id>
    <published>2017-12-08T15:57:12.000Z</published>
    <updated>2017-12-09T07:13:28.857Z</updated>
    
    <content type="html"><![CDATA[<p>  本世纪以来的很多新语言都提供了各种赋值或者模式匹配判断的语法糖，es6也提供了对解构赋值的一系列支持使得我们可以在很多情况下节省很多行代码。但是对一个复杂模式的解构赋值很可能让维护代码的人员感到很疑惑，所以这里记录的解构赋值没有那么多奇技淫巧。</p>
<a id="more"></a>
<h2 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h2><p>我们在es6中，可以向scala中操作元组和集合那样，用模式匹配的方式来对数组进行解构赋值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> [a, [b, c], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</div><div class="line">    alert(c);<span class="comment">//输出3</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> [a, b] = [, <span class="number">2</span>];</div><div class="line">    alert(a);<span class="comment">//a没有匹配项，解构不成功，输出undefined</span></div><div class="line">    alert(b);<span class="comment">//输出2</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> [a, b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">    alert(b);<span class="comment">//输出2</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">    <span class="comment">// 我们可以用...来表示一个多值匹配</span></div><div class="line">    <span class="keyword">let</span> [a, [...b], c] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>];</div><div class="line">    alert(b);<span class="comment">//输出2,3,4</span></div><div class="line">    alert(c);<span class="comment">//输出5</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line">    alert(b);<span class="comment">//输出2,3,4</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="提供默认值的解构"><a href="#提供默认值的解构" class="headerlink" title="提供默认值的解构"></a>提供默认值的解构</h3><p>我们可以为解构需要的变量赋默认值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> [a, b = <span class="number">4</span>] = [<span class="number">1</span>];</div><div class="line">    alert(b);<span class="comment">//输出4</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> [a, b = <span class="number">4</span>] = [<span class="number">1</span>, <span class="literal">undefined</span>];<span class="comment">//不严格等于undefined，所以赋默认值</span></div><div class="line">    <span class="keyword">let</span> [c,d=<span class="number">4</span>]=[<span class="number">1</span>,<span class="literal">null</span>];</div><div class="line">    alert(b);<span class="comment">//输出4</span></div><div class="line">    alert(d);<span class="comment">//输出null</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> [a, b = a] = [<span class="number">1</span>];<span class="comment">//你甚至可以这样</span></div><div class="line">    alert(b);<span class="comment">//输出1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h3><p>es6中也有惰性求值这种东西的存在，比如如果结构中默认值是一个表达式那么，默认值其实是惰性求值的，即如果结构成功这个表达式根本不执行<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">lazy</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(<span class="string">"execute lazy"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="string">"abc"</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> [m = lazy(), k] = [<span class="number">1</span>, <span class="number">2</span>];<span class="comment">//不出现弹窗</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="数组结构与可遍历性"><a href="#数组结构与可遍历性" class="headerlink" title="数组结构与可遍历性"></a>数组结构与可遍历性</h3><p>数组解构赋值的进行实际上是利用了右边集合的可遍历性，如果右边的集合不具有可遍历性则直接报错<br>相反的，如果右边的集合是一个可遍历的结构，当然就是可以解构的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> [k] = <span class="literal">NaN</span>;<span class="comment">//Uncaught TypeError: NaN is not iterable</span></div><div class="line">    <span class="comment">// let [k]=1;</span></div><div class="line">    <span class="comment">// let [k]=&#123;&#125;;</span></div><div class="line">    <span class="comment">// let [k]=null;</span></div><div class="line">    <span class="comment">// let [k]=false;</span></div><div class="line">    <span class="comment">// let [k]=undefined;</span></div><div class="line">  <span class="comment">//全部报类似错误</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><p>对象也可以使用解构方式来赋值，不过对象不再要求右边的值是一个可遍历的解构了<br>这种方式类似于scala中的函数传参<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> &#123;tom, jack&#125; = &#123;<span class="attr">jack</span>: <span class="string">"jack"</span>, <span class="attr">tom</span>: <span class="string">"tom"</span>&#125;;</div><div class="line">    <span class="comment">//相当于 let &#123;tom:tom, jack:jack&#125; = &#123;jack: "jack", tom: "tom"&#125;;</span></div><div class="line">    alert(tom);<span class="comment">//输出tom</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="对象结构中的默认值使用"><a href="#对象结构中的默认值使用" class="headerlink" title="对象结构中的默认值使用"></a>对象结构中的默认值使用</h3><p>当然我们可以赋默认值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> &#123;tom=<span class="string">"TOM"</span>,mary, jack&#125; = &#123;<span class="attr">jack</span>: <span class="string">"jack"</span>&#125;;</div><div class="line">    alert(tom);</div><div class="line">    alert(mary);<span class="comment">//输出undefined</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这种语法糖更是提供了我们对对象属性的赋值，和将对象属性直接转化为变量<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">   <span class="keyword">let</span> man=&#123;<span class="attr">clz</span>:<span class="string">"Man"</span>,<span class="attr">old</span>:<span class="number">18</span>&#125;;</div><div class="line">   <span class="keyword">let</span> &#123;<span class="attr">clz</span>:clz,<span class="attr">old</span>:od&#125;=man;<span class="comment">//以属性名:变量名的方式来确定赋值</span></div><div class="line">    alert(clz);</div><div class="line">    alert(od);</div><div class="line"></div><div class="line">   <span class="keyword">let</span> woman=&#123;<span class="attr">clz</span>:<span class="string">"woman"</span>,<span class="attr">old</span>:od&#125;;<span class="comment">//变量作为实际值</span></div><div class="line">   alert(woman.old);<span class="comment">//输出18</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="嵌套匹配结构"><a href="#嵌套匹配结构" class="headerlink" title="嵌套匹配结构"></a>嵌套匹配结构</h3><p>嵌套的匹配<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> course=&#123;</div><div class="line">        <span class="attr">name</span>:<span class="string">"Operation System"</span>,</div><div class="line">        <span class="attr">detail</span>:&#123;</div><div class="line">            <span class="attr">score</span>:<span class="number">3.5</span>,</div><div class="line">            <span class="attr">teacher</span>:[<span class="string">"Mark Watson"</span>,<span class="string">"John Joy"</span>]</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">let</span> &#123;name,<span class="attr">detail</span>:&#123;score,<span class="attr">teacher</span>:[t1,t2]&#125;&#125;=course;</div><div class="line">    <span class="comment">//如果你想获取整个detail的值，可以这样let &#123;name,detail,detail:&#123;score,teacher:[t1,t2]&#125;&#125;=course;</span></div><div class="line">    alert(name);</div><div class="line">    alert(score);</div><div class="line">    alert(t2);<span class="comment">//正确输出了John joy，可见新的语法糖给我们带来的便利是很明显的，虽然很少会用到</span></div><div class="line">&#125;</div><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> k=[];</div><div class="line">    (&#123;<span class="attr">z</span>:k[<span class="number">1</span>],<span class="attr">m</span>:k[<span class="number">0</span>]&#125;=&#123;<span class="attr">m</span>:<span class="number">2</span>,<span class="attr">z</span>:<span class="number">1</span>&#125;);<span class="comment">//加小括号的理由是&#123;开头会被解释器认为是一个代码块的开始</span></div><div class="line">    alert(k[<span class="number">0</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="提取函数和转化字符串"><a href="#提取函数和转化字符串" class="headerlink" title="提取函数和转化字符串"></a>提取函数和转化字符串</h3><p>我们可以这样讲对象中的函数提取出来<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> &#123;sin,cos,log,tan&#125;=<span class="built_in">Math</span>;</div><div class="line">    alert(tan);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于字符串，我们可以将它解构为一个个字符<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">   <span class="keyword">let</span> [a,b,c]=<span class="string">"abc"</span>;</div><div class="line">   alert(a+<span class="string">"~"</span>+b+<span class="string">"~"</span>+c);<span class="comment">//输出a~b~c</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="函数解构"><a href="#函数解构" class="headerlink" title="函数解构"></a>函数解构</h2><p>对函数的数组参数进行解构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    function hello([x,y]) &#123;</div><div class="line">        alert(x+&quot; &quot;+y);</div><div class="line">    &#125;</div><div class="line">    let v=[&quot;hello&quot;,&quot;world&quot;];</div><div class="line">    hello(v);//输出hello world</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>提供默认值和默认参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    function halo(&#123;x=&quot;halo&quot;,y=&quot;world&quot;&#125;=&#123;&#125;) &#123;</div><div class="line">        alert(x+&quot; &quot;+y);</div><div class="line">    &#125;</div><div class="line">    halo(&#123;x:&quot;hello&quot;&#125;);</div><div class="line">    halo(&#123;y:&quot;Jack&quot;&#125;);</div><div class="line">    function hi(&#123;x,y&#125;=&#123;x:&quot;hi&quot;,y:&quot;world&quot;&#125;) &#123;</div><div class="line">        alert(x+&quot; &quot;+y);</div><div class="line">    &#125;</div><div class="line">    hi(&#123;x:&quot;hello&quot;&#125;);//提供了参数&#123;x:&quot;hello&quot;&#125;，不使用默认参数，输出hello undefined</div><div class="line">    hi();//使用默认参数，输出hello world</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="解构的应用"><a href="#解构的应用" class="headerlink" title="解构的应用"></a>解构的应用</h2><p>用于交换<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> [x,y]=[<span class="number">1</span>,<span class="number">2</span>];</div><div class="line">    [x,y]=[y,x];</div><div class="line">    alert(y);<span class="comment">//输出1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>用于解构函数的返回值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnArray</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnObj</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;<span class="attr">x</span>:<span class="string">"hey"</span>,<span class="attr">y</span>:<span class="string">"Daisy"</span>&#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> [a,b,c]=returnArray();</div><div class="line"><span class="keyword">let</span> &#123;<span class="attr">x</span>:m,<span class="attr">y</span>:k&#125;=returnObj();</div><div class="line">alert(k);<span class="comment">//Daisy</span></div><div class="line">alert(b);<span class="comment">//2</span></div></pre></td></tr></table></figure></p>
<p>快速提取json对象中的数据<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> json=&#123;<span class="attr">name</span>:<span class="string">"Jack"</span>,<span class="attr">score</span>:[<span class="number">83</span>,<span class="number">91</span>],<span class="attr">old</span>:<span class="number">15</span>&#125;;</div><div class="line"><span class="keyword">let</span> &#123;<span class="attr">name</span>:x,<span class="attr">score</span>:s,<span class="attr">old</span>:o&#125;=json</div><div class="line">alert(s[<span class="number">1</span>]);<span class="comment">//91</span></div></pre></td></tr></table></figure></p>
<p>提取map中的键值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</div><div class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</div><div class="line">    alert(key + <span class="string">" is "</span> + value);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  本世纪以来的很多新语言都提供了各种赋值或者模式匹配判断的语法糖，es6也提供了对解构赋值的一系列支持使得我们可以在很多情况下节省很多行代码。但是对一个复杂模式的解构赋值很可能让维护代码的人员感到很疑惑，所以这里记录的解构赋值没有那么多奇技淫巧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>Learning ES6(1):块作用域</title>
    <link href="http://yoursite.com/2017/12/06/Learning-ES6-1-Block-scope/"/>
    <id>http://yoursite.com/2017/12/06/Learning-ES6-1-Block-scope/</id>
    <published>2017-12-06T06:46:19.000Z</published>
    <updated>2017-12-06T08:42:35.280Z</updated>
    
    <content type="html"><![CDATA[<p>  最近主要是在学习3个东西，一个就是单元测试，第二个就是jvm，还有一个就是es6了，目前的话jvm已经学完了，就差把笔记搬运从笔记本上到博客上，单元测试和es6的话都是正在进行，es6的是阮一峰的<a href="https://github.com/ruanyf/es6tutorial" target="_blank" rel="external">ECMAScript 6 入门</a>，大神已经把书开源道github上了，推荐大家去看那本书，博客这里主要用于我个人用于以后回忆某些知识用的。</p>
<p>  至于es6是什么可以自行使用搜索引擎，或看上面那本书的第1章，这里我就不介绍了。</p>
<hr>
<p>  在ES6之前，js中是没有<strong>块级作用域</strong>这个东西的，只有<strong>函数</strong>和<strong>全局</strong>作用域<br>  ES6中的第一个特性，即以let来声明一个变量，这个变量只在当前代码块中有效，比如对于如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">let</span> k = <span class="number">3</span>;<span class="comment">//k作用域只在当前代码块中</span></div><div class="line">    &#125;</div><div class="line">    alert(k); <span class="comment">//报错，外层代码不能去引用内层代码块中的k，如果上面是var则输出3</span></div><div class="line">&#125;();</div><div class="line"></div><div class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> k = <span class="number">3</span>;</div><div class="line">    &#123;</div><div class="line">        alert(k);<span class="comment">//正常输出3</span></div><div class="line">    &#125;</div><div class="line">&#125;();</div><div class="line"></div><div class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> k = <span class="number">4</span>;</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">let</span> k = <span class="number">5</span>;</div><div class="line">        alert(k);<span class="comment">//输出k=5</span></div><div class="line">    &#125;</div><div class="line">    alert(k);<span class="comment">//输出k=4</span></div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="let变量特性"><a href="#let变量特性" class="headerlink" title="let变量特性"></a>let变量特性</h2><h3 id="变量提升和暂时性死区"><a href="#变量提升和暂时性死区" class="headerlink" title="变量提升和暂时性死区"></a>变量提升和暂时性死区</h3><p>  对于var声明的变量会有变量提升问题，即是在作用域开头变量已经存在但是没有赋值，<strong>var定义的变量只能是函数或者全局作用域有效的，没有块这个概念</strong>。比如对于以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(f);<span class="comment">//输出undefined，var声明的变量标识在函数作用域有效，有变量提升</span></div><div class="line">    <span class="keyword">var</span> f = <span class="number">1</span>;</div><div class="line">&#125;();</div><div class="line"></div><div class="line"><span class="comment">//实际相当于执行代码：</span></div><div class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  	<span class="keyword">var</span> f = <span class="literal">undefined</span>;</div><div class="line">    alert(f);</div><div class="line">    f = <span class="number">1</span>;</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>但是对于let来说，这样声明就报错，<strong>let声明的变量没有变量提升</strong>，作用域是块级。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">//TDZ开始</span></div><div class="line">    alert(k);<span class="comment">//报错:Uncaught ReferenceError: k is not defined</span></div><div class="line">    <span class="keyword">let</span> k = <span class="number">1</span>;<span class="comment">//TDZ结束</span></div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>现在我们来引入一个概念：暂时性死区(temporl dead zone,TDZ),这个概念是对于let和const变量而言的，es6引入它的目的在于，让js程序员养成使用前先定义的好习惯。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">* 在阮一峰的《ECMAScript 6 入门》中提到</div><div class="line">* ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。</div><div class="line">* 凡是在声明之前就使用这些变量（任何操作），就会报错。</div><div class="line">*</div><div class="line">* 在块中，let定义一个变量n之前的区域，都称之为“展暂时性死区”</div></pre></td></tr></table></figure>
<p>总之，暂时性死区的本质就是，<strong>只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</strong></p>
<h3 id="不可重复声明"><a href="#不可重复声明" class="headerlink" title="不可重复声明"></a>不可重复声明</h3><p>在同一个作用域中，var声明的变量可以重复声明，会取后声明的值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//正常运行</span></div><div class="line">    <span class="keyword">var</span> f = <span class="number">1</span>;</div><div class="line">    <span class="keyword">var</span> f = <span class="number">2</span>;</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>而在同一个作用域中，let声明的变量不可以重复声明，会报错</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//报错</span></div><div class="line">    <span class="keyword">let</span> k = <span class="number">4</span>;</div><div class="line">    <span class="keyword">let</span> k = <span class="number">5</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//如果同一个变量已经被var声明，那么如果它再用let声明同样报错</span></div><div class="line">    <span class="comment">//let f=3;</span></div><div class="line">&#125;();</div><div class="line"></div><div class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> f = <span class="number">4</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//如果同一个变量已经被var声明，那么如果它再用let声明同样报错</span></div><div class="line">    <span class="comment">//相反一样</span></div><div class="line">    <span class="keyword">let</span> f=<span class="number">3</span>;<span class="comment">//这一行报错</span></div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<h3 id="用let做for循环参数"><a href="#用let做for循环参数" class="headerlink" title="用let做for循环参数"></a>用let做for循环参数</h3><p>ES5中由于闭包关系，我们不得不用一段不太漂亮的代码来实现for循环中i的不同取值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">!function () &#123;</div><div class="line">    var a = &#123;&#125;;</div><div class="line">    for (let i = 0; i &lt; 10; i++) &#123;</div><div class="line">        a[i] = function (arg) &#123;//闭包函数，以变量arg来保存当前i的值，从而传递给内部的返回函数</div><div class="line">            return function () &#123;</div><div class="line">                alert(arg)</div><div class="line">            &#125;</div><div class="line">        &#125;(i);</div><div class="line">    &#125;</div><div class="line">    a[6]()</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>在ES6中我们可以这样做:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> a = &#123;&#125;;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">        a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            alert(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    a[<span class="number">6</span>]()</div><div class="line">&#125;();</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> 这里很多人可能会理解错误，因为for语句和&#123;&#125;代码块其实是两个作用域</div><div class="line"> 而let只能在当前作用域有效，那么&#123;&#125;代码块里的数据是怎么来的呢？</div><div class="line"> 其实这里每次循环都创建了一个新的i，这个新的i的值在旧的i的基础上计算</div><div class="line"> */</div><div class="line"> </div><div class="line"><span class="comment">//类似于执行一个这样的，过程</span></div><div class="line"><span class="keyword">var</span> a = &#123;&#125;;</div><div class="line">&#123; <span class="keyword">let</span> k = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">for</span> (;k &lt; <span class="number">10</span>;) &#123;</div><div class="line">      <span class="keyword">let</span> i = k; </div><div class="line">      a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        alert(i);</div><div class="line">      &#125;;</div><div class="line">      k++;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></div><div class="line"></div><div class="line"><span class="comment">//在babel中转成es代码是这样的：</span></div><div class="line"><span class="keyword">var</span> a = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> _loop = <span class="function"><span class="keyword">function</span> <span class="title">_loop</span>(<span class="params">i</span>) </span>&#123;</div><div class="line">    a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        alert(i);</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    _loop(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="const变量"><a href="#const变量" class="headerlink" title="const变量"></a>const变量</h2><p>  const声明常量，一旦声明就不能被改变，所以const声明时必须立刻赋值<br>如果下代码不赋值就抛出：Uncaught SyntaxError: Missing initializer in const declaration</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> k;</div><div class="line">alert(k);</div></pre></td></tr></table></figure>
<p><strong>const同样只在块作用域内有效，不可重复声明，且存在暂时性死区</strong></p>
<p>  const只能保证它所指向的地址不可变，但是这个地址的数据结构怎么变它管不了，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> man=&#123;&#125;;</div><div class="line">man.name=<span class="string">"Tom"</span>;</div><div class="line">man.name=<span class="string">"Jack"</span>;</div><div class="line">alert(man.name);<span class="comment">//输出jack</span></div></pre></td></tr></table></figure>
<p>  如果要保证对象不可变，还是必须用Object.freeze去冻结一个对象，比如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> man=<span class="built_in">Object</span>.freeze(&#123;<span class="attr">name</span>:<span class="string">"Tom"</span>&#125;);</div><div class="line">man.name=<span class="string">"Jack"</span>;<span class="comment">//不报错，但是不起作用，如果是严格模式就报错了</span></div><div class="line">alert(man.name);</div></pre></td></tr></table></figure>
<p>这种冻结方式对对象的对象引用属性没效果，但是你可以以递归去写一个冻结函数。</p>
<h2 id="块级作用域和函数"><a href="#块级作用域和函数" class="headerlink" title="块级作用域和函数"></a>块级作用域和函数</h2><p>在es5浏览器中，下面的代码是可以正常运行的，并输出I am inside，因为function声明会提升到函数作用域顶端</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>); &#125;</div><div class="line">    !<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</div><div class="line">            <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>); &#125;</div><div class="line">        &#125;</div><div class="line">        f();</div><div class="line">    &#125;();</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>  在es5浏览器中，上面的代码是可以正常运行的，并输出I am inside，因为function声明会提升到函数作用域顶端，实际上执行下面这段：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>); &#125;</div><div class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>); &#125;</div><div class="line">        <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</div><div class="line">        &#125;</div><div class="line">        f();</div><div class="line">    &#125;());</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>  在es6浏览器中，在块级作用域中声明函数，类似var声明变量，下面这段代码会抛出错误:Uncaught TypeError: f is not a function<br>实际上es6浏览器执行的代码，是类似于下面这段：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>); &#125;</div><div class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> f = <span class="literal">undefined</span>;</div><div class="line">        <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</div><div class="line">            f=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>); &#125;</div><div class="line">        &#125;</div><div class="line">        f();</div><div class="line">    &#125;());</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>  最佳实践是：避免在块级作用域内声明函数，在有必要的情况下，也应该写成函数表达式，而不是函数声明语句。</p>
<h2 id="全局作用域的let和const"><a href="#全局作用域的let和const" class="headerlink" title="全局作用域的let和const"></a>全局作用域的let和const</h2><p>在es5中，我们知道浏览器中的顶层对象指的是window和self对象(Node中是global)</p>
<p>浏览器中对于var和function命令声明的全局变量，其实就是window的属性</p>
<p>es6为了改变这种含糊的表达方式，但是又不得不得向以前的代码妥协，于是它做出了以下区分：<br>首先它对于var和function命令声明的全局变量意义不变<br>对于let,const,class声明的全局变量，不再是顶层对象的属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">abc</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">"abc"</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">window</span>.abc();</div><div class="line"></div><div class="line"><span class="keyword">var</span> k=<span class="string">"kkk"</span>;</div><div class="line">alert(<span class="built_in">window</span>.k);</div><div class="line"></div><div class="line"><span class="keyword">let</span> i=<span class="string">"iii"</span>;</div><div class="line">alert(<span class="built_in">window</span>.i);<span class="comment">//undefinded</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  最近主要是在学习3个东西，一个就是单元测试，第二个就是jvm，还有一个就是es6了，目前的话jvm已经学完了，就差把笔记搬运从笔记本上到博客上，单元测试和es6的话都是正在进行，es6的是阮一峰的&lt;a href=&quot;https://github.com/ruanyf/es6tutorial&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ECMAScript 6 入门&lt;/a&gt;，大神已经把书开源道github上了，推荐大家去看那本书，博客这里主要用于我个人用于以后回忆某些知识用的。&lt;/p&gt;
&lt;p&gt;  至于es6是什么可以自行使用搜索引擎，或看上面那本书的第1章，这里我就不介绍了。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;  在ES6之前，js中是没有&lt;strong&gt;块级作用域&lt;/strong&gt;这个东西的，只有&lt;strong&gt;函数&lt;/strong&gt;和&lt;strong&gt;全局&lt;/strong&gt;作用域&lt;br&gt;  ES6中的第一个特性，即以let来声明一个变量，这个变量只在当前代码块中有效，比如对于如下代码：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;!&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; k = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//k作用域只在当前代码块中&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    alert(k); &lt;span class=&quot;comment&quot;&gt;//报错，外层代码不能去引用内层代码块中的k，如果上面是var则输出3&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;!&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; k = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        alert(k);&lt;span class=&quot;comment&quot;&gt;//正常输出3&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;!&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; k = &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; k = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        alert(k);&lt;span class=&quot;comment&quot;&gt;//输出k=5&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    alert(k);&lt;span class=&quot;comment&quot;&gt;//输出k=4&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>JVM(4):类加载器机制</title>
    <link href="http://yoursite.com/2017/12/05/JVM-4-Class-Loader/"/>
    <id>http://yoursite.com/2017/12/05/JVM-4-Class-Loader/</id>
    <published>2017-12-05T03:45:40.000Z</published>
    <updated>2017-12-05T10:23:38.194Z</updated>
    
    <content type="html"><![CDATA[<p>  类加载执行的前提是我们能以一个类的全限定名来获取字节流，至于字节流在哪里生成，我们从哪里获取这并不是虚拟机所关心的，作为一个出色的设计团队，Java的设计者最初为了满足Java Applet，设计了大名鼎鼎的类加载器机制，<strong>即让通过全限定名获取字节流的这个动作，放到JVM的外部，用户可以选择自行实现一些特殊的加载方案</strong>，现在你知道的随着flash的流行，Java Applet这种技术已经淘汰了，现在随着html5的新起，flash也基本上接近夕阳了，可见技术的变化是普遍而剧烈的。虽然Applet死了很多年，但是类加载器却被作为一种精髓留在了java体系中，原因是它在OSGi,代码加密，热部署等等应用中有了新生的土壤。</p>
<p>  类加载器还有一个作用就是和类的标识一起来确定这个类的唯一性，若N1是类C的全限定名称标识，而L1是加载类C类加载器，那么如果存在一个类D的全限定名称为N2,而L2是类D的加载器，那么：</p>
<p> 当且仅当，N1=N2且L1=L2时C和D才被认为是同一个类，即C&lt;N1,L1&gt;=D&lt;N2,L2&gt;</p>
<p> 这种相等，关系到类的Class对象的equals方法，isAssignableFrom()方法以及isInstance()方法和instanceof关键字的判断结果。</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException </span>&#123;</div><div class="line">      	<span class="comment">//从写一个自定义类加载器，用于加载同路径下的类，如果一个类名不是同路径下的就用父类加载器加载</span></div><div class="line">		ClassLoader loader=<span class="keyword">new</span> ClassLoader() &#123;</div><div class="line">			<span class="keyword">public</span> java.lang.Class&lt;?&amp;gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					String fn=name.substring(name.lastIndexOf(<span class="string">"."</span>)+<span class="number">1</span>)+<span class="string">".class"</span>;</div><div class="line">					InputStream resourceAsStream = getClass().getResourceAsStream(fn);</div><div class="line">                  	  <span class="comment">//同路径下没有该类，用父类加载器加载</span></div><div class="line">					<span class="keyword">if</span>(resourceAsStream==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</div><div class="line">					<span class="keyword">byte</span>[] bs=<span class="keyword">new</span> <span class="keyword">byte</span>[resourceAsStream.available()];</div><div class="line">					resourceAsStream.read(bs);</div><div class="line">					<span class="keyword">return</span> defineClass(name, bs, <span class="number">0</span>, bs.length);</div><div class="line">				&#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">			&#125;;</div><div class="line">		&#125;;</div><div class="line">		Object newInstance = loader.loadClass(<span class="string">"test.Hello"</span>).newInstance();</div><div class="line">		Hello hello = <span class="keyword">new</span> Hello();</div><div class="line">		System.out.println(newInstance.getClass().getName());</div><div class="line">		System.out.println(hello.getClass().getName());</div><div class="line">		System.out.println(newInstance.getClass().equals(hello.getClass()));</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//可以看出虽然全限定名相同但是却是不同的类</span></div><div class="line">输出：</div><div class="line">test.Hello</div><div class="line">test.Hello</div><div class="line"><span class="keyword">false</span></div></pre></td></tr></table></figure>
<h2 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h2><p>  在官方文档中，我们中看到了两种类加载器的区分，一种就是<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3.1" target="_blank" rel="external">启动类加载器</a>（Bootstrap Class Loader ）还一种就是<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3.2" target="_blank" rel="external">用户定义加载器</a>（ User-defined Class Loader ）。</p>
<p>原文：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">There are two kinds of class loaders: the bootstrap class loader supplied by the Java Virtual Machine, and user-defined class loaders. Every user-defined class loader is an instance of a subclass of the abstract class ClassLoader</div></pre></td></tr></table></figure>
<h3 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h3><p>  这个<strong>启动类加载器</strong>是虚拟机本身定义的，它是以C++来实现的，用于加载java的核心库&lt;JAVA_HOME&gt;\lib中或者-Xbootclasspath参数指定的，这些库都要被虚拟机所识别比如rt.jar，随便定义一个库放到以上文件夹里是不会被虚拟机加载的。</p>
<h3 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><p>  对于<strong>用户定义类加载器</strong>来说，它的工作步骤大概是这样的：</p>
<p>  首先JVM判断用户定义加载器L是不是已经记录为全限定名为N的类或者接口的初始加载器，如果是就直接返回这个类C，没必要从新创建一个类。</p>
<p>  否则，JVM就调用L的loadClass方法，参数为N，这此调用创建一个新的类或者接口C并返回，然后JVM会记录L是C的初始加载器。详细来说这个过程会执行接下来的两个操作中的一个：</p>
<p>  <strong>操作1</strong>：类加载器L可以创建一个字节数组用于表示C在Class文件结构中的字节流，之后L调用Classloader类中的defineClass方法，defineClass方法会让JVM用这个字节数组派生出一个类&lt;N,L&gt;（类的唯一性标识，上面提到过）</p>
<p>  <strong>操作2</strong>：类加载器L可以把C的加载委托给另一个加载器L’,这个过程通过用N直接或者间接地调用L‘的方法的完成，一般是loadClass方法，然后调用的结果是C。</p>
<p>无论是操作1还是操作2，如果类加载器不能加载全限定名为N的类，就会抛出ClassNotFoundException异常实例。</p>
<p>用户定义类加载器这个分类，并不是指这个加载器一定是用户定义的，比如有两个系统定义的加载器也属于这个分类：</p>
<p>1.扩展类加载器(extensions class loader)：用于加载Java的扩展库，即&lt;JAVA_HOME&gt;\lib\ext目录中的或者由java.ext.dirs系统变量指定的。</p>
<p>2.应用类加载器(Application class loader)：根据Java应用的类路径CLASSPATH来加载Java类，一般Java应用的类都由它加载，我们可以通过ClassLoader中的getSystemClassLoader方法来获取它。</p>
<h2 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h2><p><img src="\img\QQ图片20171205143304.png" alt="QQ图片20171205143304"></p>
<p>从图中（这里箭头不是继承关系）可以看出，除了顶层的启动类加载器以外，其余的类加载器都应当有自己委派类加载器，一般用组合关系来实现这种委派关系。</p>
<p>双亲委派模式是指：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求为派给上层的加载器去完成，只有当<strong>上层加载器不能加载的时候才会尝试自己去加载</strong>，这样就保证了java类有一种层次关系，保证了即使你用不同的类加载器去执行类加载，但是实际上我们一般都会得到相同的&lt;N,L&gt;,不会导致类关系的错乱。</p>
<p>双亲委派模式是保证Java程序稳定运行的重要部分。但并不是强制约束模型，实际上在OSGi等环境下这种模式已经被改造，不再基于树桩结构而是基于网状结构。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  类加载执行的前提是我们能以一个类的全限定名来获取字节流，至于字节流在哪里生成，我们从哪里获取这并不是虚拟机所关心的，作为一个出色的设计团队，Java的设计者最初为了满足Java Applet，设计了大名鼎鼎的类加载器机制，&lt;strong&gt;即让通过全限定名获取字节流的这个动作，放到JVM的外部，用户可以选择自行实现一些特殊的加载方案&lt;/strong&gt;，现在你知道的随着flash的流行，Java Applet这种技术已经淘汰了，现在随着html5的新起，flash也基本上接近夕阳了，可见技术的变化是普遍而剧烈的。虽然Applet死了很多年，但是类加载器却被作为一种精髓留在了java体系中，原因是它在OSGi,代码加密，热部署等等应用中有了新生的土壤。&lt;/p&gt;
&lt;p&gt;  类加载器还有一个作用就是和类的标识一起来确定这个类的唯一性，若N1是类C的全限定名称标识，而L1是加载类C类加载器，那么如果存在一个类D的全限定名称为N2,而L2是类D的加载器，那么：&lt;/p&gt;
&lt;p&gt; 当且仅当，N1=N2且L1=L2时C和D才被认为是同一个类，即C&amp;lt;N1,L1&amp;gt;=D&amp;lt;N2,L2&amp;gt;&lt;/p&gt;
&lt;p&gt; 这种相等，关系到类的Class对象的equals方法，isAssignableFrom()方法以及isInstance()方法和instanceof关键字的判断结果。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM(3):类加载过程</title>
    <link href="http://yoursite.com/2017/12/04/JVM-3-Class-Loading/"/>
    <id>http://yoursite.com/2017/12/04/JVM-3-Class-Loading/</id>
    <published>2017-12-04T04:41:21.000Z</published>
    <updated>2017-12-09T07:17:44.128Z</updated>
    
    <content type="html"><![CDATA[<p>  一般来说，我们以.class文件的形式将类保存到磁盘上，在介绍类结构的时候我已经说了，jvm并不关系你的类从哪儿来，只要它符合jvm类结构的规范就好了，无论是以传统方式从磁盘上加载.class文件，还是从网络来获取一段流，亦或者以Proxy动态生成一个类，都没有问题，它们最终会被自己所属的<strong>类加载器</strong>加载到虚拟机的方法区中，成为jvm可以直接使用的java类型。</p>
<p>  类的生命周期有7个阶段，它们分别是：</p>
<p><code>加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化-&gt;使用-&gt;卸载</code></p>
<p>其中<code>验证-&gt;准备-&gt;解析</code>这三个阶段被称为链接（Linking）阶段</p>
<p><code>加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化</code>这5个阶段称为<strong>类加载阶段</strong></p>
<p>  在上面的声明周期七个阶段中，<strong>加载，验证，准备，初始化，卸载</strong>这5个阶段是<strong>按顺序开始</strong>的，注意这里是只是说开始，实际上它们的执行过程是<strong>交叉进行</strong>，相当于你按顺序执行了一个线程，线程里又执行了一个新的线程，如此往复的执行了5个，实际上它们是交叉执行的。</p>
<p>  上面的<strong>箭头部分有误导倾向</strong>，因为<strong>解析</strong>这个过程，为了支持Java的运行时绑定机制，<strong>有些时候在初始化过程之后开始</strong>。</p>
<a id="more"></a>
<p>  <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.5" target="_blank" rel="external">虚拟机规范</a>并没有规定加载阶段在什么时候开始，但是它规定了初始化阶段，<strong>有且只有</strong>在以下<strong>6种情况（Java1.8中）</strong>下必须立刻执行，当然我们上面提到过的，初始化阶段必须在<strong>加载，验证，准备</strong>之后才能执行，所以那个时候其实已经开始了前三个阶段了，类初始化实际上就是执行clinit方法，下面列出这六种情况，<strong>如果类没有被初始化，那么先初始化</strong>：</p>
<p>  1.遇到new,getstatic,putstatic,invokestatic四条字节码指令时，比如new一个对象，或者获取或修改一个类的静态变量</p>
<p>  2.使用了某些反射方法对类进行反射调用，比如Class类中或者java.lang.reflect包中的某些方法</p>
<p>  3.初始化一个类时，发现其父类没有被初始化，那么先初始化父类</p>
<p>  4.一个被选定为虚拟机启动时初始化类的类</p>
<p>  5.首次调用方法句柄解析结果是REF_getStatic, REF_putStatic, REF_invokeStatic,REF_newInvokeSpecial这几种类型的 java.lang.invoke.MethodHandle实例，且方法句柄所对应的类没有被初始化</p>
<p>  6.如果一个接口声明了一个非抽象且非静态的方法，在初始化它的实现类之前应该初始化。</p>
<p>  以上6种情况，统称为对一个类进行主动引用，有主动引用就有被动引用，被动引用不会触发对类的初始化，比如如下几种情况的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">----------案例一------------</div><div class="line">public class Hello &#123;</div><div class="line">	</div><div class="line">	public static int alpha=123;</div><div class="line">	</div><div class="line">	//这种区域会直接编译到clinit方法中去</div><div class="line">	static &#123;</div><div class="line">		System.out.println(&quot;hello&quot;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//注意main方法是在父类Hello中，如在子类中，会因为这个main方法导致子类初始化</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		/*</div><div class="line">		*用子类A调用了父类中的字段alpha，</div><div class="line">		*但是实际上A不会被初始化，从类结构上考虑下我们就可以知道为什么，</div><div class="line">		*因为子类中根本不会有父类的字段，而父类的static在父类的clinit方法中初始化，和子类没半毛钱关系</div><div class="line">		*/</div><div class="line">		System.out.println(A.alpha);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">class A extends Hello &#123;</div><div class="line">	</div><div class="line">	static &#123;</div><div class="line">		System.out.println(&quot;m&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line">输出：</div><div class="line">hello</div><div class="line">123</div><div class="line"></div><div class="line"></div><div class="line">--------------案例二----------</div><div class="line">class Init&#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">	/*</div><div class="line">	这种情况既不会初始化A也不会初始化Hello，为什么呢？因为数组这种类是由jvm自己生成的，而且new一个数组的字节码也是newarray而不是new</div><div class="line">	*/</div><div class="line">		A[] hello=new A[100];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">输出：</div></pre></td></tr></table></figure>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>  我们首先来讨论一下<strong>类加载</strong>过程中的第一个阶段——<strong>加载</strong>，这个阶段主要就是做这样两件事情：</p>
<p> 1.把一个类的全限定名获取来的字节流转化为方法区的运行时数据结构</p>
<p> 2.在内存中（hotspot是在方法区中），生成一个代表该类的java.lang.Class对象，以作为该类各种数据的访问入口</p>
<hr>
<p><strong>数组的加载</strong></p>
<p>对于数组而言，上面我们看到了数组这种东西是JVM自己创建的，那么它的加载方式也不同，但是对于数组的元素类型（<strong>数组去掉所有维度对应的那个类型</strong>）还是要用类加载器去加载的。</p>
<p>下面的步骤用于使用类加载器L类装载器创建由描述符N表示的数组类C，L可以是引导类加载器或用户定义类加载器。</p>
<p>第一步JVM判断，如果L已被记录为具有与描述符为N的类或者接口的组件类型的数组类的启动装入器，则该类是C，并且不需要创建数组类。 （就是该数组类型已经被在加载了，就不再加载）</p>
<p>否则，执行以下步骤以创建C：</p>
<p>如果组件类型（<strong>数组去掉一个维度的类型</strong>）是引用类型，类加载器L递归的使用这一节说到的类加载算法，从而创建的组件类型C.</p>
<p>java虚拟机创建一个新的显示组件类型和维数的数组类。</p>
<p>如果组件类型是引用类型，那么C被标记为由组件类型的定义类装入器定义的。</p>
<p>否则（比如int k[],这基本类型），C被标记为由引导类装入器定义的。</p>
<p>在以上两种的任何情况下，接下来java虚拟机都会记录L是C的类加载器。如果组件类型是引用类型，则数组类的可访问性取决于其组件类型的可访问性。否则，数组类的可访问性是公共的。 </p>
<hr>
<p>  有些人可能会好奇方法区中怎么存储类，这个问题我可能会写一篇新的文章来说明，目前我们只讨论类加载过程，实际上JVM规范是没有给出方法区以什么数据结构出现的，但是我们可以在未来讨论一下Hotspot中的实现，正如上面所说的，Hotspot会在方法区中创建一个标识类的java.lang.Class对象。</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>  我们把验证，准备，解析3个阶段统称为链接阶段，链接阶段是与加载阶段交替进行的，即一边加载一边链接。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>  首先我们来看看验证阶段，这个阶段并不是运行是必须的，你完全可以不验证类，只要你保证它一定是符合虚拟机规范正常运行的，比如对于一些软件中运行了不知道多少年的类，你可以认为他们不需要浪费时间去验证，因为以前已经验证过了（验证是非常耗时的），我们可以使用-Xverify:none参数来关闭大部分类验证措施。</p>
<p>  虽然验证并非是必要的，但是不代表它不是重要的，它是虚拟机能够稳定运行的重要防线，我们虽然会浪费时间对一个类进行重复的验证，不过我们也可以防止一些恶意的意想不到的字节流对我们的虚拟机造成不可预测的破坏。</p>
<p>  如果验证阶段验证到字节流不符合Class规范，那么虚拟机会抛出java.lang.VerifyError或者其子异常。</p>
<p>以HotSpot验证过程大概分为四个部分：</p>
<p>1.文件结构验证</p>
<p>  这个阶段是验证里唯一一个基于二进制字节流的阶段，通过了该阶段之后字节流就变成方法区的数据结构了，该阶段主要是验证像魔术，版本，是否符合UTF8编码等等不需要语义分析的验证。</p>
<p>2.元数据验证</p>
<p>  这个阶段主要是对类的继承，抽象等等语义进行验证，即对类的元数据进行语义验证</p>
<p>3.字节码验证</p>
<p>  主要通过数据流和控制流分析看程序语义是否合法，还有就是对方法体进行校验，在上篇文章中我们提到的额StackMapTable属性就是在这个阶段中使用的，它描述了方法体中所有的基本代码块开始是本地变量表和操作数栈应有的关系，验证期间对着它来推导状态的合法性。</p>
<p>4.符号引用验证</p>
<p>  这个阶段的验证发生在解析阶段中，主要对符号引用转化为直接引用的可行性进行验证，如果通过不了就会抛出一个java.lang.IncompatibleClassChangeError异常的子类型。</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>  该阶段涉及到为类创建静态字段（static fields）并为他们设置初始值。</p>
<p>  这里的初始值并不是指用户在诸如<code>static int k=1;</code>这样的语句中设定的k的值为1（这个阶段是clinit做的）,而是对于int类型给定初始值为0，对boolean则是为false，对reference则是null，等等。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>  解析阶段即是<strong>虚拟机将常量池内的符号引用替换为直接引用的过程</strong>。</p>
<p>  JVM中<em>anewarray</em>, <em>checkcast</em>, <em>getfield</em>, <em>getstatic</em>, <em>instanceof</em>,<em> invokedynamic</em>, <em>invokeinterface</em>, <em>invokespecial</em>, <em>invokestatic</em>,<em>invokevirtual</em>, <em>ldc</em>, <em>ldc_w</em>, <em>multianewarray</em>, <em>new</em>, <em>putfield</em>,  <em>putstatic</em>都把符号引用映射到在运行时常量池（run-time constant pool），所以在执行这些语句之前都需要先执行对应符号引用的解析。</p>
<p>  对于除了invokedynamic之外的指令，对同一个符号引用的多次解析是非常平常的，因此虚拟机会把第一次解析结果进行缓存，从而实现只解析一次，实际操作方式是在运行时常量池中把直接引用标记为已解析状态。这样一来如果一个符号以前被正确解析过，那么解析请求就应当一直成功，如果第一次失败了，那么后续失败抛出的异常也应该相同。这些指令都可以在刚刚完成加载阶段就开始解析。</p>
<p>  对应invokedynamic来说，它是要等到程序运行到这条指令才开始解析，所以我们说类的解析阶段不固定，可能是在初始化之后才完成也说不定。当碰到前面某个已经由invokedynamic触发过解析的符号引用时，并不意味着该解析结果对于其他的invokedynamic同样适用。</p>
<p>  解析动作主要针对7中符号：</p>
<p>  类和接口，字段，类方法，接口方法，方法类型，方法句柄以及调用点</p>
<h4 id="类和接口解析"><a href="#类和接口解析" class="headerlink" title="类和接口解析"></a>类和接口解析</h4><p>对类和接口的解析我们这样来描述：</p>
<p> 如果当前代码所属类D，现在要解析一个未解析的符号N为一个类或者接口的直接引用，那么：</p>
<ol>
<li>如果C不是数组，那么VM把代表N的权限定名给用D的类加载器，然后D的类加载器去加载C。</li>
<li><p>如果C是数组则按照第一点加载数组的元素类型。接着虚拟机生成一个代表此数组维度和元素的数组对象</p>
<p>3.上面的步骤正常执行完，那么最后进行符号引用验证，确认D是否具备对C的访问权，不具备就抛出java.lang.IllegalAccessError。</p>
</li>
</ol>
<h4 id="字段解析"><a href="#字段解析" class="headerlink" title="字段解析"></a>字段解析</h4><p>  解析一个未被解析过的字段的符号引用，首先对该字段表内class_index项中索引的CONSTANT_Class_info符号引用进行解析（即先解析这个对应的类，参照上面的对类和接口的解析）。</p>
<p>如果C本身就包含了简单名称和字段描述符的字段都与目标相匹配的字段，则字段查找成功。返回这个字段的直接引用，查找结束。</p>
<p>否则，如果C定义了接口那么会按照继承关系递归的搜索各个接口和他的父接口，如果接口中包含了简单名称和字段的全部描述符都于目标相匹配的字段，则返回这个字段的直接引用，查找结束。</p>
<p>否则，如果C不是java.lang.Object就递归搜索其父类，如果父类中包含了简单名称和字段描述都与目标相匹配的字段，则返回该字段的直接引用，查找结束。</p>
<p>否则，字段查找失败，抛出java.lang.NoSuchFieldError异常</p>
<p>上面的步骤正常执行完，那么最后进行符号引用验证，上下文是否具备对字段的访问权，不具备就抛出java.lang.IllegalAccessError。</p>
<h4 id="类方法解析"><a href="#类方法解析" class="headerlink" title="类方法解析"></a>类方法解析</h4><p>  第一步先解析出类方法表中class_index所属的<strong>类引用</strong>,我们用C代表这个类。</p>
<p>  这里首先明确一点类方法和接口方法引用的常量定义是分开的，如果类方法表中class_index指向一个接口的索引就抛出java.lang.IncompatibleClassChangeError异常。</p>
<p>  如果C中有简单名称和描述符都相匹配的方法，有则返回该方法的直接引用，查找结束。</p>
<p>  否则递归寻找父类中是否有简单名称和描述符都相匹配的方法，有则返回该方法的直接引用，查找结束。</p>
<p>  否则递归寻找C实现的接口即接口的父接口中简单名称和描述符都相匹配的方法，有则说明C是抽象类，抛出java.lang.AbstractMethodError异常。</p>
<p>  否则肯定查找失败了，直接抛出java.lang.IllegalAccessError。</p>
<p>  上面的步骤正常执行完，那么最后进行符号引用验证，上下文是否具备对方法的访问权，不具备就抛出java.lang.IllegalAccessError。</p>
<h4 id="接口方法解析"><a href="#接口方法解析" class="headerlink" title="接口方法解析"></a>接口方法解析</h4><p>第一步先解析出类方法表中class_index所属的<strong>接口引用</strong>,我们用C代表这个接口。</p>
<p>  这里首先明确一点类方法和接口方法引用的常量定义是分开的，如果类方法表中class_index指向一个类的索引就抛出java.lang.IncompatibleClassChangeError异常。</p>
<p>  如果C中有简单名称和描述符都相匹配的方法，有则返回该方法的直接引用，查找结束。</p>
<p>  否则递归寻找C的父接口中简单名称和描述符都相匹配的方法，直到找到java.lang.Object类， 如果找到有简单名称和描述符都相匹配的方法，有则返回该方法的直接引用，查找结束。</p>
<p>  否则肯定查找失败了，直接抛出java.lang.NoSuchMethodError异常</p>
<p>  接口中的方法默认都是public和static的,不存在访问权限问题。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>  初始化阶段(Initialization)一般是类加载的最后一步(解析阶段有时候可能在这之后发生)，我们知道在链接过程中的准备阶段，我们的类变量就已经赋了类型默认值，但是<code>static int k=3;</code>这个3是的赋值就是发生在初始化阶段的,准确来说它发生在类构造器clinit方法执行的过程中。</p>
<p>  我们在讨论类的方法表的时候说过，编译器可能会自动给你加一些你没有写过的方法，比如类构造器就是一个这样的方法。</p>
<p>  编译器自动收集类中所有的类变量的赋值动作和静态代码块(static标注)，这个顺序由Java源代码给出的顺序决定，这里有一个很有意思的经常出面试题的部分，就是<strong>static块对出现在它之前类变量可以赋值但是不可以访问</strong></p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class Hello &#123;</div><div class="line">	static &#123;</div><div class="line">		alpha=1;</div><div class="line">		System.out.println(alpha);//该句报错</div><div class="line">	&#125;</div><div class="line">	public static int alpha=124;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//如果改为，则没问题</div><div class="line">class A extends Hello &#123;</div><div class="line">	public static int alpha=124;</div><div class="line">	static &#123;</div><div class="line">		alpha=1;</div><div class="line">		System.out.println(alpha);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  第二点要注意的就是，clinit不需要现实的调用父类的clinit，它会自动保证在执行子类的类构造器方法前已经执行了父类的类构造器。</p>
<p>  一个<strong>类或者接口</strong>中根本没有静态语句块和对静态变量赋值操作那么编译器可以不生成clinit方法，注意接口也可能有clinit来做对静态变量的初始化操作。</p>
<p>  VM会自动保证clinit方法在多线程环境中的同步和加锁操作，只能有一个线程去执行clinit，且同一个类加载器下，一个类型只会初始化一次，所以即使有多个线程同时执行这个类型的clinit，也只会有一个线程执行成功。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  一般来说，我们以.class文件的形式将类保存到磁盘上，在介绍类结构的时候我已经说了，jvm并不关系你的类从哪儿来，只要它符合jvm类结构的规范就好了，无论是以传统方式从磁盘上加载.class文件，还是从网络来获取一段流，亦或者以Proxy动态生成一个类，都没有问题，它们最终会被自己所属的&lt;strong&gt;类加载器&lt;/strong&gt;加载到虚拟机的方法区中，成为jvm可以直接使用的java类型。&lt;/p&gt;
&lt;p&gt;  类的生命周期有7个阶段，它们分别是：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;加载-&amp;gt;验证-&amp;gt;准备-&amp;gt;解析-&amp;gt;初始化-&amp;gt;使用-&amp;gt;卸载&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;验证-&amp;gt;准备-&amp;gt;解析&lt;/code&gt;这三个阶段被称为链接（Linking）阶段&lt;/p&gt;
&lt;p&gt;&lt;code&gt;加载-&amp;gt;验证-&amp;gt;准备-&amp;gt;解析-&amp;gt;初始化&lt;/code&gt;这5个阶段称为&lt;strong&gt;类加载阶段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  在上面的声明周期七个阶段中，&lt;strong&gt;加载，验证，准备，初始化，卸载&lt;/strong&gt;这5个阶段是&lt;strong&gt;按顺序开始&lt;/strong&gt;的，注意这里是只是说开始，实际上它们的执行过程是&lt;strong&gt;交叉进行&lt;/strong&gt;，相当于你按顺序执行了一个线程，线程里又执行了一个新的线程，如此往复的执行了5个，实际上它们是交叉执行的。&lt;/p&gt;
&lt;p&gt;  上面的&lt;strong&gt;箭头部分有误导倾向&lt;/strong&gt;，因为&lt;strong&gt;解析&lt;/strong&gt;这个过程，为了支持Java的运行时绑定机制，&lt;strong&gt;有些时候在初始化过程之后开始&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM(2):类文件结构（下）</title>
    <link href="http://yoursite.com/2017/11/29/JVM-2-Structure-of-class-file-II/"/>
    <id>http://yoursite.com/2017/11/29/JVM-2-Structure-of-class-file-II/</id>
    <published>2017-11-29T03:55:41.000Z</published>
    <updated>2017-12-03T13:47:56.162Z</updated>
    
    <content type="html"><![CDATA[<p>  如上篇文章所说，这篇文章我介绍一下类文件结构里比较复杂的<strong>属性表</strong>，属性列表这项数据可能存在于字段表，方法表，和类文件本身结构以及Code属性表中，我们可以 参照面的类C结构，来确认这一点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">类文件结构</div><div class="line">*/</div><div class="line">ClassFile &#123;</div><div class="line">    u4             magic;</div><div class="line">    u2             minor_version;</div><div class="line">    u2             major_version;</div><div class="line">    u2             constant_pool_count;</div><div class="line">    cp_info        constant_pool[constant_pool_count-1];</div><div class="line">    u2             access_flags;</div><div class="line">    u2             this_class;</div><div class="line">    u2             super_class;</div><div class="line">    u2             interfaces_count;</div><div class="line">    u2             interfaces[interfaces_count];</div><div class="line">    u2             fields_count;</div><div class="line">    field_info     fields[fields_count];</div><div class="line">    u2             methods_count;</div><div class="line">    method_info    methods[methods_count];</div><div class="line">    /*属性表*/</div><div class="line">    u2             attributes_count;</div><div class="line">    attribute_info attributes[attributes_count];</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*方法表（和字段表结构相同）*/</div><div class="line">field_info &#123;</div><div class="line">    u2             access_flags;</div><div class="line">    u2             name_index;</div><div class="line">    u2             descriptor_index;</div><div class="line">    /*属性表*/</div><div class="line">    u2             attributes_count;</div><div class="line">    attribute_info attributes[attributes_count];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>  属性表的结构要求比之class文件中的其他数据项要弱的多，其他数据项由于是完全按照偏移来确定的，所以顺序必须要是JVM规范给定的顺序，而这个属性表不一样，属性表相当于一种<strong>键值结构</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">attribute_info &#123;</div><div class="line">    u2 attribute_name_index;</div><div class="line">    u4 attribute_length;</div><div class="line">    u1 info[attribute_length];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  这个构造是属性表的基本构造，由于有很多种不同的属性表，所以对于第三个数据项这个info（相当于值），可能内部被划分为了很多个其他的数据项，现在我们暂时先放下这个疑问，上面我说属性表相当于一种键值结构，attribute_name_index相当于键，它指向了一个CONSTANT_Utf8_info结构，代表了这个属性的名字。</p>
<p>  有了这个键值的概念我们就不难理解为什么属性表并不需要按一定顺序排列每一个属性，因为JVM是按照这个attribute_name_index指向的名字来确定这个属性是什么属性，它的info的具体结构是怎么样的，所以你如果自己实现JVM和编译器，你可以自己定义属性名（不能与已有的属性重复），然后为了提供解析操作的实际代码，对于JVM来说，如果碰到它不认识的属性名，它就选择直接忽略了。</p>
<p>  JVM规范给出了一些预定义的属性，要求java虚拟机应当能识别这些属性，在<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7" target="_blank" rel="external">官方文档</a>（Java虚拟机规范 SE8）中，我们可以从4.7节得到所有的23项属性的详细信息。</p>
<p>首先我们来看看5项关乎到class文件能不能被JVM正确解释的属性:</p>
<h3 id="ConstantValue"><a href="#ConstantValue" class="headerlink" title="ConstantValue"></a>ConstantValue</h3><p>ConstantValue的作用是通知虚拟机自动为静态变量赋值（即被static属性标识的字段），只有被static标识的字段虚拟机才查看ConstantValue属性，否则即使有该属性也被忽略，静态变量其实有两种赋值方式：</p>
<p><strong>clinit赋值</strong></p>
<p>一种就是非常量型静态变量，如<code>static int k=1</code>，这种变量是在类加载的初始化阶段，执行clinit函数来进行赋值的，clinit函数是编译器自动生成的，赋值字节码指令已经被写在了里面。</p>
<p><strong>ConstantValue赋值</strong></p>
<p>对于如<strong>基本类型和String</strong>（其他引用类型不支持），如果字段被static和final同时修饰，这种情况在编译期你就可以确定它是哪个值了，所以直接生成ConstantValue属性来进行初始化（编译期）。</p>
<p>以上两种种赋值的条件差异是javac自行决定的，如果你自己实现一个编译器也可以对没有final修饰的static变量进行编译期初始化，JVM规范（SE 8）上是这么说的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">这段话里没有提到final字段，那么我们可以猜测javac对只有static修饰的字段，根本不生成ConstantValue属性</div><div class="line">*/</div><div class="line">If the ACC_STATIC flag in the access_flags item of the field_info structure is set, then the field represented by the field_info structure is assigned the value represented by its ConstantValue attribute as part of the initialization of the class or interface declaring the field (§5.5). This occurs prior to the invocation of the class or interface initialization method of that class or interface (§2.9). </div><div class="line">Otherwise, the Java Virtual Machine must silently ignore the attribute.</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ConstantValue_attribute &#123;</div><div class="line">    u2 attribute_name_index;</div><div class="line">    u4 attribute_length;</div><div class="line">    /*info部分*/</div><div class="line">    u2 constantvalue_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  具体你可以看到constantvalue_index是一个指向常量池的u2类型，而常量池中字面量常量只有基本类型和String，所以对于其他引用类型，你根本不可能用ConstantValue这种东西来定值。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>Code属性只<strong>可能</strong>存在于method_info中，抽象方法之类的没有方法体的当然就没有Code属性这种东西了，具体的code属性如下表所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">Code_attribute &#123;</div><div class="line">    u2 attribute_name_index;//固定指向值为Code的一个CONSTANT_Utf8_info</div><div class="line">    u4 attribute_length;</div><div class="line">    /*info部分*/</div><div class="line">    u2 max_stack;//操作数栈的最大深度</div><div class="line">    u2 max_locals;//局部变量表的存储空间，单位Slot(4个字节)</div><div class="line">    /*代码部分*/</div><div class="line">    u4 code_length;</div><div class="line">    u1 code[code_length];</div><div class="line">    /*显示异常处理表部分*/</div><div class="line">    u2 exception_table_length;</div><div class="line">    exception_info exception_table[exception_table_length];</div><div class="line">    /*属性表部分*/</div><div class="line">    u2 attributes_count;</div><div class="line">    attribute_info attributes[attributes_count];</div><div class="line">&#125;</div><div class="line"></div><div class="line">exception_info&#123;</div><div class="line">	u2 start_pc;</div><div class="line">	u2 end_pc;</div><div class="line">	u2 handler_pc;</div><div class="line">	u2 catch_type;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>字节码部分</strong></p>
<p>code_length和code[]一起构成了方法体被编译之后的字节码指令流,jvm的字节码指令是单字节的基于栈的字节码，单字节意思就是最多256条，目前只用了200多条，详细是怎么样的，我以后会写关于<strong>字节码执行引擎</strong>的文章，详细讨论这个问题。</p>
<p><strong>显示异常处理表部分</strong></p>
<p>显示异常处理表部分与try/catch语句有关，我们可以看到exception_info这个结构，指示了字节码从start_pc行到end_pc行（不包含），出现了catch_type类型或者其子类的话，就转跳到handler_pc行进行处理。</p>
<p><strong>属性表部分</strong></p>
<p>code中的属性表中的属性一般都是运行时非必须的，但这些熟悉往往会在程序员编程和调试时有着巨大的作用，比如我们编程时的方法的参数的参数名，或者调试时出现异常标识的异常出现的行号等等，主要有下面几种:</p>
<p>1.<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.12" target="_blank" rel="external">LineNumberTable</a>  //用于标识java代码中实际行号和字节码偏移量的对应关系</p>
<p>2.<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.13" target="_blank" rel="external">LocalVariableTable</a>  //用于描述局部变量表中变量与java源码中定义变量的对应关系</p>
<p>3.<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.14" target="_blank" rel="external">LocalVariableTypeTable</a>  //1.5引入泛型后用来代替LocalVariableTable</p>
<p>4.<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.4" target="_blank" rel="external">StackMapTable</a>    //用于做类加载阶段的类型验证，下面我们会详细介绍它。</p>
<p>以上属性的具体表现形式我已经表示了官方文档超链接，大家可以自己去看看，或者参考一下周志明的<a href="https://book.douban.com/subject/24722612/" target="_blank" rel="external">《深度理解java虚拟机》</a>，里面有一个简单的描述。</p>
<h3 id="StackMapTable"><a href="#StackMapTable" class="headerlink" title="StackMapTable"></a>StackMapTable</h3><p>如上面所说，StackMapTable是一个只会存在于Code中的属性，它是在jdk 1.6后被引入的，用于代替以前开销极大的通过数据流分析的类型推导。如果一个Code的属性表里不包含StackMapTable属性，那么虚拟机默认它包含了一个隐式的stack map attribute，相当于一个StackMapTable但是number_of_entries为0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">StackMapTable_attribute &#123;</div><div class="line">    u2              attribute_name_index;</div><div class="line">    u4              attribute_length;</div><div class="line">    u2              number_of_entries;</div><div class="line">    stack_map_frame entries[number_of_entries];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>每一个stack_map_frame都显示或者隐式的指明它所应用的字节码偏移量，以及该偏移量对应的一组局部变量和操作数栈项目的验证类型（Verifiacation Types）。</strong></p>
<p>我还是在这里详细说一下这个stack_map_frame，以及它内部可能会包含的标识验证类型的另一个结构verification_type_info,如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">这里用union标识的意思是这种结构是C语言中类似union的结构，就是说这里面的项目只会出现一项</div><div class="line">*/</div><div class="line">union stack_map_frame &#123;</div><div class="line">    same_frame;</div><div class="line">    same_locals_1_stack_item_frame;</div><div class="line">    same_locals_1_stack_item_frame_extended;</div><div class="line">    chop_frame;</div><div class="line">    same_frame_extended;</div><div class="line">    append_frame;</div><div class="line">    full_frame;</div><div class="line">&#125;</div><div class="line"></div><div class="line">union verification_type_info &#123;</div><div class="line">    Top_variable_info;</div><div class="line">    Integer_variable_info;</div><div class="line">    Float_variable_info;</div><div class="line">    Long_variable_info;</div><div class="line">    Double_variable_info;</div><div class="line">    Null_variable_info;</div><div class="line">    UninitializedThis_variable_info;</div><div class="line">    Object_variable_info;</div><div class="line">    Uninitialized_variable_info;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="verification-type-info"><a href="#verification-type-info" class="headerlink" title="verification_type_info"></a>verification_type_info</h4><p>verification_type_info用于指示一个或者两个<strong>位置</strong>（如果是64位类型则占2个slot）的类型，<strong>位置指的是一个局部变量或者一个操作数栈中的项目</strong>，验证类型就是用这个类似于union结构的verification_type_info来表示的，由一个单字节的tag来表示这个union里用的是哪一个项目，在tag后跟着零个或者多个字节，用来表示更多的信息。具体的union可能表示的项目有9个，我们这里列举几个，其余的你可以参考<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.4" target="_blank" rel="external">官方文档</a>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">如果verification_type_info中的tag是5，那么它指示对应位置的验证类型是null</div><div class="line">*/</div><div class="line">Null_variable_info &#123;</div><div class="line">    u1 tag = ITEM_Null; /* 5 */</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">/*</div><div class="line">如果tag是7,那么它表示该位置验证类型是由常量池的index为cpool_index的CONSTANT_Class_info结构指示的</div><div class="line">*/</div><div class="line">Object_variable_info &#123;</div><div class="line">    u1 tag = ITEM_Object; /* 7 */</div><div class="line">    u2 cpool_index;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">如果tag是8，则说明这个位置的验证类型还没有初始化，offset项目指示了包含该StackMapTable属性的Code的code数组中的偏移，该偏移对应的字节码是一个new指令，将会创建存储在该位置的对象</div><div class="line">*/</div><div class="line">Uninitialized_variable_info &#123;</div><div class="line">    u1 tag = ITEM_Uninitialized; /* 8 */</div><div class="line">    u2 offset;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">这里还存在一个Top_variable_info类型可能大家看名字也看不明白，我在这里说一下</div><div class="line">对于Long和Double这两种类型来说，他们是64位的，所以是占2个slot，那么他们该怎么确定类型呢？</div><div class="line">如果第一个位置是一个局部变量，那么</div><div class="line">它一定不是最大index的那个局部变量，它的下一个变量的验证类型是top</div><div class="line">如果第一个位置是一个操作数栈项目，那么</div><div class="line">它一定不是栈顶元素</div><div class="line">它上面的那个元素（更靠近栈顶的）的验证类型是top</div><div class="line">*/</div></pre></td></tr></table></figure>
<h4 id="stack-map-frame"><a href="#stack-map-frame" class="headerlink" title="stack_map_frame"></a>stack_map_frame</h4><p>  接下来我们来看一下stack_map_frame这个结构，中文就把它叫做<strong>栈映射帧</strong>，它同样是类似于union的，然后它也有一个单字节的frame_type数据项来指示这union到底表示的是哪一种项目,一共有7种可能上面已经列出来了。</p>
<p>  每一个<strong>栈映射帧</strong>都会依赖于前一个frame中的一些语义，第一个<strong>栈映射帧</strong>其实是隐式的，这个隐式的frame会被类型检查器（type checker）根据Code属性的所在的方法描述符给计算出来，在上面的entries[]中的0号元素其实是第二个,所以上面有提到过<code>如果一个Code的属性表里不包含StackMapTable属性，那么虚拟机默认它包含了一个隐式的stack map attribute，相当于一个StackMapTable但是number_of_entries为0。</code></p>
<p>  栈映射帧所用的字节码偏移是通过它里面指定的offset_delta计算出来的，并且offset_delta+1还会作为前个帧的字节码偏移，除非前一个帧是首帧（initial frame），这种情况下字节码偏移就是首帧指定的offset_delta。</p>
<p>  为什么使用<strong>偏移增量</strong>（即offset_delta），而不是存储实际的字节码偏移量，是因为根据定义，我们可以确保栈映射帧处于正确的排序顺序。</p>
<p>我这里同样拿出几种来介绍，其余的可以参考<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.4" target="_blank" rel="external">官方文档</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">当frame_type在0-63之间，就代表了这个frame中存储的是一个same_frame，它表明这个frame所代表的局部变量与前一个frame相同而且操作数栈为空，frame_type的数值就是offset_delta</div><div class="line">*/</div><div class="line">same_frame &#123;</div><div class="line">    u1 frame_type = SAME; /* 0-63 */</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">只有当fram_type为247的时候才确定类型为same_locals_1_stack_item_frame_extended，它表明这个frame所代表的局部变量与前一个frame相同而且操作数栈为空，但是明确给出了offset_delta，然后后面跟着类型数据项，上面我们已经介绍过了</div><div class="line">*/</div><div class="line">same_locals_1_stack_item_frame_extended &#123;</div><div class="line">    u1 frame_type = SAME_LOCALS_1_STACK_ITEM_EXTENDED; /* 247 */</div><div class="line">    u2 offset_delta;</div><div class="line">    verification_type_info stack[1];</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">这个类型中，它表明这个frame所代表的局部变量与前一个frame相同而且操作数栈为空，除非最后的k个局部变量缺失，k等于251-frame_type。</div><div class="line">*/</div><div class="line">chop_frame &#123;</div><div class="line">    u1 frame_type = CHOP; /* 248-250 */</div><div class="line">    u2 offset_delta;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h3><p>异常属性和上面code属性中提到的显示异常处理表不同，它指示了方法签名中throws后面标识的可能会抛出的异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Exceptions_attribute &#123;</div><div class="line">    u2 attribute_name_index;</div><div class="line">    u4 attribute_length;</div><div class="line">    u2 number_of_exceptions;</div><div class="line">    u2 exception_index_table[number_of_exceptions];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个属性比较简单，exception_index_table[]的每个u2项目都指向常量池中一个标识了异常类型的CONSTANT_Class_info型的常量。</p>
<h3 id="BootstrapMethods"><a href="#BootstrapMethods" class="headerlink" title="BootstrapMethods"></a>BootstrapMethods</h3><p>BootstrapMethods属性在jdk 1.7后增加，它仅存在于类文件属性表里，目的是为了保存invokedynamic指令引用的引导方法限定符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">BootstrapMethods_attribute &#123;</div><div class="line">    u2 attribute_name_index;</div><div class="line">    u4 attribute_length;</div><div class="line">    u2 num_bootstrap_methods;</div><div class="line">    bootstrap_method bootstrap_methods[num_bootstrap_methods];</div><div class="line">&#125;</div><div class="line"></div><div class="line">bootstrap_method&#123;   </div><div class="line">	u2 bootstrap_method_ref;//指向常量池中的一个CONSTANT_MethodHandle_info</div><div class="line">	u2 num_bootstrap_arguments;</div><div class="line">	u2 bootstrap_arguments[num_bootstrap_arguments];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>bootstrap_arguments[]中的每一个项目，都是对常量池中的以下几种结构之一的索引</p>
<p>1.CONSTANT_String_info, CONSTANT_Class_info<br>2.CONSTANT_Integer_info, CONSTANT_Long_info<br>3.CONSTANT_Float_info, CONSTANT_Double_info<br>4.CONSTANT_MethodHandle_info<br>5.CONSTANT_MethodType_info</p>
<p>然后我们来看看在Java平台下类关乎到文件能否正确解析的属性，一共有12个，这里我也说几个：</p>
<p>1.InnerClasses<br>2.EnclosingMethod<br>3.Synthetic<br>4.Signature<br>5.RuntimeVisibleAnnotations<br>6.RuntimeInvisibleAnnotations<br>7.RuntimeVisibleParameterAnnotations<br>8.RuntimeInvisibleParameterAnnotations<br>9.RuntimeVisibleTypeAnnotations<br>10.RuntimeInvisibleTypeAnnotations<br>11.AnnotationDefault<br>12.MethodParameters</p>
<h3 id="InnerClasses"><a href="#InnerClasses" class="headerlink" title="InnerClasses"></a>InnerClasses</h3><p>首先看看这个InnerClasses,看名字就知道，这个属性就是记录内部类的，准确来说它记录了内部类和宿主类之间的关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">InnerClasses_attribute &#123;</div><div class="line">    u2 attribute_name_index;</div><div class="line">    u4 attribute_length;</div><div class="line">    u2 number_of_classes;</div><div class="line">    inner_class_info classes[number_of_classes];</div><div class="line">&#125;</div><div class="line"></div><div class="line">inner_class_info&#123;   </div><div class="line">	u2 inner_class_info_index;</div><div class="line">	u2 outer_class_info_index;</div><div class="line">	u2 inner_name_index;</div><div class="line">    u2 inner_class_access_flags;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  对于inner_class_info来说，开始4个字节就是两个个指向常量池中某个CONSTANT_Class_info的常量索引，分别代表了内部类和宿主类的符号引用。</p>
<p>  inner_name_index是一个CONSTANT_Ut8_info常量索引，这个常量即内部类类名，如果是<strong>匿名内部类</strong>，则这项值为0，即没有引用任何常量（上一篇文章中说过这个问题）。</p>
<p>  最后的inner_class_access_flags是访问标志位，这个具体有哪些标志可以参考<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.6" target="_blank" rel="external">官方文档</a>。</p>
<h3 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h3><p>1.5之后，为了支持擦出法实现的伪泛型，jvm引入Singature。如果一个类型，接口，构造器，方法，或者字段（field）的声明中包含了类型变量或者参数化类型，则javac必须为他们添上signature属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Signature_attribute &#123;</div><div class="line">    u2 attribute_name_index;</div><div class="line">    u4 attribute_length;</div><div class="line">    u2 signature_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>signature_index是一个指向常量池CONSTANT_Utf8_info的符号引用，里面包含的字符串表示类，方法或者字段签名，具体取决于Signature属于哪个表结构，签名字符串的表述形式类似于我们上面介绍过的描述符，具体可以看<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.9.1" target="_blank" rel="external">官方文档</a>。</p>
<p>我们运用java的反射api可以获取到泛型的信息，实际上就是来源于Signature属性。</p>
<h3 id="MethodParameters"><a href="#MethodParameters" class="headerlink" title="MethodParameters"></a>MethodParameters</h3><p>最后我们来看看方法参数表,他只存在方法表(method_info)中，且每个方法表最多只能有一个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">MethodParameters_attribute &#123;</div><div class="line">    u2 attribute_name_index;</div><div class="line">    u4 attribute_length;</div><div class="line">    u1 parameters_count;</div><div class="line">    parameter_info parameters[parameters_count];</div><div class="line">&#125;</div><div class="line"></div><div class="line">parameter_info&#123;  </div><div class="line">	u2 name_index;</div><div class="line">	u2 access_flags;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于parameter_info来说</p>
<p>name_index是一个指向CONSTANT_Utf8_info的符号引用，它的值如果为0，那么表示这是一个无名的形参，如果非0则表示了一个<strong>有效的</strong>参数限定名称。</p>
<p>access_flags,有三种值</p>
<p>0x0010 (ACC_FINAL),这个大家都用过，表示这个参数是不可变的</p>
<p>另外两种可能大家没有接触过</p>
<p>0x1000 (ACC_SYNTHETIC)和 0x8000 (ACC_MANDATED)</p>
<p>ACC_SYNTHETIC表示这个参数不是由用户代码生成的，而是由比如编译器这样的东西加进去的，比如this这个参数。</p>
<p>ACC_MANDATED则表示这个形参是隐式声明在代码中的</p>
<p>还有6项属性不是运行时必须的，但是我们在编写代码时很多信息来源于他们：</p>
<p><strong>SourceFile</strong></p>
<p>  在类属性表，指定该类对应的源文件名</p>
<p><strong>SourceDebugExtension</strong></p>
<p>这个属性用于提供额外的调试信息，有些字节码的来源并不是.java文件，比如可以来自JSP，对于JSP的调试我们是无法通过但但从LineNumberTable来定位到JSP行号和堆栈的对应关系的，于是1.6后引入了该属性，以至于新的调试标准机制（JSR-45中定义）可以用它来作为调试信息。</p>
<p><strong>下面三个属性，我在介绍Code属性时已经说过了</strong></p>
<p><strong>LineNumberTable</strong><br><strong>LocalVariableTable</strong><br><strong>LocalVariableTypeTable</strong></p>
<p><strong>Deprecated</strong></p>
<p>  Deprecated指定某个类，字段或者方法不再推荐使用，即在源码中用@deprecated标识</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  如上篇文章所说，这篇文章我介绍一下类文件结构里比较复杂的&lt;strong&gt;属性表&lt;/strong&gt;，属性列表这项数据可能存在于字段表，方法表，和类文件本身结构以及Code属性表中，我们可以 参照面的类C结构，来确认这一点。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;/*&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;类文件结构&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;*/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ClassFile &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    u4             magic;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    u2             minor_version;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    u2             major_version;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    u2             constant_pool_count;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    cp_info        constant_pool[constant_pool_count-1];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    u2             access_flags;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    u2             this_class;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    u2             super_class;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    u2             interfaces_count;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    u2             interfaces[interfaces_count];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    u2             fields_count;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    field_info     fields[fields_count];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    u2             methods_count;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    method_info    methods[methods_count];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    /*属性表*/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    u2             attributes_count;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    attribute_info attributes[attributes_count];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;/*方法表（和字段表结构相同）*/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;field_info &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    u2             access_flags;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    u2             name_index;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    u2             descriptor_index;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    /*属性表*/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    u2             attributes_count;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    attribute_info attributes[attributes_count];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM (1):类文件结构（上）</title>
    <link href="http://yoursite.com/2017/11/25/JVM-1-Structure-of-class-file/"/>
    <id>http://yoursite.com/2017/11/25/JVM-1-Structure-of-class-file/</id>
    <published>2017-11-25T06:02:15.000Z</published>
    <updated>2017-11-28T07:26:55.867Z</updated>
    
    <content type="html"><![CDATA[<p>  <strong>平台无关性</strong>是Java语言最重要的特性之一，这个特性由<strong>字节码</strong>这种中间码作为虚拟机执行的文件载体被大家所认识，<strong>一次编译到处运行</strong>的这种<strong>平台无关性</strong>在一个学习者在刚刚学习编程而且选择的是Java语言时就会了解，但是随着学习者技术视野不断扩张，就会意识到jvm不是提供了java运行的平台，而是提供了字节码运行的平台，像Scala，Groovy，Ruby，Python等等语言通过他们自己的编译器，也可以编译成字节码从而在jvm平台上运行，即<strong>语言无关性</strong>。</p>
<p>  一个非凡的公司去设计一款非凡的程序平台，Java在诞生之初，JVM和Java语言的规范就是分开来的，JVM只关心Class文件里的字节码，并不关心它是怎么来的，你甚至可以用16进制编辑器自己写一份字节码，前提你对它的结构非常的清楚，你也可自己设计一门语言，然后让这门语言编译成字节码，运行在jvm平台上，以作为你的毕业设计或者开源项目。</p>
<a id="more"></a>
<h2 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h2><p>  上面一段中我提到过”一个非凡的公司去设计一款非凡的程序平台，Java在诞生之初，JVM和Java语言的规范就是分开来的”,你可能会怀疑句话，因为一个程序语言编译成一个中间载体，完成这个过程时就顺便实现了所谓的<strong>语言无关性</strong>。实际上高超的设计团队，并不会为了迎合某种语言的需求去设计一种中间载体，而是在这个中间载体的语义范围之内去设计一门能提高生产力的分工度的语言。</p>
<p>  一言蔽之：“<strong>字节码不是但但为了java而设计的，字节码有着比java更强大的语义</strong>”。比如对于函数重载，但但是返回值不同在java语言中是不能判定为不同函数的，但是在class文件中则不然，class文件中只要一个类中方法的描述字段不相同，那么他们就是两个方法。虽然在具体语言上实现这一语义，这会带来新的运行时的麻烦。</p>
<h2 id="Class文件"><a href="#Class文件" class="headerlink" title="Class文件"></a>Class文件</h2><p>  <strong>Class文件对应着唯一一个类或接口的定义信息</strong>，注意这里有几个重点，首先是<strong>唯一一个</strong>，第二是<strong>类或接口</strong>，第三点是<strong>定义信息</strong></p>
<p>  Class文件，并不一定是指磁盘上的具体文件，它也许是动态生成的比如由CGlib生成，也可能是一个JSP文件生成，也有可能是一段网络流直接读取到内存里，但是不管它怎么样来，这段字节流都符合jvm规范里定义的类的结构，它的基础单位就是字节，各个项目数据严格按照规范排列在这段字节数据中，没有空隙存在，也没有分隔符存在，如果一个数据项不能以8位字节来表示，那么就用若干个字节，以高位在前方式来表示。</p>
<p>  从高级语言编译成字节码的那一刻开始，<strong>在Class文件中每一个数据项都有它存在的意义</strong>，当并非都是运行时必须的，因为<strong>类的属性表（后面会介绍）</strong>要求更为宽泛一些，存在一些如LineNumberTable,LocalVariableTable这样的属性是用来帮助我们编程和调试期间能够确定错误行行号，以及避免局部变量显示的名称是arg0,arg1这样没有意义的符号。<strong>这些运行期不必要的数据项都可通过编译时使用特别的参数来拒绝生成</strong>，但是我建议不要这么做，因为会导致别人很难复用和审查你的代码。</p>
<p>  Class文件格式并不是键值型的（属性表内属性除外），对数据的区分完全是看顺序和偏移。</p>
<h3 id="Class文件的组成"><a href="#Class文件的组成" class="headerlink" title="Class文件的组成"></a>Class文件的组成</h3><p>  要搞清楚什么组成了Class文件，首先要清楚的明白宽泛的讲，Class文件里只有两种数据类型：</p>
<ol>
<li><p>基本数据类型：<strong>无符号数</strong>，包括了u1,u2,u4,u8几种分别代表了<strong>不同字节数的无符号数</strong>，这些无符号数用来描述<strong>数字</strong>和<strong>索引引用</strong>,并且可以按照<strong>缩略UTF-8</strong>来表示字符串。这里缩略和普通的UTF-8编码的具体区别大家可以看卡wiki上这段话：</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">The Unicode strings, despite the moniker &quot;UTF-8 string&quot;, are not actually encoded according to the Unicode standard, although it is similar. There are two differences (see UTF-8 for a complete discussion). The first is that the codepoint U+0000 is encoded as the two-byte sequence C0 80 (in hex) instead of the standard single-byte encoding 00. The second difference is that supplementary characters (those outside the BMP at U+10000 and above) are encoded using a surrogate-pair construction similar to UTF-16 rather than being directly encoded using UTF-8. In this case each of the two surrogates is encoded separately in UTF-8. For example, U+1D11E is encoded as the 6-byte sequence ED A0 B4 ED B4 9E, rather than the correct 4-byte UTF-8 encoding of F0 9D 84 9E.</div></pre></td></tr></table></figure>
</code></pre></li>
<li><p>复合数据类型：<strong>表</strong>，“表”可由<strong>其他表</strong>和<strong>无符号数</strong>组成，你可以把Class文件整个看成一张大表，里面有无符号数和许多小表，小表里又有小表，这些表设计者都以”_info”为结尾来命名，但是这些名称并不会体现在class文件里面，这里再次声明一遍，class文件格式没有键（属性表内属性除外）这种东西，完全是靠偏移来确定这个字段是什么，以及某个字段在哪里。</p>
</li>
</ol>
<p>整个Class文件结构如下表顺序所示：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u4</td>
<td>magic</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>minor_version</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>major_version</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>constant_pool_count</td>
<td>1</td>
</tr>
<tr>
<td>cp_info</td>
<td>constant_pool</td>
<td>constant_pool_count-1</td>
</tr>
<tr>
<td>u2</td>
<td>assess_flags</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>this_class</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>super_class</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces_count</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces</td>
<td>interface_count</td>
</tr>
<tr>
<td>u2</td>
<td>fields_count</td>
<td>1</td>
</tr>
<tr>
<td>field_info</td>
<td>fields</td>
<td>fields_count</td>
</tr>
<tr>
<td>u2</td>
<td>methods_count</td>
<td>1</td>
</tr>
<tr>
<td>method_info</td>
<td>methods</td>
<td>methods_count</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attributes_count</td>
</tr>
</tbody>
</table>
<p>下面我们来拆解这张表，但是我们把比较特别的attribute部分，也就是最后两行另外以一篇新的文章来讲。</p>
<h4 id="magic-minor-major-version"><a href="#magic-minor-major-version" class="headerlink" title="magic,minor/major_version"></a>magic,minor/major_version</h4><p>class文件打头的6个字节就是<strong>魔术</strong>，<strong>次版本号</strong>以及<strong>主版本号</strong>。</p>
<p><strong>魔术固定为：0xCAFEBABY</strong>，这个字段唯一的目的就是类加载时验证阶段确定这个类是不是一个class类</p>
<p><strong>次版本号</strong>和<strong>主板本号</strong>确定这个class文件所支持最低的JDK版本,高版本的JDK能向下兼容，如果JVM检测到版本标识超过了自己支持的版本，就拒绝执行。</p>
<p>比如，你把一个JDK7编译的class文件放到基于JDK6的项目中运行，就可能得到unsupporter major.minor 51.0异常。</p>
<p>jdk7的版本号即51，jdk的版本号是从45开始（1.0和1.1都是45，小版本号不同），1.2开始每一个大版本号加1，jdk1.2是46,1.6是50，1.8是52。</p>
<h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>接下来常量池，由于每个类中的常量不是固定的，所以这部分数据由2个部分组成</p>
<ol>
<li><p>constant_pool_count，它是一个数值量，用来指定常量词中包含了多少个常量，但<strong>这个数值量不是从0开始计数的，这点需要特别注意，它从1开始计数，1表示没有任何常量，2表示有1个常量</strong>，然后依次后推，至于为什么不从0开始，因为后面的一些表中的引用字段，可能会存在不指向任何常量的情况，这时候就用0做为引用对于常量池的偏移。</p>
</li>
<li><p>即  constant_pool_count-1个cp_info，cp_info是常量项的表结构，它有14种类型（截止jdk1.7），每种类型的常量项的表结构都不同，但是这种表结构的开头都是一个u1类型的tag字段，来指定不同的数值标识这个表结构是哪种类型。</p>
<p>这14种类型你可以查看wiki：<a href="https://en.wikipedia.org/wiki/Java_class_file,里面的The" target="_blank" rel="external">https://en.wikipedia.org/wiki/Java_class_file,里面的The</a> constant pool项目就很清楚的说明了14种类型以及他们对应的tag的值。</p>
<p>比如对于其中的一种CONSTANT_Class_info表结构：</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u1</td>
<td>tag</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>   这里的tag的值肯定是0x07,标识它的类型为CONSTANT_Class_info，接下来name_index标识了一个索引值，该值指向的是一个常量词中的CONSTANT_Utf8_info结构，这个结构中有该类的全限定名字符串。现在我们来看看这种结构：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u1</td>
<td>tag</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>length</td>
<td>1</td>
</tr>
<tr>
<td>u1</td>
<td>bytes</td>
<td>length</td>
</tr>
</tbody>
</table>
<p>   对应于CONSTANT_Utf8_info的tag值为0x01,然后有一个16位数指定这个utf-8字符串所占的字节数，所以你可以推测一下你在java里直接以赋值形式构造一个所需空间大于64k的数是不可能的，接下来就是一个<strong>缩略utf-8编码</strong>所代表的字符串的字节流了，它的长度是上面给定的length。</p>
<h4 id="访问标志位"><a href="#访问标志位" class="headerlink" title="访问标志位"></a>访问标志位</h4><p>接下来一个u2类型的access_flags字段标识这个类的访问标志位，用来表示该类是不是被abstract等关键字修饰，是不是一个注解或者接口，是否是用户代码产生，是否是一个枚举类型等等，我们知道访问标志只有有和没有的区别，于是一个u2的每一位就代表了一种访问标志有还是没有，一个u2字段可以代表16种标志位，但是实际上只用了其中的8个。</p>
<p>你可以从<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4" target="_blank" rel="external">官方文档</a>，里的4.1小结查看这些标志位的具体信息，这个文档是Java se8的。</p>
<h4 id="this-class-super-class-interface索引集合"><a href="#this-class-super-class-interface索引集合" class="headerlink" title="this_class,super_class,interface索引集合"></a>this_class,super_class,interface索引集合</h4><table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u2</td>
<td>this_class</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>super_class</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces_count</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces</td>
<td>interface_count</td>
</tr>
</tbody>
</table>
<p>   ​    它们通通指向的一个常量词中类型为CONSTANT_Class_info的常量，我们上面介绍过这个常量的具体结构，它有一个name_index指向一个CONSTANT_Utf8_info常量，这个常量中包含了一段字符串，具体在这里这段字符串是完整的类名。诸如：java/lang/Object。</p>
<p>   ​    在java中除了Object外，所有的类都有父类，字节码中表现也是一样的。</p>
<h4 id="字段和方法表集合"><a href="#字段和方法表集合" class="headerlink" title="字段和方法表集合"></a>字段和方法表集合</h4><table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u2</td>
<td>field_count</td>
<td>1</td>
</tr>
<tr>
<td>field_info</td>
<td>fields</td>
<td>fields_count</td>
</tr>
<tr>
<td>u2</td>
<td>methods_count</td>
<td>1</td>
</tr>
<tr>
<td>method_info</td>
<td>methods</td>
<td>methods_count</td>
</tr>
</tbody>
</table>
<p>   字段表和方法表的结构每个字段的功能上几乎一样，<strong>但是实际上在access_flags的取值上是不同的，另外在属性表中它们也可能有不同的属性</strong>。表结构如下：</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">这里只列出了方法表其实字段表和它一模一样，只是位置一前一后，从而vm可以判断出谁是方法表，谁是字段表</div><div class="line">*/</div><div class="line">method_info &#123;</div><div class="line">    u2             access_flags;</div><div class="line">    u2             name_index;</div><div class="line">    u2             descriptor_index;</div><div class="line">    u2             attributes_count;</div><div class="line">    attribute_info attributes[attributes_count];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>   1.访问位：不再赘述，和类的访问位功能和形式上差不多，具体有哪些访问位可以参考<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4" target="_blank" rel="external">官方文档</a></p>
<p>   中4.5和4.6小结查看。</p>
<p>   2.name_index指向一个常量CONSTANT_Utf8_info，标识了方法或者字段名的<strong>简单名称</strong>，这里的简单名称指的是没有类型和参数修饰的名称，比如”inc()”-&gt;”inc”</p>
<p>   3.descriptor_index描述字段，这个字段有点复杂</p>
<p><strong>字段的描述：</strong></p>
<pre><code>首先对于除了long基本类型和void，都用首字符的大写来表示，比如void-&gt;V,int-&gt;I,double-&gt;D,long用J表示。
</code></pre><p>   ​    为什么long用J表示的原因是因为所有引用类型都用L作为开头表示，引用类型表示的方式为L+类型权限定名，比如对于java.lang.Object-&gt;Ljava/lang/Object</p>
<p>   ​    对于数组一个维度就在类型符号面前加一个[,比如对于int[]-&gt;[I,对于String[][]-&gt;[[Ljava/lang/String。</p>
<p><strong>方法的描述</strong></p>
<p>   ​    有了上面的基础，我们可以来介绍一下方法的descriptor_index字段，对于方法</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object m(int i, double d, Thread t) &#123;...&#125;</div></pre></td></tr></table></figure>
<p>   编译器把它转换为一个描述为：</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(IDLjava/lang/Thread;)Ljava/lang/Object;</div></pre></td></tr></table></figure>
<p>   可以看到即使是在java中<strong>不能重载的同名同方法表不同返回值的方法</strong>实际上它们的描述符是不同的，实际上在class类中，这种<strong>不能重载的同名同方法表不同返回值的方法</strong>是可以存在的，但是运行期如何判断无接受值的方法调用到底调用的是什么方法呢?这是个巨大的问题。</p>
<p>   方法表和属性表中都不会列出从父类继承来的方法和字段，除非是自己在代码里重写了，但是会有你用javap去解析一个class文件时可能会发现没有在你代码里出现过的方法出现在了方法和字段表里，比如\<init>和\<clinit>方法，它们是实例的构造器和类的构造器，再比如对于内部类，我们可以访问外部类的字段和方法，编译器会直接给我们在内部类属性表插一个指向外部类实例的字段。</clinit></init></p>
<p>   <strong>就如我上面所说，对于类，方法和字段三种表中都存在的属性表，我在下篇文章介绍，这个表比较复杂，也能解开你包括，java里方法代码去哪儿了，被设为常量的类变量的赋值的值去哪儿了的疑问。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  &lt;strong&gt;平台无关性&lt;/strong&gt;是Java语言最重要的特性之一，这个特性由&lt;strong&gt;字节码&lt;/strong&gt;这种中间码作为虚拟机执行的文件载体被大家所认识，&lt;strong&gt;一次编译到处运行&lt;/strong&gt;的这种&lt;strong&gt;平台无关性&lt;/strong&gt;在一个学习者在刚刚学习编程而且选择的是Java语言时就会了解，但是随着学习者技术视野不断扩张，就会意识到jvm不是提供了java运行的平台，而是提供了字节码运行的平台，像Scala，Groovy，Ruby，Python等等语言通过他们自己的编译器，也可以编译成字节码从而在jvm平台上运行，即&lt;strong&gt;语言无关性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;  一个非凡的公司去设计一款非凡的程序平台，Java在诞生之初，JVM和Java语言的规范就是分开来的，JVM只关心Class文件里的字节码，并不关心它是怎么来的，你甚至可以用16进制编辑器自己写一份字节码，前提你对它的结构非常的清楚，你也可自己设计一门语言，然后让这门语言编译成字节码，运行在jvm平台上，以作为你的毕业设计或者开源项目。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Junit(2):使用Hamcrest断言</title>
    <link href="http://yoursite.com/2017/10/29/Junit-2-Assert-by-Hamcrest/"/>
    <id>http://yoursite.com/2017/10/29/Junit-2-Assert-by-Hamcrest/</id>
    <published>2017-10-29T07:32:43.000Z</published>
    <updated>2017-10-31T08:51:02.767Z</updated>
    
    <content type="html"><![CDATA[<p>  上一篇文章中，我们以几个简单的用例测试来开篇，以assertTure,assertEquals这样的简单形式来作断言，这些方法都是org.junit.Assert来提供，如果你用的是maven或者其他的项目构建工具来引入junit包，我们会发现，它居然依赖于一个org.hamcrest的项目包，实际上，如果涉及到比较复杂的断言，我们以junit需要写一大串代码，这让我们的测试代码非常不美观，这个叫做hamcrest提供了一套断言工具，而且该项目还有ruby等等语言的版本，他们返回一个org.hamcrest.Matcher的子类，另外在org.hamcrest.MatcherAssert中提供了一套assertThat方法，它接受一个org.hamcrest.Matcher和一个计算值，从而做出该值是否符合该Matcher的判断。</p>
<p>  在org.junit.Assert类中也有assertThat方法，不过它其实就是包装了一下MatcherAssert中的assertThat。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">assertThat</span><span class="params">(String reason, T actual,</span></span></div><div class="line">        Matcher&lt;? <span class="keyword">super</span> T&gt; matcher) &#123;</div><div class="line">    MatcherAssert.assertThat(reason, actual, matcher);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="常用的比较"><a href="#常用的比较" class="headerlink" title="常用的比较"></a>常用的比较</h2><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><h4 id="anything"><a href="#anything" class="headerlink" title="anything"></a>anything</h4><p>anything会返回一个匹配任意值（包括null）的matchers，如果一个值可以是任何预期，你可以用anything来做断言</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anythingMatchersTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    Calculate calculate = <span class="keyword">new</span> Calculate();</div><div class="line">    assertThat(calculate, anything());</div><div class="line">    assertThat(<span class="keyword">null</span>, anything(<span class="string">"hello world"</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="is"><a href="#is" class="headerlink" title="is"></a>is</h4><p>is匹配两个值是否相等（equals），经常做equalsTo的简写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isMatchersTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    assertThat(<span class="string">"hello world"</span>, is(<span class="string">"hello world"</span>));</div><div class="line">    assertThat(<span class="keyword">new</span> String[] &#123;<span class="string">"floor"</span>, <span class="string">"bank"</span>&#125;, is(<span class="keyword">new</span> String[] &#123;<span class="string">"floor"</span>, <span class="string">"bank"</span>&#125;));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>####describedsAs</p>
<p>包装一个Matchers，其中的三个参数：</p>
<p>description:作为包装后的Matchers的失败描述</p>
<p>matcher:要包装的matchers</p>
<p>valus:选择性插入值,它会被插入到description标识的数字占位符处，该参数不允许为null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; org.hamcrest.<span class="function">Matcher&lt;T&gt; <span class="title">describedAs</span><span class="params">(java.lang.String description, org.hamcrest.Matcher&lt;T&gt; matcher, java.lang.Object... values)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> org.hamcrest.core.DescribedAs.&lt;T&gt;describedAs(description, matcher, values);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>比如如下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">describedsAsMatchersTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    Calculate calculate = <span class="keyword">new</span> Calculate();</div><div class="line">    Calculate calculate1 = <span class="keyword">new</span> Calculate();</div><div class="line">    assertThat(calculate1, describedAs(<span class="string">"hello world %0,%1"</span>,is(calculate),<span class="keyword">new</span> String[]&#123;<span class="string">"saul"</span>,<span class="string">"xin"</span>&#125;));</div><div class="line">    <span class="comment">//当然你也可以这样传入多值参数</span></div><div class="line">    <span class="comment">//assertThat(calculate1, describedAs("hello world %0,%1",is(calculate),"saul","xin");</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试：</p>
<p><img src="\img\QQ图片20171029180301.png" alt="QQ图片20171029180301"></p>
<h3 id="逻辑比较"><a href="#逻辑比较" class="headerlink" title="逻辑比较"></a>逻辑比较</h3><h4 id="allOf"><a href="#allOf" class="headerlink" title="allOf"></a>allOf</h4><p><img src="\img\QQ图片20171029221453.png" alt="QQ图片20171029221453"></p>
<p>allOf在hamcrest相当于与操作，如下对于”hello world”验证它是否同时符合以下两个Matchers，显然是符合的，allOf有多个重写，接受的参数是一个可变的Matchers列表，或者一个Matchers的迭代器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">allOfTest</span><span class="params">()</span></span>&#123;</div><div class="line">    assertThat(<span class="string">"hello world"</span>,allOf(endsWith(<span class="string">"ld"</span>),startsWith(<span class="string">"hello"</span>)));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="anyOf"><a href="#anyOf" class="headerlink" title="anyOf"></a>anyOf</h4><p>anyOf和allOf类似，相当于或操作，既然类似当然它们的参数表也是类似了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anyOfTest</span><span class="params">()</span></span>&#123;</div><div class="line">    assertThat(<span class="string">"hello world"</span>,anyOf(endsWith(<span class="string">"mld"</span>),startsWith(<span class="string">"hello"</span>)));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="not"><a href="#not" class="headerlink" title="not"></a>not</h4><p>not表否定，可以接受一个Matchers或者一个值，返回一个Matchers，表示非逻辑，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notTest</span><span class="params">()</span></span>&#123;</div><div class="line">    assertThat(<span class="string">"hello world"</span>,not(<span class="string">"Hello world"</span>));</div><div class="line">    assertThat(<span class="string">"hello world"</span>,not(allOf(endsWith(<span class="string">"mld"</span>),startsWith(<span class="string">"hello"</span>))));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="equalTo"><a href="#equalTo" class="headerlink" title="equalTo"></a>equalTo</h4><p>检测两个值是否相等，equals判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">equalToTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    String k=<span class="string">"hello world"</span>;</div><div class="line">    String s=<span class="keyword">new</span> String(<span class="string">"hello world"</span>);</div><div class="line">    assertThat(k,equalTo(s));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="hasToString"><a href="#hasToString" class="headerlink" title="hasToString"></a>hasToString</h4><p>测试某个对象的toString方法的返回值是否符合某个Matchers或等于某个值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hasToStringTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    assertThat(<span class="keyword">new</span> Integer(<span class="number">1</span>), hasToString(<span class="string">"1"</span>));</div><div class="line">    assertThat(<span class="keyword">new</span> Integer(<span class="number">1</span>), hasToString(endsWith(<span class="string">"1"</span>)));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="instanceOf"><a href="#instanceOf" class="headerlink" title="instanceOf"></a>instanceOf</h4><p>判断某个对象是否是某种类型的实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">instanceOfTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    assertThat(<span class="keyword">new</span> Integer(<span class="number">1</span>), instanceOf(Number.class));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="isCompatibleType"><a href="#isCompatibleType" class="headerlink" title="isCompatibleType"></a>isCompatibleType</h4><p>测试一个类是否是可兼容另一个类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isCompatibleTypeTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    assertThat(Integer.class, typeCompatibleWith(Number.class));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="notNullValue"><a href="#notNullValue" class="headerlink" title="notNullValue"></a>notNullValue</h4><p>检测一个值是否不为null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notNullValueTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    assertThat(<span class="keyword">null</span>, not(notNullValue()));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="nullValue"><a href="#nullValue" class="headerlink" title="nullValue"></a>nullValue</h4><p>检测一个值是否为null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nullValueTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    assertThat(<span class="keyword">null</span>, nullValue());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="sameInstance"><a href="#sameInstance" class="headerlink" title="sameInstance"></a>sameInstance</h4><p>检测两个对象是否相同,==判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sameInstanceTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    String k=<span class="string">"hello"</span>;</div><div class="line">    String s=<span class="string">"hello"</span>;</div><div class="line">    assertThat(s,sameInstance(k));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="hasProperty"><a href="#hasProperty" class="headerlink" title="hasProperty"></a>hasProperty</h4><p>判断一个Bean对象是否有某个属性，这个Matchers会使用get方法来判断，没有get方法就是没有该属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hasPropertyTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    User user = <span class="keyword">new</span> User();</div><div class="line">    assertThat(user, hasProperty(<span class="string">"name"</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h4 id="array"><a href="#array" class="headerlink" title="array"></a>array</h4><p>生成一个Machers，其包含一组Machers，接着对一个数组进行遍历匹配，每个元素匹配他们的对应位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">arrayTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    String ls[] = &#123;<span class="string">"hello"</span>, <span class="string">"world"</span>, <span class="string">"love"</span>, <span class="string">"bcd"</span>&#125;;</div><div class="line">    assertThat(ls, array(startsWith(<span class="string">"hel"</span>), startsWith(<span class="string">"wor"</span>), startsWith(<span class="string">"lo"</span>), endsWith(<span class="string">"d"</span>)));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="hasEntry-hasKey-hasValue"><a href="#hasEntry-hasKey-hasValue" class="headerlink" title="hasEntry,hasKey,hasValue"></a>hasEntry,hasKey,hasValue</h4><p>返回一个Matchers，匹配键值对</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MapTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</div><div class="line">    map.put(<span class="string">"name"</span>, <span class="string">"tom"</span>);</div><div class="line">    assertThat(map, hasEntry(<span class="string">"name"</span>, <span class="string">"tom"</span>));</div><div class="line">    assertThat(map, hasEntry(startsWith(<span class="string">"nam"</span>), endsWith(<span class="string">"om"</span>)));</div><div class="line">    assertThat(map, hasKey(<span class="string">"name"</span>));</div><div class="line">    assertThat(map, hasValue(endsWith(<span class="string">"om"</span>)));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="hasItem-hasItems-hasItemInArray"><a href="#hasItem-hasItems-hasItemInArray" class="headerlink" title="hasItem,hasItems,hasItemInArray"></a>hasItem,hasItems,hasItemInArray</h4><p>返回一个Mathers，对集合中的每一个元素进行匹配，要求至少有一个元素满足给定条件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ItemTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</div><div class="line">    set.add(<span class="string">"some"</span>);</div><div class="line">    set.add(<span class="string">"one"</span>);</div><div class="line">    set.add(<span class="string">"in here"</span>);</div><div class="line">    assertThat(set, hasItem(startsWith(<span class="string">"some"</span>)));</div><div class="line">    assertThat(set, hasItems(anyOf(startsWith(<span class="string">"can"</span>), endsWith(<span class="string">"here"</span>))));</div><div class="line">    assertThat(set.toArray(<span class="keyword">new</span> String[]&#123;&#125;), hasItemInArray(startsWith(<span class="string">"so"</span>)));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><h4 id="近似值匹配"><a href="#近似值匹配" class="headerlink" title="近似值匹配"></a>近似值匹配</h4><p> 匹配某个值是否在误差允许的范围内接近一个精确值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeToTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    assertThat(<span class="number">5.3</span>, closeTo(<span class="number">5</span>, <span class="number">0.3</span>));</div><div class="line">    BigDecimal bigDecimal = <span class="keyword">new</span> BigDecimal(<span class="string">"99999999999999999999999999999999999999"</span>);</div><div class="line">    BigDecimal error = <span class="keyword">new</span> BigDecimal(<span class="number">0.001</span>);</div><div class="line">    assertThat(<span class="keyword">new</span> BigDecimal(<span class="string">"99999999999999999999999999999999999999.0009"</span>), closeTo(bigDecimal, error));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="大小匹配"><a href="#大小匹配" class="headerlink" title="大小匹配"></a>大小匹配</h4><p> 返回一个Matchers做值的大小匹配</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compareToTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    assertThat(<span class="number">5</span>, greaterThan(<span class="number">4</span>));</div><div class="line">    assertThat(<span class="number">5</span>, lessThan(<span class="number">6</span>));</div><div class="line">    assertThat(<span class="number">5</span>, greaterThanOrEqualTo(<span class="number">5</span>));</div><div class="line">    assertThat(<span class="number">4</span>, lessThanOrEqualTo(<span class="number">4</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stringTest</span><span class="params">()</span></span>&#123;</div><div class="line">    assertThat(<span class="string">"jay"</span>,equalTo(<span class="string">"jay"</span>));</div><div class="line">    assertThat(<span class="string">"hello"</span>,equalToIgnoringCase(<span class="string">"HelLO"</span>));</div><div class="line">    <span class="comment">//忽略头尾所有空白字符和空字符，且非头尾空白字符，空字符都认为是1个空白字符进行匹配</span></div><div class="line">    <span class="comment">//"helloworld"匹配"  helloworld"和"helloworld  "，但是不匹配"hello world"，因为非头尾空白字符总被认为是一个需要匹配的空字符或空白字符</span></div><div class="line">    assertThat(<span class="string">"hello  wor\nld"</span>,equalToIgnoringWhiteSpace(<span class="string">"  \t\bhello wor  ld    "</span>));</div><div class="line">    assertThat(<span class="string">"hello"</span>,startsWith(<span class="string">"hel"</span>));</div><div class="line">    assertThat(<span class="string">"name"</span>,endsWith(<span class="string">"me"</span>));</div><div class="line">    assertThat(<span class="string">"hello world!"</span>,containsString(<span class="string">"!"</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  上一篇文章中，我们以几个简单的用例测试来开篇，以assertTure,assertEquals这样的简单形式来作断言，这些方法都是org.junit.Assert来提供，如果你用的是maven或者其他的项目构建工具来引入junit包，我们会发现，它居然依赖于一个org.hamcrest的项目包，实际上，如果涉及到比较复杂的断言，我们以junit需要写一大串代码，这让我们的测试代码非常不美观，这个叫做hamcrest提供了一套断言工具，而且该项目还有ruby等等语言的版本，他们返回一个org.hamcrest.Matcher的子类，另外在org.hamcrest.MatcherAssert中提供了一套assertThat方法，它接受一个org.hamcrest.Matcher和一个计算值，从而做出该值是否符合该Matcher的判断。&lt;/p&gt;
&lt;p&gt;  在org.junit.Assert类中也有assertThat方法，不过它其实就是包装了一下MatcherAssert中的assertThat。如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;assertThat&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String reason, T actual,&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Matcher&amp;lt;? &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; T&amp;gt; matcher) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    MatcherAssert.assertThat(reason, actual, matcher);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="软件测试" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
      <category term="TDD" scheme="http://yoursite.com/tags/TDD/"/>
    
      <category term="Junit" scheme="http://yoursite.com/tags/Junit/"/>
    
  </entry>
  
  <entry>
    <title>Junit(1):开始我们的单元测试之旅!</title>
    <link href="http://yoursite.com/2017/10/27/Junit-1-Start-our-testing-travel/"/>
    <id>http://yoursite.com/2017/10/27/Junit-1-Start-our-testing-travel/</id>
    <published>2017-10-27T09:52:55.000Z</published>
    <updated>2017-10-28T07:15:16.104Z</updated>
    
    <content type="html"><![CDATA[<p>  作为一名程序员，虽然你可能不是测试岗，但是懂得测试是必须的，这一个系列的文章用来记录一些Junit的测试方法，首先从实现自动化测试开始，然后衍生到stub和mock测试，再来进行我们的web应用的测试和数据库的测试。当然测试并不只包含这些内容，这里只是其中的一小块，有兴趣的同学可以继续开展。</p>
<p>  写这个系列的文章的目的在于，由于我未来工作的公司，是结对编程，有时候我需要去在伙伴写业务代码的时候写测试代码，不过我认为，既然软件测试在软件工程课程中是基础课，那么每一个程序员都应该懂得一定的测试手段，再者写下这套文章，有利于我从新复习java的单元测试手段，当然这些手段在未来，即使是换一种语言，也会是通用的知识。这篇文章中所用的junit版本都是junit4,用注解来标识一些测试声明，而且测试类不再需要继承TestCase,也不需要遵循它的测试方法命名规则，我们可以把测试方法命名的的更加直观。</p>
<a id="more"></a>
<h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>  可能很多情况下，我们会把@Test标识的方法作为一个主方法来使用，如果在没有专门测试的项目中，你可能会使用sysout插桩，然后用一个个去查看输入输出是不是和你内心预期的相同来检验我们的代码是不是存在某些问题。</p>
<p>  如果有成百上千个方法需要测试，而每一个方法都需要覆盖到它所有的分支，我们就不能再用上面提到过的原始方式来对测试用例的结果进行判断了。在以@Test标识的测试用例，我们引入断言的方式来对我们的预期结果和实际结果的匹配进行判断，如果断言验证预期和实际不同则该用例执行时就会标红，这样其实我们的测试代码就和实际的业务代码分离了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> services;</div><div class="line"></div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.junit.Before;</div><div class="line"><span class="keyword">import</span> org.junit.Test;</div><div class="line"><span class="keyword">import</span> xin.saul.app.services.Calculate;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculateTest</span> </span>&#123;</div><div class="line">    Calculate calculate;</div><div class="line"></div><div class="line">    <span class="meta">@Before</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">        calculate = <span class="keyword">new</span> Calculate();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTest</span><span class="params">()</span> </span>&#123;</div><div class="line">        assertEquals(<span class="number">3</span>, calculate.add(<span class="number">1</span>, <span class="number">2</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">minusTest</span><span class="params">()</span> </span>&#123;</div><div class="line">        assertEquals(-<span class="number">1</span>, calculate.minus(<span class="number">1</span>, <span class="number">2</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiplyTest</span><span class="params">()</span> </span>&#123;</div><div class="line">        assertEquals(<span class="number">2</span>, calculate.multiply(<span class="number">1</span>, <span class="number">2</span>));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">divideTest</span><span class="params">()</span> </span>&#123;</div><div class="line">        assertEquals(<span class="number">2</span>, calculate.divide(<span class="number">4</span>, <span class="number">2</span>));</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="\img\QQ图片20171028140338.png" alt="QQ图片20171028140338"></p>
<p>  从上面可以看到，我的测试用例都通过了断言，当然些测试用例是不完备的，它没有覆盖到我们有可能输入的所有情况，或者我给定的输入没有覆盖到被测试方法的所有分支。</p>
<p>  当然如果我们的项目是一个maven项目我们可以用mvn test来进行测试。比如对于该项目mvn test输出如下报告，当然如果你对maven熟悉你可以去详细看其生成的测试报告，它在<strong>target-&gt;surefire-reports</strong>文件夹。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">-------------------------------------------------------</div><div class="line"> T E S T S</div><div class="line">-------------------------------------------------------</div><div class="line">Running services.CalculateTest</div><div class="line">Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.042 sec</div><div class="line"></div><div class="line">Results :</div><div class="line"></div><div class="line">Tests run: 4, Failures: 0, Errors: 0, Skipped: 0</div></pre></td></tr></table></figure>
<h2 id="异常测试"><a href="#异常测试" class="headerlink" title="异常测试"></a>异常测试</h2><p>  现在我们对这个项目做一些小小的改变，我们加一个用例来测试:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">arithmeticExceptionTest</span><span class="params">()</span> </span>&#123;</div><div class="line">	calculate.divide(<span class="number">4</span>, <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  你可以知道这个方法用例明显是会抛出一个ArithmeticException的</p>
<p><img src="\img\QQ图片20171028141519.png" alt="QQ图片20171028141519"></p>
<p>  我们可以看到，正如我们所料，新加的测试用例直接抛出了异常，直觉告诉我们这肯定是不符合标准的，测试是要有预期的，对异常的预期也是一种预期，实际上我们可以测试在某种情况下会抛出某种异常。<strong>这需要我们添加@Test注解的一个属性–expected,它接受一个Throwable的子类型来作为预期的异常，默认值是一个定义在Test中的静态类型None，标识预期不抛出任何异常。</strong>如果你定义的一个预期的异常，但是实际运行过程中并没有抛出该异常，不会标红，但是会标黄，并提示没有抛出该异常，实际上这样测试用例依然是没有通过测试，会抛出一个<strong>java.lang.AssertionError</strong>，比如如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 异常测试</div><div class="line"> */</div><div class="line">@Test(expected = ArithmeticException.class)</div><div class="line">public void arithmeticExceptionTest() &#123;</div><div class="line">    calculate.divide(4, 1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="\img\QQ图片20171028142613.png" alt="QQ图片20171028142613"></p>
<p>Maven中你会得到如下的报告：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">-------------------------------------------------------</div><div class="line"> T E S T S</div><div class="line">-------------------------------------------------------</div><div class="line">Running services.CalculateTest</div><div class="line">Tests run: 6, Failures: 1, Errors: 0, Skipped: 0, Time elapsed: 1.047 sec &lt;&lt;&lt; FAILURE!</div><div class="line">arithmeticExceptionTest(services.CalculateTest)  Time elapsed: 0.004 sec  &lt;&lt;&lt; FAILURE!</div><div class="line">java.lang.AssertionError: Expected exception: java.lang.ArithmeticException</div><div class="line">...(省略异常栈内容)</div><div class="line">Results :</div><div class="line"></div><div class="line">Failed tests:   arithmeticExceptionTest(services.CalculateTest): Expected exception: java.lang.ArithmeticException</div><div class="line"></div><div class="line">Tests run: 6, Failures: 1, Errors: 0, Skipped: 0</div></pre></td></tr></table></figure>
<h2 id="时间预期测试"><a href="#时间预期测试" class="headerlink" title="时间预期测试"></a>时间预期测试</h2><p>  业务量大了以后，或者涉及到复杂的算法或线程，我们需要在给定的时间之类测试我们的业务是否能完成，比如我们需要每次正常查询数据库的时间都在10毫秒之内，当然由于服务器资源是有限的，我们的测试并不完备，我们做时间的单元测试并没有考虑到可能会有服务器过载的情况导致运行时间的拉长，但是我们可以考虑一个比较合理的时间（更短），来中和掉这些误差，比如一个业务在70ms正常内完成是被允许的，但是在服务器过载的情况下需要100ms，我们可以将测试的时间预期压缩到30毫秒，以要求开放人员设计出的算法能够达到这个水平，以至于即使在服务器过载情况下，我们也能在时间允许的范围内完成大多数业务请求。</p>
<p>  引入时间测试的另一个理由是，<strong>junit并非是多线程去运行每一个测试用例的，而是按顺序往下执行</strong>，所以我们如果某个业务很耗时（比如一个或多个网络请求），或者直接就阻塞了，严重影响我们的自动化测试过程，所以如果超时我们就直接报错，把这部分代码的问题提交给开发人员去处理。</p>
<p>  我们需要引入@Test注解的另一个属性timeout,它接受一个long类型，默认值是0L，表示不考虑最大等待时间。</p>
<p>  我们在我们的单元测试类中引入一个新方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 时间测试</div><div class="line"> */</div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timeoutTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Thread.sleep(<span class="number">100000</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    calculate.divide(<span class="number">4</span>, <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>你可以预料到这个方法要注释100秒之久，在这个过程中，还没执行的测试用例都得不到测试。</p>
<p><img src="\img\QQ图片20171028145933.png" alt="QQ图片20171028145933"></p>
<p>现在我们加入timeout属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 时间测试</div><div class="line"> */</div><div class="line"><span class="meta">@Test</span>(timeout = <span class="number">1000</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">timeoutTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Thread.sleep(<span class="number">100000</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">    calculate.divide(<span class="number">4</span>, <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在可以看到，阻塞一秒之后并没有等到任务完成，我们的代码直接报错了，用例没有在预期时间类完成，这该线程会被interrupted，你可以知道线程会抛出一个异常打断sleep，从而让测试继续往下执行。<br><img src="\img\QQ图片20171028150227.png" alt="QQ图片20171028150227"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  作为一名程序员，虽然你可能不是测试岗，但是懂得测试是必须的，这一个系列的文章用来记录一些Junit的测试方法，首先从实现自动化测试开始，然后衍生到stub和mock测试，再来进行我们的web应用的测试和数据库的测试。当然测试并不只包含这些内容，这里只是其中的一小块，有兴趣的同学可以继续开展。&lt;/p&gt;
&lt;p&gt;  写这个系列的文章的目的在于，由于我未来工作的公司，是结对编程，有时候我需要去在伙伴写业务代码的时候写测试代码，不过我认为，既然软件测试在软件工程课程中是基础课，那么每一个程序员都应该懂得一定的测试手段，再者写下这套文章，有利于我从新复习java的单元测试手段，当然这些手段在未来，即使是换一种语言，也会是通用的知识。这篇文章中所用的junit版本都是junit4,用注解来标识一些测试声明，而且测试类不再需要继承TestCase,也不需要遵循它的测试方法命名规则，我们可以把测试方法命名的的更加直观。&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件测试" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
      <category term="TDD" scheme="http://yoursite.com/tags/TDD/"/>
    
      <category term="Junit" scheme="http://yoursite.com/tags/Junit/"/>
    
  </entry>
  
  <entry>
    <title>温故:快排和归并</title>
    <link href="http://yoursite.com/2017/09/14/Recall-Quick-Sort-and-Merging-Sort/"/>
    <id>http://yoursite.com/2017/09/14/Recall-Quick-Sort-and-Merging-Sort/</id>
    <published>2017-09-14T13:37:04.000Z</published>
    <updated>2017-09-14T16:31:09.565Z</updated>
    
    <content type="html"><![CDATA[<p>可能要去实习了，笔试的常考的算法要看一下，今天无聊的时候随便写了几个。</p>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><p>  这个应该是一个要背出来的的算法了随便用scala实现了一下，快排的话是英国人霍尔在26岁的时候偶然发现的，当时他为了解决词典排序问题，想到了冒泡排序这种比较普遍的方法，然后就发现了霍尔划分法，20年之后就得了图灵奖，真是我辈楷模，所以快排又被看作是特殊的冒泡，也就是这个道理了。</p>
<p>  我们上面提到的并不是霍尔发现了快排，而是霍尔发现了霍尔划分法，实际上快排最主要的部分是划分，而不是排序或者合并，有两种划分方法，分别是Lomuto划分，Hoare划分，其中前者常常被用来实现基于减治的快速查找算法。但两者都可以实现快排。</p>
<h2 id="Lomuto划分"><a href="#Lomuto划分" class="headerlink" title="Lomuto划分"></a>Lomuto划分</h2><p>  先用1行代码写一个交换函数，然后，额….这里我犯了小错误，因为我当时考虑用基类实现数字划分的时候的时候发现这AnyVal这个东西没有比较函数，所以我为了偷懒就用了一下Int直接写了，实际只花费了5行代码。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//读取一个Array和要交换的两个元素的位置</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap</span></span>[<span class="type">T</span>](l:<span class="type">Array</span>[<span class="type">T</span>],a:<span class="type">Int</span>,b:<span class="type">Int</span>):<span class="type">Unit</span>=&#123;<span class="keyword">val</span> temp=l(a);l(a)=l(b);l(b)=temp&#125;</div><div class="line"></div><div class="line"><span class="comment">//实现Lomuto划分</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">lomutoPartion</span></span>(buf:<span class="type">Array</span>[<span class="type">Int</span>],start:<span class="type">Int</span>,end:<span class="type">Int</span>)=&#123;</div><div class="line">  <span class="keyword">var</span> (p,s)=(buf(start),start);</div><div class="line">  <span class="comment">//s指向大于p的第一个数的前一个数，一旦发现小于p的数就与s指向的位置交换，当然还有一种情况是不存在大于p的数，最后p被换到最后</span></div><div class="line">  <span class="keyword">for</span>(i&lt;-s+<span class="number">1</span> to end) <span class="keyword">if</span>(buf(i)&lt;p)&#123;s+=<span class="number">1</span>;swap(buf,s,i)&#125;</div><div class="line">  <span class="comment">//返回中轴s的位置</span></div><div class="line">  swap(buf,start,s);s</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="快速查找"><a href="#快速查找" class="headerlink" title="快速查找"></a>快速查找</h3><p>Lomuto划分算法常常用来做减值法的快速查找,这种查找法和在一个已经排序的数组里二分找某个元素的位置不同，这个查找是从一个无序数组里找到第n大或者第n小的元素。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//找第n大的元素</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSelect</span></span>(l:<span class="type">Array</span>[<span class="type">Int</span>],start:<span class="type">Int</span>,end:<span class="type">Int</span>,i:<span class="type">Int</span>):<span class="type">Int</span>=&#123;</div><div class="line">    <span class="keyword">val</span> s=lomutoPartion(l,start,end);</div><div class="line">   <span class="comment">//如果第k大的元素在前半部分，那么后半部分和中轴被丢弃的元素是end+1-s个，所以前半部分应该找第i-(end+1-s)大的元素</span></div><div class="line">    s+i<span class="number">-1</span>-end <span class="keyword">match</span>&#123;</div><div class="line">    <span class="comment">//如果正好是中轴直接返回</span></div><div class="line">    <span class="keyword">case</span> <span class="number">0</span>=&gt;l(s)</div><div class="line">    <span class="comment">//x&gt;0时，表示元素在前半部分</span></div><div class="line">    <span class="keyword">case</span> x=&gt;x&gt;<span class="number">0</span> <span class="keyword">match</span>&#123;</div><div class="line">      <span class="keyword">case</span> <span class="literal">true</span> =&gt;&#123;quickSelect(l,start,s<span class="number">-1</span>, x)&#125;</div><div class="line">      <span class="keyword">case</span> <span class="literal">false</span> =&gt; &#123;quickSelect(l,s+<span class="number">1</span>,end,i)&#125;</div><div class="line">    &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//找第n小的元素</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSelectLittle</span></span>(l:<span class="type">Array</span>[<span class="type">Int</span>],start:<span class="type">Int</span>,end:<span class="type">Int</span>,i:<span class="type">Int</span>):<span class="type">Int</span>=&#123;</div><div class="line">    <span class="keyword">val</span> s=lomutoPartion(l,start,end);</div><div class="line">   <span class="comment">//如果第k大的元素在后半部分，那么后前部分和中轴被丢弃的元素是s+1-start个，所以前后部分应该找第start+i-s+1小的元素</span></div><div class="line">    start+i<span class="number">-1</span>-s <span class="keyword">match</span>&#123;</div><div class="line">      <span class="comment">//如果正好是中轴直接返回</span></div><div class="line">      <span class="keyword">case</span> <span class="number">0</span>=&gt;l(s)</div><div class="line">      <span class="comment">//x&gt;0时，表示元素在后半部分</span></div><div class="line">      <span class="keyword">case</span> x=&gt;x&lt;<span class="number">0</span> <span class="keyword">match</span>&#123;</div><div class="line">        <span class="keyword">case</span> <span class="literal">true</span> =&gt;quickSelectLittle(l,start,s<span class="number">-1</span>, i)</div><div class="line">        <span class="keyword">case</span> <span class="literal">false</span> =&gt;quickSelectLittle(l,s+<span class="number">1</span>,end,x)</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Hoare划分"><a href="#Hoare划分" class="headerlink" title="Hoare划分"></a>Hoare划分</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这个霍尔划分法没有做其他的增强效率的操作，比如用特殊的方法，取一个更好的p为中轴</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">HoarePartion</span></span>(l:<span class="type">Array</span>[<span class="type">Int</span>],start:<span class="type">Int</span>,end:<span class="type">Int</span>)=&#123;</div><div class="line">  <span class="keyword">var</span> (p,i,j)=(l(start),start,end+<span class="number">1</span>);</div><div class="line">  do&#123;</div><div class="line">    <span class="comment">//i指从左到右扫描到第一个大于等于p的数为止</span></div><div class="line">    do i+=<span class="number">1</span> <span class="keyword">while</span>(i&lt;end&amp;&amp;l(i)&lt;p)</div><div class="line">    <span class="comment">//j从右向左扫描到小于p的第一个数为止</span></div><div class="line">    do j-=<span class="number">1</span> <span class="keyword">while</span>(j&gt;start&amp;&amp;l(j)&gt;p)</div><div class="line">    <span class="comment">//交换i,j</span></div><div class="line">    swap(l, i, j)</div><div class="line">  &#125;<span class="keyword">while</span>(i&lt;j)<span class="comment">//知道i和j交叉，即当i&gt;=j的时候结束循环</span></div><div class="line">  <span class="comment">//复原上次交换，因为i&gt;=j这次交换是无效的</span></div><div class="line">  swap(l, i, j)</div><div class="line">  <span class="comment">//把起始的l的第一个元素交换到j位置上，完成划分，返回j的位置，即中轴</span></div><div class="line">  swap(l, start, j);j</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</div><div class="line">  <span class="keyword">val</span> s=<span class="type">Array</span>(<span class="number">9</span>,<span class="number">12</span>,<span class="number">42</span>,<span class="number">41</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">41</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">5</span>)</div><div class="line">  quickSort(s, <span class="number">0</span>, s.length<span class="number">-1</span>);</div><div class="line">  println(s.toList)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">output:</div><div class="line">List(0, 2, 2, 3, 4, 5, 5, 5, 9, 9, 12, 13, 41, 41, 42)</div><div class="line">*/</div></pre></td></tr></table></figure>
<h3 id="实现快排"><a href="#实现快排" class="headerlink" title="实现快排"></a>实现快排</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">quickSort</span></span>(l:<span class="type">Array</span>[<span class="type">Int</span>],start:<span class="type">Int</span>,end:<span class="type">Int</span>)&#123;</div><div class="line">  <span class="keyword">if</span>(start&lt;end)&#123;</div><div class="line">    <span class="keyword">val</span> s=<span class="type">HoarePartion</span>(l, start, end);</div><div class="line">    </div><div class="line">    <span class="comment">//val s=LomutoPartion(l, start, end);   你也可以用Lomuto划分，或者你自己的划分算法</span></div><div class="line">    </div><div class="line">    <span class="comment">//分治策略，更好的方法时在l.lengtg&lt;10的时候用选择排序，其实改进后可以成为尾递归，这里没做</span></div><div class="line">    quickSort(l, start, s<span class="number">-1</span>);</div><div class="line">    quickSort(l, s+<span class="number">1</span>, end);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>  基于分治策略的归并排序，如果需要的话空间复杂度可以到O(1),即在位排序，只用一个空间来做交换，但是这样对算法时间效率就毫无提升了，失去意义。</p>
<p>  要发挥最差nlog(n)的时间效率（由主定理得出）就需要有O(n)空间牺牲。但是应该记住归并排序的最大优势是<strong>稳定性</strong>！如果你需要在某些单片机上在位排序，又想获得最差nlong(n)可以用<strong>堆排序</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//归并排序    </span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">mergeSort</span></span>(ls:<span class="type">Array</span>[<span class="type">Int</span>]):<span class="type">Array</span>[<span class="type">Int</span>]=&#123;</div><div class="line">      <span class="comment">//这里要注意的是如果ls的length是1那么l是空，而r长度是1</span></div><div class="line">      <span class="keyword">val</span> (l,r)=(ls.take(ls.length/<span class="number">2</span>),ls.drop(ls.length/<span class="number">2</span>))</div><div class="line">    </div><div class="line">  	  <span class="comment">//如果l，r的长度大于1的话就做递归</span></div><div class="line">      <span class="keyword">if</span>(l.length&gt;<span class="number">1</span>) mergeSort(l);</div><div class="line">      <span class="keyword">if</span>(r.length&gt;<span class="number">1</span>) mergeSort(r);</div><div class="line">      </div><div class="line">      merge(l, r, ls);</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="comment">//合并两个数组</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>(l:<span class="type">Array</span>[<span class="type">Int</span>],r:<span class="type">Array</span>[<span class="type">Int</span>],ls:<span class="type">Array</span>[<span class="type">Int</span>]):<span class="type">Array</span>[<span class="type">Int</span>]=&#123;</div><div class="line">  <span class="keyword">var</span> i,j=<span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span>(k &lt;- <span class="number">0</span> to ls.length<span class="number">-1</span>)&#123;</div><div class="line">    <span class="comment">//用模式配置来匹配各种情形</span></div><div class="line">    (i&lt;l.length,j&lt;r.length) <span class="keyword">match</span>&#123;</div><div class="line">      <span class="keyword">case</span> (<span class="literal">true</span>,<span class="literal">true</span>) =&gt; <span class="keyword">if</span>(l(i)&lt;=r(j))&#123;ls(k)=l(i);i+=<span class="number">1</span>&#125;<span class="keyword">else</span>&#123;ls(k)=r(j);j+=<span class="number">1</span>&#125;</div><div class="line">      <span class="keyword">case</span> (<span class="literal">true</span>,<span class="literal">false</span>) =&gt; &#123;ls(k)=l(i);i+=<span class="number">1</span>&#125;</div><div class="line">      <span class="keyword">case</span> (<span class="literal">false</span>,<span class="literal">true</span>) =&gt; &#123;ls(k)=r(j);j+=<span class="number">1</span>&#125;</div><div class="line">      <span class="keyword">case</span> _=&gt;</div><div class="line">    &#125;</div><div class="line">   &#125;</div><div class="line">  ls</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</div><div class="line">  <span class="keyword">val</span> s=<span class="type">Array</span>(<span class="number">9</span>,<span class="number">12</span>,<span class="number">42</span>,<span class="number">41</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">41</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">3</span>,<span class="number">13</span>,<span class="number">4</span>,<span class="number">5</span>)</div><div class="line">  mergeSort(s)</div><div class="line">  println(s.toList)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">output:</div><div class="line">List(0, 2, 2, 3, 4, 5, 5, 5, 9, 9, 12, 13, 41, 41, 42)</div><div class="line">*/</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;可能要去实习了，笔试的常考的算法要看一下，今天无聊的时候随便写了几个。&lt;/p&gt;
&lt;h1 id=&quot;快速排序&quot;&gt;&lt;a href=&quot;#快速排序&quot; class=&quot;headerlink&quot; title=&quot;快速排序&quot;&gt;&lt;/a&gt;快速排序&lt;/h1&gt;&lt;p&gt;  这个应该是一个要背出来的的算法了随便用scala实现了一下，快排的话是英国人霍尔在26岁的时候偶然发现的，当时他为了解决词典排序问题，想到了冒泡排序这种比较普遍的方法，然后就发现了霍尔划分法，20年之后就得了图灵奖，真是我辈楷模，所以快排又被看作是特殊的冒泡，也就是这个道理了。&lt;/p&gt;
&lt;p&gt;  我们上面提到的并不是霍尔发现了快排，而是霍尔发现了霍尔划分法，实际上快排最主要的部分是划分，而不是排序或者合并，有两种划分方法，分别是Lomuto划分，Hoare划分，其中前者常常被用来实现基于减治的快速查找算法。但两者都可以实现快排。&lt;/p&gt;
&lt;h2 id=&quot;Lomuto划分&quot;&gt;&lt;a href=&quot;#Lomuto划分&quot; class=&quot;headerlink&quot; title=&quot;Lomuto划分&quot;&gt;&lt;/a&gt;Lomuto划分&lt;/h2&gt;&lt;p&gt;  先用1行代码写一个交换函数，然后，额….这里我犯了小错误，因为我当时考虑用基类实现数字划分的时候的时候发现这AnyVal这个东西没有比较函数，所以我为了偷懒就用了一下Int直接写了，实际只花费了5行代码。&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//读取一个Array和要交换的两个元素的位置&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;swap&lt;/span&gt;&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;T&lt;/span&gt;](l:&lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;T&lt;/span&gt;],a:&lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;,b:&lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;):&lt;span class=&quot;type&quot;&gt;Unit&lt;/span&gt;=&amp;#123;&lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; temp=l(a);l(a)=l(b);l(b)=temp&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//实现Lomuto划分&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;lomutoPartion&lt;/span&gt;&lt;/span&gt;(buf:&lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;],start:&lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;,end:&lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;)=&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;var&lt;/span&gt; (p,s)=(buf(start),start);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//s指向大于p的第一个数的前一个数，一旦发现小于p的数就与s指向的位置交换，当然还有一种情况是不存在大于p的数，最后p被换到最后&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt;(i&amp;lt;-s+&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; to end) &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(buf(i)&amp;lt;p)&amp;#123;s+=&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;swap(buf,s,i)&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;comment&quot;&gt;//返回中轴s的位置&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  swap(buf,start,s);s&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="温故" scheme="http://yoursite.com/tags/%E6%B8%A9%E6%95%85/"/>
    
  </entry>
  
  <entry>
    <title>Docker (1):Run a Nginx in Docker</title>
    <link href="http://yoursite.com/2017/09/13/Docker-1-Run-a-Nginx-in-Docker/"/>
    <id>http://yoursite.com/2017/09/13/Docker-1-Run-a-Nginx-in-Docker/</id>
    <published>2017-09-13T04:51:35.000Z</published>
    <updated>2017-10-31T14:10:49.268Z</updated>
    
    <content type="html"><![CDATA[<p>  Docker是在下非常常见的一个应用容器引擎，和MongoDb一样，它也诞生Paas市场混战时的,一家叫dotCloud的Paas提供商。</p>
<p>   它的流行主要是能解决一些业界的痛点：</p>
<p>​    1.解决了运行环境不一致带来的问题</p>
<p>​    2.它的隔离性解决了资源分配过度的问题，它可以限定一个用户最多用多少资源</p>
<p>​    3.因为上两点，我们可以实现新的服务器更快的部署</p>
<p>centos上，直接使用以下命令，就可以自动安装docker</p>
<p><code>yum install docker</code></p>
<p>这个安装方式的缺点是，版本号可能不是最新的，你也可以采取curl方式来安装它的最新版本：</p>
<p><code>curl -s https://get.docker.com|sh</code></p>
<a id="more"></a>
<h1 id="Docker如何工作？"><a href="#Docker如何工作？" class="headerlink" title="Docker如何工作？"></a>Docker如何工作？</h1><p>  安装完成之后我们就直接运行它吧，非常简单：</p>
<p><code>service docker start</code></p>
<p>然后我们可以尝试一下运行我们的helloworld程序</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# docker run hello-world</div><div class="line"></div><div class="line">Hello from Docker!</div><div class="line">This message shows that your installation appears to be working correctly.</div><div class="line"></div><div class="line">To generate this message, Docker took the following steps:</div><div class="line"> 1. The Docker client contacted the Docker daemon.</div><div class="line"> 2. The Docker daemon pulled the "hello-world" image from the Docker Hub.</div><div class="line"> 3. The Docker daemon created a new container from that image which runs the</div><div class="line">    executable that produces the output you are currently reading.</div><div class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</div><div class="line">    to your terminal.</div><div class="line"></div><div class="line">To try something more ambitious, you can run an Ubuntu container with:</div><div class="line"><span class="meta"> $</span> docker run -it ubuntu bash</div><div class="line"></div><div class="line">Share images, automate workflows, and more with a free Docker ID:</div><div class="line"> https://cloud.docker.com/</div><div class="line"></div><div class="line">For more examples and ideas, visit:</div><div class="line"> https://docs.docker.com/engine/userguide/</div></pre></td></tr></table></figure>
<p>hello-world程序设计的很好，它不止输出了一个欢迎字符，而且它告诉了你docker如何工作：</p>
<p>1.docker客户端链接到了docker daemon</p>
<p>2.docker deamon尝试去Docker hub仓库中查找一个叫做hello-world的镜像，拉取到本地</p>
<p>3.从找到的hello-world镜像中创建一个容器,并且执行它，输出了你看到的这段话</p>
<p>4.这段话被显示在了中断里</p>
<p>简单的四句话，体现了Docker的工作流程。</p>
<h2 id="仓库，镜像，容器"><a href="#仓库，镜像，容器" class="headerlink" title="仓库，镜像，容器"></a>仓库，镜像，容器</h2><p>这里提到了3个概念，即仓库,镜像，容器</p>
<h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>本质就是一个进程，是可读写的，可以看成一个虚拟机<br>层级查找，容器在最上层，如果要修改一个镜像文件，则该文件会移动到容器层，然后在容器层实现修改，然后实现层级查找</p>
<h3 id="镜像（image）"><a href="#镜像（image）" class="headerlink" title="镜像（image）"></a>镜像（image）</h3><p>它是一系列的文件，每一层都是是只读的，这种分层以联合文件系统来实现，每一层加载完成后，这些文件都看做是同一个目录<br>比如第一层 test1 有 a b两个文件<br>第二层test2 有c d两个文件<br>联合文件系统 把他们结合看做test  包括了 a b c d四个文件</p>
<h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>仓库保存了一列的镜像，我们可以用Nexus创建本地私服仓库，就像Maven那样，也可以用几个著名的大仓库，比如下两个：</p>
<p><a href="">hub.docker.com</a>    docker官方仓库<br><a href="https://c.163.com/hub#/m/home/" target="_blank" rel="external">https://c.163.com/hub#/m/home/</a>   网易蜂巢镜像中心（要登录网易账号）</p>
<p>你可能要问为什么，hello world叫hello-world而不是别的什么，原因就是仓库里它就叫做hello-world，其他的很多镜像我们也可以直接去仓库里找。</p>
<h2 id="新的镜像"><a href="#新的镜像" class="headerlink" title="新的镜像"></a>新的镜像</h2><h3 id="比如先获取Nginx？"><a href="#比如先获取Nginx？" class="headerlink" title="比如先获取Nginx？"></a>比如先获取Nginx？</h3><p>如果只能运行hello-world的话那么就太没意思了，但是我前面说过容器几乎可以看成一个虚拟机，所以不难推测出我们的linux上可以运行的服务器程序都可以在docker容器里运行。</p>
<p>比如我们可以通过这种方式来get一个新的镜像：</p>
<p>拉取镜像<br>docker pull [OPTIONS] NAME[:TAG]</p>
<p>查看本地镜像<br>docker images [OPTIONS][REPOSITORY[:TAG]]</p>
<p>我们可以在仓库中搜索镜像的链接，然后把它拉取到本地比如对于Nginx:</p>
<p><img src="\img\QQ图片20170913135622.png" alt="QQ图片20170913135622"></p>
<p>我们可以查看到它所仓库中对于该镜像的描述，使用下面的命令将其拉取到本地：</p>
<p><code>docker pull hub.c.163.com/library/nginx:latest</code></p>
<h3 id="查看本地镜像列表"><a href="#查看本地镜像列表" class="headerlink" title="查看本地镜像列表"></a>查看本地镜像列表</h3><p>拉取之后我们用上面提到的docker images来查看我们的本地镜像：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# docker images</div><div class="line">REPOSITORY                    TAG                 IMAGE ID            CREATED                                                 SIZE</div><div class="line">docker.io/hello-world         latest              05a3bd381fc2        Less than                                a second ago   1.84 kB</div><div class="line">hub.c.163.com/library/nginx   latest              46102226f2fd        4 months a                               go             109.4 MB</div></pre></td></tr></table></figure>
<h3 id="Nginx从镜像到容器"><a href="#Nginx从镜像到容器" class="headerlink" title="Nginx从镜像到容器"></a>Nginx从镜像到容器</h3><p>可以看到我们的本地有两个镜像,那么我们要如何来运行Nginx呢？一般来说Nginx是运行在后台的负载均衡服务器，而且可能需要配置很多配置文件，如何来配置Nginx呢？</p>
<p>首先我们需要介绍两个命令：</p>
<p>docker -d -p 主机端口:容器端口 镜像名/镜像id（可缩写）  //手动分配映射端口<br>docker -d -P 镜像名/镜像id （可缩写）    //这个命令自动给端口号映射到所有的需要映射的端口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> //首先我们需要在后台来运行Nginx，把它当做是一个容器，因为我们的镜像比较小</div><div class="line">[root@localhost ~]# docker run -d -p 8080:80 46</div><div class="line">e333f51f79e74c75f0b89b475588de6c7bdcce3e664d591c8ade4b5baeebd131</div></pre></td></tr></table></figure>
<h3 id="访问Niginx容器"><a href="#访问Niginx容器" class="headerlink" title="访问Niginx容器"></a>访问Niginx容器</h3><p>现在我们运行了Nginx，但是你可能要测试一下，我们有两种测试方法，一种就是用浏览器了，但是Linux一般是没有图形界面的，我们可以用curl来获取Nginx的欢迎界面的html：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# curl http://localhost:8080</div><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">&lt;title&gt;Welcome to nginx!&lt;/title&gt;</div><div class="line">&lt;style&gt;</div><div class="line">    body &#123;</div><div class="line">        width: 35em;</div><div class="line">        margin: 0 auto;</div><div class="line">        font-family: Tahoma, Verdana, Arial, sans-serif;</div><div class="line">    &#125;</div><div class="line">&lt;/style&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;</div><div class="line">&lt;p&gt;If you see this page, the nginx web server is successfully installed and</div><div class="line">working. Further configuration is required.&lt;/p&gt;</div><div class="line"></div><div class="line">&lt;p&gt;For online documentation and support please refer to</div><div class="line">&lt;a href="http://nginx.org/"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;</div><div class="line">Commercial support is available at</div><div class="line">&lt;a href="http://nginx.com/"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;</div><div class="line"></div><div class="line">&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<h3 id="宿主windows上访问Nginx"><a href="#宿主windows上访问Nginx" class="headerlink" title="宿主windows上访问Nginx"></a>宿主windows上访问Nginx</h3><p>  我们可以看到Nginx的欢迎界面已经可以访问，有些人可能会很奇怪，他在windows上用浏览器访问linxus上的ip地址加端口号的方式为什么访问不到该界面，其实docker容器自己有一个ip地址，我刚刚说他，你几乎可以把它认为是一个在操作一个类似于虚拟机的东西（其实它不是虚拟机，而是基于联合文件系统的上层容器），那么我们在哪里可以访问到这个ip地址呢？</p>
<p>  实际上我们直接可以看路由表或者用ifconfig就知道了,这里我用路由表来显示一下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@localhost ~]# route</div><div class="line">Kernel IP routing table</div><div class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</div><div class="line">default         gateway         0.0.0.0         UG    100    0        0 ens33</div><div class="line">172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0</div><div class="line">192.168.194.0   0.0.0.0         255.255.255.0   U     100    0        0 ens33</div></pre></td></tr></table></figure>
<p>  从上面这个路由表你可以推测，如果你对192.168.194.1:8080进行curl的话当然是抓取不到HTML欢迎界面的，但是可以通过172.17.0.1:8080来抓取，很遗憾的是你的windows宿主机器中根本不知道172.17.0.1和192.168.194.1有什么关系。</p>
<p>  这种情况下我们只能手动配置路由表了，打开cmd(需要以管理员身份):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">//我们首先当然要看看192.168.194.1的掩码，因为我们呢要把它设为网关，所以先看看ipv4的路由表</div><div class="line"></div><div class="line">C:\WINDOWS\system32&gt;route print -4</div><div class="line">===========================================================================</div><div class="line">接口列表</div><div class="line">  7...d0 bf 9c 94 fb d4 ......Realtek PCIe GBE Family Controller</div><div class="line"> 14...f4 06 69 7d ea 1b ......Microsoft Wi-Fi Direct Virtual Adapter</div><div class="line">  6...f6 06 69 7d ea 1a ......Microsoft Hosted Network Virtual Adapter</div><div class="line"> 21...00 50 56 c0 00 01 ......VMware Virtual Ethernet Adapter for VMnet1</div><div class="line"> 17...00 50 56 c0 00 08 ......VMware Virtual Ethernet Adapter for VMnet8</div><div class="line"> 12...f4 06 69 7d ea 1a ......Intel(R) Dual Band Wireless-AC 3160</div><div class="line">  1...........................Software Loopback Interface 1</div><div class="line">===========================================================================</div><div class="line"></div><div class="line">IPv4 路由表</div><div class="line">===========================================================================</div><div class="line">活动路由:</div><div class="line">网络目标        网络掩码          网关       接口   跃点数</div><div class="line">          0.0.0.0          0.0.0.0       10.86.80.1     10.86.80.164     55</div><div class="line">       10.86.80.0    255.255.240.0            在链路上      10.86.80.164    311</div><div class="line">     10.86.80.164  255.255.255.255            在链路上      10.86.80.164    311</div><div class="line">     10.86.95.255  255.255.255.255            在链路上      10.86.80.164    311</div><div class="line">        127.0.0.0        255.0.0.0            在链路上         127.0.0.1    331</div><div class="line">        127.0.0.1  255.255.255.255            在链路上         127.0.0.1    331</div><div class="line">  127.255.255.255  255.255.255.255            在链路上         127.0.0.1    331</div><div class="line">     192.168.32.0    255.255.255.0            在链路上      192.168.32.1    291</div><div class="line">     192.168.32.1  255.255.255.255            在链路上      192.168.32.1    291</div><div class="line">   192.168.32.255  255.255.255.255            在链路上      192.168.32.1    291</div><div class="line">    192.168.194.0    255.255.255.0            在链路上     192.168.194.1    291</div><div class="line">    192.168.194.1  255.255.255.255            在链路上     192.168.194.1    291</div><div class="line">  192.168.194.255  255.255.255.255            在链路上     192.168.194.1    291</div><div class="line">        224.0.0.0        240.0.0.0            在链路上         127.0.0.1    331</div><div class="line">        224.0.0.0        240.0.0.0            在链路上      192.168.32.1    291</div><div class="line">        224.0.0.0        240.0.0.0            在链路上     192.168.194.1    291</div><div class="line">        224.0.0.0        240.0.0.0            在链路上      10.86.80.164    311</div><div class="line">  255.255.255.255  255.255.255.255            在链路上         127.0.0.1    331</div><div class="line">  255.255.255.255  255.255.255.255            在链路上      192.168.32.1    291</div><div class="line">  255.255.255.255  255.255.255.255            在链路上     192.168.194.1    291</div><div class="line">  255.255.255.255  255.255.255.255            在链路上      10.86.80.164    311</div><div class="line">===========================================================================</div><div class="line">永久路由:</div><div class="line">  无</div><div class="line">  </div><div class="line">//可以看到我们的192.164.194.1/32 在路由表中，我们把它设置为网关</div><div class="line">C:\WINDOWS\system32&gt;route add 172.17.0.1 mask 255.255.255.255 192.168.194.1</div><div class="line"> 操作完成!</div></pre></td></tr></table></figure>
<p>然后我们再访问172.17.0.1就可以看到Nginx界面了，说些仅仅因为，如果你将来把web程序配置到linxu虚拟机上，我们要用浏览器访问它，不可能用curl来做操作吧！</p>
<p><img src="\img\QQ图片20170913141920.png" alt="QQ图片20170913141920"></p>
<h3 id="如何配置容器？"><a href="#如何配置容器？" class="headerlink" title="如何配置容器？"></a>如何配置容器？</h3><p>如果一个容器只能访问，而不能配置，那它毫无作用，实际上我们可以进入容器来对它做配置：</p>
<p>在一个容器中运行一个命令</p>
<pre><code>               选项      容器名    命令
docker exec [OPTIONS] CONTAINER COMMAND [ARG...]
</code></pre><p>  -d, –detach         Detached mode: run command in the background<br>  –detach-keys        Override the key sequence for detaching a container<br>  –help               Print usage<br>  -i, –interactive    Keep STDIN open even if not attached<br>  –privileged         Give extended privileges to the command<br>容器名/容器id  -t, –tty            Allocate a pseudo-TTY<br>  -u, –user           Username or UID (format: <name|uid>[:<group|gid>])</group|gid></name|uid></p>
<p>我们常用这个命令，来以一个伪终端进入一个bash程序：</p>
<p>-i 保证输入有效<br>-t 分配一个伪终端<br>一般是 docker exec -it 容器名/容器id（可以缩写就像git log） bash </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">//要进入容器我们先得知道容器名称或者容器的id,使用docker ps命令我们可以看到这些</div><div class="line">[root@localhost ~]# docker ps</div><div class="line">CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                                                                                                NAMES</div><div class="line">e333f51f79e7        46                  &quot;nginx -g &apos;daemon off&quot;   34 minutes ago      Up 34 minutes       0.0.0.                                                                              0:8080-&gt;80/tcp   desperate_golick</div><div class="line"></div><div class="line">//现在我们以容器id的最短唯一缩写（同git里的版本号缩写）那样进入我们的容器的bash</div><div class="line"></div><div class="line">[root@localhost ~]# docker exec -it e3 bash</div><div class="line"></div><div class="line">//可以看到我们以root进入了容器，它就像一个linux虚拟机一样，有着它的大部分功能</div><div class="line">root@e333f51f79e7:/# ls</div><div class="line">bin  boot  dev  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</div><div class="line"></div><div class="line">//我们可以进入/etc/nginx/目录</div><div class="line">root@e333f51f79e7:/# cd /etc/nginx/</div><div class="line">root@e333f51f79e7:/etc/nginx# ls</div><div class="line">conf.d  fastcgi_params  koi-utf  koi-win  mime.types  modules  nginx.conf  scgi_params  uwsgi_params  win-utf</div></pre></td></tr></table></figure>
<p>我们进入了Docker的容器，但是你运行命令马上就会有惊人的发现，这怎么用啊！连vi都没！实际上一开始这个容器是裸的，你要自己装一些常用的软件，比如vim之类的，然后如果你是centos/rhel用户，你尝试yum update的时候，可能会提示你yum都没有，不要悲哀，实际上Docker是更倾向于支持Debian/Ubuntu这边的，所以你得用apt-get 去安装软件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">apt-get update</div><div class="line"></div><div class="line">apt-get -y install vim</div><div class="line"></div><div class="line">...</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  Docker是在下非常常见的一个应用容器引擎，和MongoDb一样，它也诞生Paas市场混战时的,一家叫dotCloud的Paas提供商。&lt;/p&gt;
&lt;p&gt;   它的流行主要是能解决一些业界的痛点：&lt;/p&gt;
&lt;p&gt;​    1.解决了运行环境不一致带来的问题&lt;/p&gt;
&lt;p&gt;​    2.它的隔离性解决了资源分配过度的问题，它可以限定一个用户最多用多少资源&lt;/p&gt;
&lt;p&gt;​    3.因为上两点，我们可以实现新的服务器更快的部署&lt;/p&gt;
&lt;p&gt;centos上，直接使用以下命令，就可以自动安装docker&lt;/p&gt;
&lt;p&gt;&lt;code&gt;yum install docker&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这个安装方式的缺点是，版本号可能不是最新的，你也可以采取curl方式来安装它的最新版本：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;curl -s https://get.docker.com|sh&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Functional Programming(4):Monoid</title>
    <link href="http://yoursite.com/2017/09/10/Functional-Programming-4-Monoid/"/>
    <id>http://yoursite.com/2017/09/10/Functional-Programming-4-Monoid/</id>
    <published>2017-09-10T14:17:34.000Z</published>
    <updated>2017-09-13T06:56:43.872Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Monoid的数学定义"><a href="#Monoid的数学定义" class="headerlink" title="Monoid的数学定义"></a>Monoid的数学定义</h2><p>  在函数式编程中，我们喜欢用代数来描述一些数据类型，包括特定的法则和被它们限定的操作。比如说n阶可逆矩阵在其乘法运算下，满足结合律，且单位阵为幺元，每个n阶可逆矩阵都有逆阵，即逆元，那么它是一个群。<br>  实际上一些我们有一些通用的代数模式被用于函数式编程式数据类型的设计，对于函数式编程来说，他们就像在面向对象编程时我们要立刻想到各种设计模式一样重要，运用代数模式我们可以消除大量的重复代码！为什么可以呢？我们先来看看幺半群–Monoid。<br>  在左孝凌版本的离散数学Monoid不叫幺半群，而叫做独异点：</p>
<blockquote>
<p>  一个代数系统&lt;S,*&gt;,S为非空集合，而*为S上的一个二元运算<br>  如果运算是封闭的<br>  且运算是可结合的，即对于x,y,z ∈S满足(x*y)*z=x*(y*z)<br>  那么&lt;S,*&gt;是半群<br>  如果半群众含有幺元（对于任何x∈S，存在e,e*x=x=x*e,e即&lt;S,*&gt;的幺元），那么它就是一个幺半群（独异点）</p>
</blockquote>
  <a id="more"></a>
<h2 id="Monoid示例"><a href="#Monoid示例" class="headerlink" title="Monoid示例"></a>Monoid示例</h2><p>  理解这样一个概念的意义是帮助我们去选择纯代数（purely algebraic）结构，我们可以从这个简单的定义中提取一些有意义的东西，即这个代数结构的定义，比如对于字符串，我们思考一下它&lt;String,+&gt;上是不是满足Monoid定义呢？<br>  首先，&lt;String,+&gt;上的运算是封闭的，这个是肯定的，你不可能把两个字符串相加，加出个别的什么东西来<br>  其次，&lt;String,+&gt;是可结合的，这个我们可以推论出来对于字符串a,b,c<br>  <strong>(a+b)+c=a+(b+c)</strong><br>  最后，可以找到一个幺元，即空串””，任何字符串s与它做左右的+运算，都等于它本身<br>  现在我们可以确定，&lt;String,+&gt;,是一个Monoid,于是我们可以定义：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="class"><span class="keyword">trait</span> <span class="title">Monoid</span>[<span class="type">S</span>]</span>&#123;</div><div class="line">     | <span class="function"><span class="keyword">def</span> <span class="title">opreate</span></span>(a:<span class="type">S</span>,b:<span class="type">S</span>):<span class="type">S</span></div><div class="line">     | <span class="function"><span class="keyword">def</span> <span class="title">identity</span></span>:<span class="type">S</span></div><div class="line">     | &#125;</div><div class="line">defined <span class="class"><span class="keyword">trait</span> <span class="title">Monoid</span></span></div></pre></td></tr></table></figure></p>
<p>  现在我们有了Monoid接口定义，它很简单，且体现了除结合律以外的其他两条定义，当然我们用了泛型S来表示集合，这个传入的这个集合必须是非空的。<br>  那么对于&lt;String,+&gt;，我们有<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="class"><span class="keyword">class</span> <span class="title">Stringplus</span> <span class="keyword">extends</span> <span class="title">Monoid</span>[<span class="type">String</span>]</span>&#123;<span class="type">Map</span>[<span class="type">String</span>,<span class="type">Map</span>[<span class="type">String</span>,<span class="type">String</span>]]</div><div class="line">     | <span class="function"><span class="keyword">def</span> <span class="title">opreate</span></span>(a:<span class="type">String</span>,b:<span class="type">String</span>)=a+b;</div><div class="line">     | <span class="function"><span class="keyword">def</span> <span class="title">identity=</span>""</span></div><div class="line">     | &#125;</div><div class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">Stringplus</span></span></div></pre></td></tr></table></figure></p>
<h2 id="结合律与并行化"><a href="#结合律与并行化" class="headerlink" title="结合律与并行化"></a>结合律与并行化</h2><p>   实际上如果你仔细一点想想，就会发现有很多&lt;S,#&gt;,满足Monoid定义，比如整数的加法和乘法，布尔型的与或运算，这些都是最基本的，实际上在Scala中很多集合运算在集合上都是符合Monoid定义的！比如对于List的foldLeft和foldRight操作,对于同样的输入，它们能够得出同样的结果：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">scala&gt; res5.foldLeft(<span class="number">0</span>)(_+_)</div><div class="line">res6: <span class="type">Int</span> = <span class="number">15</span></div><div class="line"></div><div class="line">scala&gt; res5.foldRight(<span class="number">0</span>)(_+_)</div><div class="line">res7: <span class="type">Int</span> = <span class="number">15</span></div></pre></td></tr></table></figure></p>
<p>  详细理解过我们的Scala后可以知道List的Left操作的效率要高于Right操作，但是这和左右折叠运算并没有关系，有关系的是左右折叠运算都是满足结合律和同一律的！<br>  那么一个&lt;S,#&gt;是Monoid,和我们的编程有什么关系呢？<br>  我们可以考虑一下，一个超大型的数据链表L，做某个操作#，如果&lt;L,#&gt;是满足结合律的，我们可以轻易对其进行并行运算，因为总是有(a#b)#c=a#(b#c)，所以先做哪一部分运算似乎无所谓。</p>
<h2 id="同态"><a href="#同态" class="headerlink" title="同态"></a>同态</h2><p>  有时候我们还可以发现一些函数符合monoid同态（homomorphism）性质：</p>
<blockquote>
<p>一个f是Monoid同态函数，那么它在Monoid M和N之间遵循一条原则，即对于所有的值x和y满足：<br> M.op(f(x),f(y))==f(N.op(x,y))</p>
</blockquote>
<p>  值得注意的是M和N可以是也可以不是同一类型的Monoid！</p>
<p>  比如对于字符串：<br>  “xxx”.length+”yyy”.length==(“xxx”+”yyy”).length，length函数就是&lt;String,+&gt;和&lt;String,+&gt;之间的同态函数，同样的的情况还出现在两个&lt;List,+&gt;之间。</p>
<p>  有时候，两个Monoid&lt;S,*&gt;，&lt;S,*&gt;之间是双向同态的，引出了同构(isomorphism)的定义:<br>  <strong>monoid同质是指在M和N之间存在两个同态函数f和g，如果f和g满足f andThen g和g andThenf是同样的函数。</strong></p>
<p>  我们在<strong>设计类型的时候</strong>，应该考虑它的函数<strong>是不是可以符合同态性质</strong>，这对我们的编程是有帮助的。</p>
<h2 id="用Monoid接口构建类型"><a href="#用Monoid接口构建类型" class="headerlink" title="用Monoid接口构建类型"></a>用Monoid接口构建类型</h2><p>###建一个Foldable类型构造器<br>  就像上面那样我们构造了一个Monoid接口后构造我们的StringPlus，现在我们要来构建新的类型，这些新的类型总会满足一些特性，比如它们都是可折叠的，而且他们的折叠函数与该集合满足我们的Monoid的特性。<br>  有了这些需求，我们可以构造这样的一个接口：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="class"><span class="keyword">trait</span> <span class="title">Foldable</span>[<span class="type">F</span>[_]]</span>&#123;</div><div class="line">     | <span class="function"><span class="keyword">def</span> <span class="title">foldRight</span></span>[<span class="type">A</span>,<span class="type">B</span>](as:<span class="type">F</span>[<span class="type">A</span>])(z:<span class="type">B</span>)(f:(<span class="type">A</span>,<span class="type">B</span>)=&gt;<span class="type">B</span>):<span class="type">B</span></div><div class="line">     | <span class="function"><span class="keyword">def</span> <span class="title">foldLeft</span></span>[<span class="type">A</span>,<span class="type">B</span>](as:<span class="type">F</span>[<span class="type">A</span>])(z:<span class="type">B</span>)(f:(<span class="type">B</span>,<span class="type">A</span>)=&gt;<span class="type">B</span>):<span class="type">B</span></div><div class="line">     | <span class="function"><span class="keyword">def</span> <span class="title">foldMap</span></span>[<span class="type">A</span>,<span class="type">B</span>](as:<span class="type">F</span>[<span class="type">A</span>])(f:<span class="type">A</span>=&gt;<span class="type">B</span>)(mb:<span class="type">Monoid</span>[<span class="type">B</span>]):<span class="type">B</span></div><div class="line">     | <span class="function"><span class="keyword">def</span> <span class="title">concatenate</span></span>[<span class="type">A</span>](as:<span class="type">F</span>[<span class="type">A</span>])(m:<span class="type">Monoid</span>[<span class="type">A</span>]):<span class="type">A</span>=foldLeft(as)(m.identity)(m.opreate)</div><div class="line">     | &#125;</div></pre></td></tr></table></figure></p>
<p>  在这里F[_]的使用或许让你有些奇怪，这里的意思其实就是抽象出一个类型构造器，下划线占位符标识F接受一个类型参数，它是一个构造器而不是类型，这里引入一个新概念，即高阶类型(higher-kinded type),这个名字包含的意义就和高阶函数差不多，只不过这里Foldable接受一个类型参数而不是函数。有了它我们可以实现这一一个类，它包含了List的折叠函数：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">然后我们来实现一个这样的类</div><div class="line">scala&gt; <span class="class"><span class="keyword">class</span> <span class="title">ListFold</span> <span class="keyword">extends</span> <span class="title">Foldable</span>[<span class="type">List</span>]</span>&#123;</div><div class="line">     |        <span class="function"><span class="keyword">def</span> <span class="title">foldRight</span></span>[<span class="type">A</span>,<span class="type">B</span>](as:<span class="type">List</span>[<span class="type">A</span>])(z:<span class="type">B</span>)(f:(<span class="type">A</span>,<span class="type">B</span>)=&gt;<span class="type">B</span>):<span class="type">B</span>=as <span class="keyword">match</span>&#123;</div><div class="line">     |           <span class="keyword">case</span> <span class="type">Nil</span>=&gt;z</div><div class="line">     |           <span class="keyword">case</span> _=&gt;foldRight(as.tail)(f(as.head,z))(f)</div><div class="line">     |   &#125;</div><div class="line">     |        <span class="function"><span class="keyword">def</span> <span class="title">foldLeft</span></span>[<span class="type">A</span>,<span class="type">B</span>](as:<span class="type">List</span>[<span class="type">A</span>])(z:<span class="type">B</span>)(f:(<span class="type">B</span>,<span class="type">A</span>)=&gt;<span class="type">B</span>):<span class="type">B</span>=as <span class="keyword">match</span>&#123;</div><div class="line">     |           <span class="keyword">case</span> <span class="type">Nil</span>=&gt;z</div><div class="line">     |           <span class="keyword">case</span> _=&gt;foldLeft(as.take(as.length<span class="number">-1</span>))(f(z,as.last))(f)</div><div class="line">     |   &#125;</div><div class="line">     |        <span class="function"><span class="keyword">def</span> <span class="title">foldMap</span></span>[<span class="type">A</span>,<span class="type">B</span>](as:<span class="type">List</span>[<span class="type">A</span>])(f:<span class="type">A</span>=&gt;<span class="type">B</span>)(mb:<span class="type">Monoid</span>[<span class="type">B</span>]):<span class="type">B</span>=&#123;</div><div class="line">     |           concatenate(as.map(f))(mb)</div><div class="line">     |   &#125;</div><div class="line">     | &#125;</div><div class="line">defined <span class="class"><span class="keyword">class</span> <span class="title">ListFold</span></span></div></pre></td></tr></table></figure></p>
<h3 id="组合monoid"><a href="#组合monoid" class="headerlink" title="组合monoid"></a>组合monoid</h3><p>  某些数据结构如果包含的元素是monoid那么它就构成monoid，比如对于元组Tuple2(A,B),如果AB都是Monoid那么，(A,B)也是Monoid，这个新生产的monoid叫做product。<br>  我们可以用简单测combinator来实现对Monoid的复杂组合，比如你创建如下函数，它是一个闭包，返回了一个新的Monoid类型，这个类型用来帮助我们组合Map。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">scala&gt; <span class="function"><span class="keyword">def</span> <span class="title">mapMergeMonoid</span></span>[<span class="type">K</span>,<span class="type">V</span>](<span class="type">V</span>: <span class="type">Monoid</span>[<span class="type">V</span>]): <span class="type">Monoid</span>[<span class="type">Map</span>[<span class="type">K</span>, <span class="type">V</span>]] =</div><div class="line">     | <span class="keyword">new</span> <span class="type">Monoid</span>[<span class="type">Map</span>[<span class="type">K</span>, <span class="type">V</span>]] &#123;</div><div class="line">     | <span class="function"><span class="keyword">def</span> <span class="title">identity</span> </span>= <span class="type">Map</span>[<span class="type">K</span>,<span class="type">V</span>]()</div><div class="line">     | <span class="function"><span class="keyword">def</span> <span class="title">opreate</span></span>(a: <span class="type">Map</span>[<span class="type">K</span>, <span class="type">V</span>], b: <span class="type">Map</span>[<span class="type">K</span>, <span class="type">V</span>]) =</div><div class="line">     | (a.keySet ++ b.keySet).foldLeft(identity) &#123; (acc,k) =&gt;</div><div class="line">     | acc.updated(k, <span class="type">V</span>.opreate(a.getOrElse(k, <span class="type">V</span>.identity),</div><div class="line">     | b.getOrElse(k, <span class="type">V</span>.identity)))</div><div class="line">     | &#125;</div><div class="line">     | &#125;</div><div class="line">mapMergeMonoid: [<span class="type">K</span>, <span class="type">V</span>](<span class="type">V</span>: <span class="type">Monoid</span>[<span class="type">V</span>])<span class="type">Monoid</span>[<span class="type">Map</span>[<span class="type">K</span>,<span class="type">V</span>]]</div><div class="line"></div><div class="line"><span class="comment">//创建了两个Map</span></div><div class="line">scala&gt; <span class="type">Map</span>(<span class="string">"f"</span>-&gt;<span class="string">"hello"</span>,<span class="string">"k"</span>-&gt;<span class="string">"hi"</span>)</div><div class="line">res50: scala.collection.immutable.<span class="type">Map</span>[<span class="type">String</span>,<span class="type">String</span>] = <span class="type">Map</span>(f -&gt; hello, k -&gt; hi)</div><div class="line"></div><div class="line">scala&gt; <span class="type">Map</span>(<span class="string">"f"</span>-&gt;<span class="string">" chen"</span>,<span class="string">"m"</span>-&gt;<span class="string">"akka"</span>)</div><div class="line">res51: scala.collection.immutable.<span class="type">Map</span>[<span class="type">String</span>,<span class="type">String</span>] = <span class="type">Map</span>(f -&gt; <span class="string">" chen"</span>, m -&gt; akka)</div><div class="line"></div><div class="line"><span class="comment">//创建一个对象，能够以Stringplus来组合Map[String,Map[String,String]]</span></div><div class="line">scala&gt; <span class="keyword">val</span> merge:<span class="type">Monoid</span>[<span class="type">Map</span>[<span class="type">String</span>,<span class="type">Map</span>[<span class="type">String</span>,<span class="type">String</span>]]]=mapMergeMonoid(mapMergeMonoid(<span class="keyword">new</span> <span class="type">Stringplus</span>))</div><div class="line">merge: <span class="type">Monoid</span>[<span class="type">Map</span>[<span class="type">String</span>,<span class="type">Map</span>[<span class="type">String</span>,<span class="type">String</span>]]] = $anon$<span class="number">1</span>@<span class="number">4113</span>ca53</div><div class="line"></div><div class="line"><span class="comment">//定义两个Map[String,Map[String,String]]</span></div><div class="line">scala&gt; <span class="type">Map</span>(<span class="string">"o1"</span>-&gt;res50)</div><div class="line">res56: scala.collection.immutable.<span class="type">Map</span>[<span class="type">String</span>,scala.collection.immutable.<span class="type">Map</span>[<span class="type">String</span>,<span class="type">String</span>]] = <span class="type">Map</span>(o1 -&gt; <span class="type">Map</span>(f -&gt; hello, k -&gt; hi))</div><div class="line"></div><div class="line">scala&gt; <span class="type">Map</span>(<span class="string">"o1"</span>-&gt;res51)<span class="type">Map</span>[<span class="type">String</span>,<span class="type">Map</span>[<span class="type">String</span>,<span class="type">String</span>]]</div><div class="line">res57: scala.collection.immutable.<span class="type">Map</span>[<span class="type">String</span>,scala.collection.immutable.<span class="type">Map</span>[<span class="type">String</span>,<span class="type">String</span>]] = <span class="type">Map</span>(o1 -&gt; <span class="type">Map</span>(f -&gt; <span class="string">" chen"</span>, m -&gt; akka))</div><div class="line"></div><div class="line"><span class="comment">//完成组合</span></div><div class="line">scala&gt; merge.opreate(res56,res57)</div><div class="line">res59: <span class="type">Map</span>[<span class="type">String</span>,<span class="type">Map</span>[<span class="type">String</span>,<span class="type">String</span>]] = <span class="type">Map</span>(o1 -&gt; <span class="type">Map</span>(f -&gt; hello chen, k -&gt; hi, m -&gt; akka))</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Monoid的数学定义&quot;&gt;&lt;a href=&quot;#Monoid的数学定义&quot; class=&quot;headerlink&quot; title=&quot;Monoid的数学定义&quot;&gt;&lt;/a&gt;Monoid的数学定义&lt;/h2&gt;&lt;p&gt;  在函数式编程中，我们喜欢用代数来描述一些数据类型，包括特定的法则和被它们限定的操作。比如说n阶可逆矩阵在其乘法运算下，满足结合律，且单位阵为幺元，每个n阶可逆矩阵都有逆阵，即逆元，那么它是一个群。&lt;br&gt;  实际上一些我们有一些通用的代数模式被用于函数式编程式数据类型的设计，对于函数式编程来说，他们就像在面向对象编程时我们要立刻想到各种设计模式一样重要，运用代数模式我们可以消除大量的重复代码！为什么可以呢？我们先来看看幺半群–Monoid。&lt;br&gt;  在左孝凌版本的离散数学Monoid不叫幺半群，而叫做独异点：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;  一个代数系统&amp;lt;S,*&amp;gt;,S为非空集合，而*为S上的一个二元运算&lt;br&gt;  如果运算是封闭的&lt;br&gt;  且运算是可结合的，即对于x,y,z ∈S满足(x*y)*z=x*(y*z)&lt;br&gt;  那么&amp;lt;S,*&amp;gt;是半群&lt;br&gt;  如果半群众含有幺元（对于任何x∈S，存在e,e*x=x=x*e,e即&amp;lt;S,*&amp;gt;的幺元），那么它就是一个幺半群（独异点）&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="scala" scheme="http://yoursite.com/tags/scala/"/>
    
      <category term="FP" scheme="http://yoursite.com/tags/FP/"/>
    
  </entry>
  
  <entry>
    <title>九月</title>
    <link href="http://yoursite.com/2017/09/03/A-failed-windows-Installation/"/>
    <id>http://yoursite.com/2017/09/03/A-failed-windows-Installation/</id>
    <published>2017-09-03T14:48:22.000Z</published>
    <updated>2017-09-13T06:56:54.254Z</updated>
    
    <content type="html"><![CDATA[<h2 id="溜走的暑期"><a href="#溜走的暑期" class="headerlink" title="溜走的暑期"></a>溜走的暑期</h2><p>  又是新的一个月，2017年就要结束了，秋天也马上要到来，遥想暑假刚刚开始的时候，我曾经想在7月和8月之间写50篇文章，可是最后只写了30篇吧，还有一些零零碎碎的知识，8月在家里比较懒就放弃了。<br>  7月学习了Scala语言，很多人说它比较难，后来我学起来觉得挺容易的，不过鉴于说这话的人不多，所以我想这应该不是以讹传讹吧（以我的经验来看，一般来说如果一个东西很多人讨论并且有很多人说很难其实如果你肯多接触的话，它就不太难，比如说vim，但是你只看到寥寥几个人说很难其他人不说话，那么这个东西肯定很难），后来我接触《FP in scala》，发现scala其实不难，但是如果不仅仅把它当做Better Java 来工作的话就很难了，正因为如此国内聊这个语言的不是太多吧。</p>
<p>  函数式编程也给我的毕业设计指明了某个方向，在写这篇文章的前几天，我在想可能会做一个用函数式写的解释器之类的的吧！</p>
<p>  <img src="/img/Sept.jpg"></p>
  <a id="more"></a>
<p>  我的第二个小小的发现就是，其实很多成熟而应用广泛的软件项目，中文社区里并没有最新的参考资料，所以都只有去看官方文档，而且这些文档实在是太详细了，比如mongodb的，apache的某些项目，只能说些这些文档的开发者不知道有多么认真的去完成这件事情，其中又能看出他们写文档的团队合作也很强，因为几千页文档肯定不是一个人写的，不同的人写的文档居然能够互相引用包含，让我觉得有点不可思议，我不知道写这些文档的人都是怎么样的开发者，但是他们做事的认真程度无疑是我这一生中见过的最认真的，我曾经看过一些大牛翻译的书，比如杨敬年教授翻译的国富论，当时我就觉得这已经是非常非常认真做事的人了，当然还有谢希仁写的计算机网络，认真的程度一眼就可以与某些年轻作者写的书区别开来，但是对比这种海量的文档，我觉得还是差很多的，这让我想起年轻的我曾经鄙视的一句话：</p>
<blockquote>
<p>软件是计算机程序、程序所用的数据以及有关文档资料的集合。</p>
</blockquote>
<p>  这句话写在我的软件工程的课本里，我曾经把课本重点抄了一遍，如今拿出那本笔记本看到这句话在第二面，还是回味无穷地！</p>
<p>  为什么国外有这么多响彻世界的开源软件呢？我想这也是一“点点小小”的原因吧,毕竟我以前写html的时候用过一个波兰人用纯js写的截头像的接口，作为一个完全不知名的开发者，人家也非常细心的维护文档，把每一步为什么，每一个参数都轻轻处处的给出来，还特意在个人服务器上开了一个web服务去专门介绍这个应用，虽然他人家可能只是随便写写玩着，但是人家就是在乎哪天有那么一个人看到了，就能通过这个文档用它的api。</p>
<p>  这让我想起了我以前听电台，主播说在他读研究生的时候，导师要他开发一套bittorrent软件，结果他就找到了ctorrent，当时这个软件的bug很多，于是他就发邮件给这作者问了很多问题，没想到这个作者居然回复了，于是乎他对着python的bt实现和询问就帮助CTorrent改了很多bug，然后那个作者就说要把CTorrent转给这个主播去维护行不行，其实人家写个软件随便玩玩，主播嫌麻烦就拒绝了，哈哈，后来主播总结说这是他这辈子做错的一件事情，在年轻的时候没有去拥抱开源社区，所以无法成为小牛,更成不了大牛，后来这个CTorrent开源件就变成了现在的Enhanced CTorrent。</p>
<p>  实际上这个故事吧，如果主角是我，我也会拒绝的，可能这就是我朝工人阶级的心态吧，谁会有事没事认认真真做好很多件吃力不讨好的事情呢？就算接受了，也不会一如既往的维护下去吧。大多数人都是想着怎么骗一笔智税，怎么满足自己小小的虚荣吧！</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;溜走的暑期&quot;&gt;&lt;a href=&quot;#溜走的暑期&quot; class=&quot;headerlink&quot; title=&quot;溜走的暑期&quot;&gt;&lt;/a&gt;溜走的暑期&lt;/h2&gt;&lt;p&gt;  又是新的一个月，2017年就要结束了，秋天也马上要到来，遥想暑假刚刚开始的时候，我曾经想在7月和8月之间写50篇文章，可是最后只写了30篇吧，还有一些零零碎碎的知识，8月在家里比较懒就放弃了。&lt;br&gt;  7月学习了Scala语言，很多人说它比较难，后来我学起来觉得挺容易的，不过鉴于说这话的人不多，所以我想这应该不是以讹传讹吧（以我的经验来看，一般来说如果一个东西很多人讨论并且有很多人说很难其实如果你肯多接触的话，它就不太难，比如说vim，但是你只看到寥寥几个人说很难其他人不说话，那么这个东西肯定很难），后来我接触《FP in scala》，发现scala其实不难，但是如果不仅仅把它当做Better Java 来工作的话就很难了，正因为如此国内聊这个语言的不是太多吧。&lt;/p&gt;
&lt;p&gt;  函数式编程也给我的毕业设计指明了某个方向，在写这篇文章的前几天，我在想可能会做一个用函数式写的解释器之类的的吧！&lt;/p&gt;
&lt;p&gt;  &lt;img src=&quot;/img/Sept.jpg&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="闲谈" scheme="http://yoursite.com/tags/%E9%97%B2%E8%B0%88/"/>
    
  </entry>
  
</feed>
