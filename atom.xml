<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog of Saul</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-09T02:59:27.610Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Saul</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>react(1):meet react</title>
    <link href="http://yoursite.com/2018/10/09/react-1-meet-react/"/>
    <id>http://yoursite.com/2018/10/09/react-1-meet-react/</id>
    <published>2018-10-09T01:44:08.000Z</published>
    <updated>2018-10-09T02:59:27.610Z</updated>
    
    <content type="html"><![CDATA[<p>  几乎所有的软件问题都可以添加一层抽象来解决，react通过添加虚拟DOM这层抽象，=，解决了处理DOM的效率问题，<strong>虚拟DOM即用来描述真实DOM的JS对象</strong>，我们知道处理结构化的js对象，要比处理一大段文本快得多。</p>
<p>  特点：</p>
<p>  <strong>声明式的视图层</strong>：以JSX语法声明视图层，因此可以随意使用状态数据</p>
<p>  <strong>从状态到UI的单向数据流</strong>：定义UI的状态，让React来把它渲染为最终的UI，React根据最新状态来渲染最新UI。</p>
<p>  <strong>灵活渲染</strong>：React并不直接把视图渲染成最终的界面，而是把它们渲染为了中间的抽象，即虚拟DOM，结合其他库，可以把虚拟DOM渲染成不同的最终界面，在浏览器上是react-dom,在移动端上则可以配合Native来使用，在服务端则可以配合Node进行渲染。</p>
<p>  <strong>高效DOM操作</strong>：本身对js对象的操作就远快于对真实DOM操作，配合一些诸如Diff之类的差异算法，更是可以减少渲染速度，让界面性能增加。</p>
<h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p>  JSX是一种用于描述UI的JS扩展语法，React用其来描述组件的UI。发明这种语法与React本身的理念有关，与传统很多模板思想把数据和UI拆分有所不同，其理念把<strong>组件</strong>当做是界面的可复用模块，<strong>且认为组件应该是具备UI描述和UI数据的完整体</strong>，不应该把它们分开来处理。</p>
<p>  实际上JSX仅仅是React提供的语法糖，它对应的方法是</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">React.createElement(component,props, ...chi)</div></pre></td></tr></table></figure>
<p>  所有的JSX最终都会转变为对上面这个方法的调用，但是为了对被声明的视图一目了然，首选使用JSX，就像java8中一般不会使用匿名类来代替lambda语法一样。</p>
<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>  JSX只有两种标签，React通过首字母是否大写来区分这两类标签，而且它们可以互相嵌套使用：</p>
<p>  其一就是DOM类型的标签，也就是html的基础标签诸如div,span,p等等，首字母必须小写。</p>
<p>  然后则是React组件标签，首字母必须大写。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//dom标签</span></div><div class="line"><span class="keyword">const</span> divElement = <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> hello saul <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//组件标签</span></div><div class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">SaulBlog</span> /&gt;</span>;</span></div><div class="line">     </div><div class="line">//嵌套使用</div><div class="line">const hello = (<span class="tag">&lt;<span class="name">div</span>&gt;</span> <span class="tag">&lt;<span class="name">SaulBlog</span> /&gt;</span> <span class="tag">&lt;/<span class="name">div</span>&gt;</span>;</div></pre></td></tr></table></figure>
<h3 id="js表达式"><a href="#js表达式" class="headerlink" title="js表达式"></a>js表达式</h3><p>JSX本质上依然是Js，我们可以用{}讲表达式括起来的方式来使用表达式，一般有两种情况我们要用这种语法：</p>
<p>  <strong>通过表达式给标签属性赋值</strong></p>
<p>  <strong>通过表达式定义子组件</strong></p>
<p>需要注意的是和scala之类的语言不同，js表达式并不支持多行js语句，用;隔开两条语句是会报错的。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Error!</span></div><div class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">Saul</span> <span class="attr">value</span> = <span class="string">&#123;const</span> <span class="attr">val</span> = <span class="string">1+1;return</span> <span class="attr">val</span>; &#125; /&gt;</span></span></div></pre></td></tr></table></figure>
<p>所以你用不了if-eles语句，但是可以用三目运算符?和&amp;&amp;代替if的作用。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> boolean = <span class="literal">false</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">Saul</span> <span class="attr">value</span> = <span class="string">&#123;boolean</span> &amp;&amp; <span class="attr">1</span>&#125; /&gt;</span></span></div></pre></td></tr></table></figure>
<h3 id="标签属性和注释"><a href="#标签属性和注释" class="headerlink" title="标签属性和注释"></a>标签属性和注释</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>除了部分属性外，DOM标签支持的属性JSX同样支持，只不过有些地方有点变化，比如es6占用的class关键字，现在需要在标签属性中用className代替</p>
<p>另外React对标签支持的事件进行了重新分封装，封装时采用的是驼峰命名法，如onclick要写成onClick。</p>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>注释方面需要用{}把/**/括起来</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="comment">/* 我是注释 */</span>&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  几乎所有的软件问题都可以添加一层抽象来解决，react通过添加虚拟DOM这层抽象，=，解决了处理DOM的效率问题，&lt;strong&gt;虚拟DOM即用来描述真实DOM的JS对象&lt;/strong&gt;，我们知道处理结构化的js对象，要比处理一大段文本快得多。&lt;/p&gt;
&lt;p&gt;  特点
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>Notes of Deep Learning:what is YOLO</title>
    <link href="http://yoursite.com/2018/03/13/Notes-of-Deep-Learning-what-is-YOLO/"/>
    <id>http://yoursite.com/2018/03/13/Notes-of-Deep-Learning-what-is-YOLO/</id>
    <published>2018-03-13T07:17:13.000Z</published>
    <updated>2018-03-14T10:14:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>  YOLO是现在性能比较好的一个基于卷积神经网络的目标检测算法，当然它有2个版本，这里说的是第一个版本，YOLO的第一个版本有一些局限性，比如对小的目标检测效果不是很好，但是它的检测速度对比于RCNN系列算法(Fast,Faster)是一个很大的优势，在论文中作者说在TITAN X显卡上跑YOLO模型，检测速度可以达到每秒45帧，另外有一个牺牲了一些准确度的简化版模型（Fast YOLO）则达到了每秒155帧，要知道RCNN最快的版本也就是10多帧的样子。下图是YOLO论文中给出的一张对比表：</p>
<div><br><br><img src="\img\QQ图片20180314145429.png" align="center"><br><br></div>

<p>  对YOLO算法在速度上的突破起决定性作用的应该是把目标检测作为单个回归问题，而不是分类问题，RCNN系列算法，一般都有两个重要的模块，一个用于找出候选区域，一个用于将候选区域里的图像用于分类。YOLO则直接是一个端到端的系统，从图像像素到边界框坐标和类概率一气呵成。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  YOLO是现在性能比较好的一个基于卷积神经网络的目标检测算法，当然它有2个版本，这里说的是第一个版本，YOLO的第一个版本有一些局限性，比如对小的目标检测效果不是很好，但是它的检测速度对比于RCNN系列算法(Fast,Faster)是一个很大的优势，在论文中作者说在TI
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="目标检测" scheme="http://yoursite.com/tags/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B/"/>
    
  </entry>
  
  <entry>
    <title>Notes of CS231n:Structure of CNN</title>
    <link href="http://yoursite.com/2018/03/12/Notes-of-Deep-Learning-Structure-of-CNN/"/>
    <id>http://yoursite.com/2018/03/12/Notes-of-Deep-Learning-Structure-of-CNN/</id>
    <published>2018-03-12T03:04:18.000Z</published>
    <updated>2018-03-12T08:39:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>  卷积神经网络也由有学习能力的神经元组成，这些神经元中也有权重和偏差。整个卷积神经网络实为是一个可导的评分函数，在神经网络中我们实现的各种技巧和要点依旧适用于卷积神经网络。但是<strong>卷积神经网络与一般神经网络不同的是，它基于一个假设，即输入的数据是图像</strong>。基于这个假设，我们添加了一些特有的特性，从而让我们的前向传播更为高效，<strong>同时也大大降低了网络中的参数数量</strong>。降低参数数量是一个很好的特性，因为在一般的神经网络中，因为是全连接的，如果要处理一个大点的图像，比如一个200*200*3的图像，一个神经元就有12万个权重，显然这是不可接受的。</p>
<a id="more"></a>
<h2 id="卷积神经网络结构"><a href="#卷积神经网络结构" class="headerlink" title="卷积神经网络结构"></a>卷积神经网络结构</h2><h3 id="三维排列的神经元"><a href="#三维排列的神经元" class="headerlink" title="三维排列的神经元"></a>三维排列的神经元</h3><p>在一般的神经网络中，神经元的排列一般是如下图所示：</p>
<p><img src="\img\QQ图片20180214180333.jpg" alt="QQ图片20180214180333"></p>
<p>我们可以观察到，如果硬要以一个形式的语言来描述的话，可以用宽度和高度来描述这个二维的神经元排列，但是卷积神经网络与此不同，它是三维排列的，如下图所示，我们以<strong>宽度，高度，和深度</strong>标记了这个神经元排列：</p>
<p><img src="\img\QQ图片20180312120608.png" alt="QQ图片20180312120608"></p>
<p>  从上图中你没办法发现神经元之间具体是如何连接的，但是你可以先了解一点，<strong>卷积神经网络的各层中的神经元不再采用全连接的方式</strong>，层中的神经元将只与前一层中的一小块区域连接，当然输出层例外，输出层还是全连接的。</p>
<p>  上图中的卷积神经网络的神经元排列可能不能让你清楚的知道深度的意义。我们以CIFAR-10举例，你知道CIFAR-10中的数据体是32*32*3这个大小，后面的3是代表了RGB颜色通道，那么它的神经元排列就是深度为3，宽度和高度都是32的排列。最后的输出层是1*1*10的，表示了评分向量。</p>
<blockquote>
<p>卷积神经网络是由层组成的。每一层都有一个简单的API：用一些含或者不含参数的可导的函数，将输入的3D数据变换为3D的输出数据。</p>
</blockquote>
<h3 id="以层构造的卷积神经网络"><a href="#以层构造的卷积神经网络" class="headerlink" title="以层构造的卷积神经网络"></a>以层构造的卷积神经网络</h3><p>卷积神经网络由不同类型的层按照一定的排列顺序组成，这些层会使用一个可微分的函数将激活数据从自身层传到另一个层。比如一个简单的用于CIFAR-10图像分类的网络结构：</p>
<blockquote>
<p>[输入层-卷积层-ReLU层-汇聚层-全连接层]</p>
</blockquote>
<p>1.输入层即是输入[32*32*3]的原始图像像素值</p>
<p>2.卷基层中，神经元与输入层的一个局部区域相连，每个神经元都计算自己与输入层相连的小区域与自己权重的内积。卷积层会计算所有神经元的输出。如果我们使用12个滤波器（也叫作核），得到的输出数据体的维度就是[32x32x12]。</p>
<p>3.ReLU层将会逐个元素地进行激活函数操作，比如使用以0为阈值的max(0,x)作为激活函数。该层对数据尺寸没有改变，还是[32x32x12]。</p>
<p>4.汇聚层在在空间维度（宽度和高度）上进行降采样（downsampling）操作，数据尺寸变为[16x16x12]。</p>
<p>5.全连接层将会计算分类评分，数据尺寸变为[1x1x10]，其中10个数字对应的就是CIFAR-10中10个类别的分类评分值。正如其名，全连接层与常规神经网络一样，其中每个神经元都与前一层中所有神经元相连接。</p>
<p>具体说来，卷积层和全连接层（CONV/FC）对输入执行变换操作的时候，不仅会用到激活函数，还会用到很多参数（神经元的突触权值和偏差）。而ReLU层和汇聚层则是进行一个固定不变的函数操作，它没有参数（汇聚层有额外的超参数）。卷积层和全连接层中的参数会随着梯度下降被训练，这样卷积神经网络计算出的分类评分就能和训练集中的每个图像的标签吻合了。</p>
<h2 id="卷基层与汇聚层"><a href="#卷基层与汇聚层" class="headerlink" title="卷基层与汇聚层"></a>卷基层与汇聚层</h2><h3 id="卷基层"><a href="#卷基层" class="headerlink" title="卷基层"></a>卷基层</h3><p>  从卷积神经网络的名字你就应该知道什么层是核心，卷基层产生了网络中的大部分计算量。</p>
<h4 id="滤波器"><a href="#滤波器" class="headerlink" title="滤波器"></a>滤波器</h4><p>  首先你肯定想知道卷积层是怎么样计算的，先明确的一点是：<strong>卷基层的参数是由一些可学习的滤波器（即一组固定权重的集合，又被称作卷积核）集合构成的。</strong>这些滤波器的宽度和高度都比较小，但是深度与输入数据一致。比如在上面CIFAR例子中的第一层卷积层与输入层相连，它的滤波器大小可能是5*5*3，其中5<em>5是宽高，而3则与数据体的RGB通道深度相同。在前向传播的时候，让每个滤波器都在输入数据的宽度和高度上滑动（更精确地说是卷积），然后计算整个滤波器和输入数据任一处的内积。当<strong>滤波器沿着输入数据的宽度和高度滑过</strong>后，会生成一个2维的激活图（activation map），激活图给出了在每个空间位置处滤波器的反应。直观地来说，网络会让滤波器学习到当它看到某些类型的视觉特征时就激活。<em>*在每个卷积层上，我们会有一整个集合的滤波器（比如12个），每个都会生成一个不同的二维激活图。将这些激活映射在深度方向上层叠起来就生成了输出数据。</em></em></p>
<h4 id="感受野"><a href="#感受野" class="headerlink" title="感受野"></a>感受野</h4><p>  图像数据是高维的，如果让每个神经元与之进行全连接，那么将会产生大量的参数以至于计算量不能忍受。于是我们让每个神经元只与输入数据的一个局部区域进行连接，这个局部区域的尺寸（高宽）是一个超参数，我们把它叫做神经元的<strong>感受野</strong>。但是可以确定的是，在数据深度上这个连接大小与输入数据一致。比如：</p>
<p><em>例1</em>：假设输入数据体尺寸为[32x32x3]（比如CIFAR-10的RGB图像），如果感受野（或滤波器尺寸）是5x5，那么卷积层中的每个神经元会有输入数据体中[5x5x3]区域的权重，共5x5x3=75个权重（还要加一个偏差参数）。注意这个连接在深度维度上的大小必须为3，和输入数据体的深度一致。</p>
<p><em>例2</em>：假设输入数据体的尺寸是[16x16x20]，感受野尺寸是3x3，那么卷积层中每个神经元和输入数据体就有3x3x20=180个连接。再次提示：在空间上连接是局部的（3x3），但是在深度上是和输入数据体一致的（20）。</p>
<h3 id="输出数据体"><a href="#输出数据体" class="headerlink" title="输出数据体"></a>输出数据体</h3><p>  现在我们知道了卷积层中神经元与输入数据体中的连接方式，那么卷积层的输出数据体是怎么样的呢？有三个超参数控制着输出数据体的尺寸：<strong>即深度，步长和零填充。</strong></p>
<p>  输出数据体的深度是一个超参数，它与滤波器数量一致，每个滤波器在输入数据中寻找一些不同的东西。举例来说，如果第一个卷积层的输入是原始图像，那么在深度维度上的不同神经元将可能被不同方向的边界，或者是颜色斑点激活。我们将这些沿着深度方向排列、感受野相同的神经元集合称为<strong>深度列（depth column）</strong>，也有人使用纤维（fibre）来称呼它们。</p>
<p>  另外，滑动滤波器的时候，需要指定步长，这个步长大小同零填充的大小一起决定了输出数据体的高宽。步长和零填充的大小都是超参数。填充有一个良好性质，即可以控制输出数据体的空间尺寸（最常用的是用来保持输入数据体在空间上的尺寸，这样输入和输出的宽高都相等）。</p>
<p>  输出数据体在空间（高度和宽度）上的尺寸可以通过输入数据体尺寸（W），卷积层中神经元的感受野尺寸（F），步长（S）和零填充的数量（P）的函数来计算。（<strong>*译者注</strong>：这里假设输入数组的空间形状是正方形，即高度和宽度相等<em>）<em>*输出数据体的空间尺寸为(W-F +2P)/S+1</em></em>（注意如果这个公式得出的值不是一个整数，说明你的步长和零填充的设置是无效的）。比如输入是7x7，滤波器是3x3，步长为1，填充为0，那么就能得到一个5x5的输出。</p>
<h3 id="参数共享"><a href="#参数共享" class="headerlink" title="参数共享"></a>参数共享</h3><p>  在2012年的ImageNet挑战中，Krizhevsky采用了这么一个设定，输入图像的尺寸是[227x227x3]。在第一个卷积层，神经元使用的感受野尺寸<strong>F=11</strong>，步长<strong>S=4</strong>，不使用零填充<strong>P=0</strong>。因为(227-11)/4+1=55，卷积层的深度<strong>K=96</strong>，则卷积层的输出数据体尺寸为[55x55x96]。</p>
<p>  我们可以看到上面举出的这个第一个卷积层就有55*55*96=290,400个神经元，每个有11*11*3个参数和一个偏差，你可以乘一下就发现，第一层卷积层参数就上亿了，显然我们需要一些策略来避免这种情况发生，这个策略就是<strong>参数共享</strong>。</p>
<p>  一个合理的假设：如果一个特征在计算某个空间位置(x,y)的时候有用，那么它在计算另一个不同位置(x2,y2)的时候也有用。基于这个假设，可以显著地减少参数数量。换言之，就是将深度维度上一个单独的2维切片看做<strong>深度切片（depth slice）</strong>，比如一个数据体尺寸为[55x55x96]的就有96个深度切片，每个尺寸为[55x55]。在这样的参数共享下，例子中的第一个卷积层就只有96个不同的权重集了，一个权重集对应一个深度切片，共有96x11x11x3=34,848个不同的权重，或34,944个参数（+96个偏差）。）。在每个深度切片中的55x55个权重使用的都是同样的参数。<strong>在反向传播的时候，都要计算每个神经元对它的权重的梯度，但是需要把同一个深度切片上的所有神经元对权重的梯度累加，这样就得到了对共享权重的梯度。</strong>这样，每个切片只更新一个权重集。</p>
<p>  注意，如果在一个深度切片中的所有权重都使用同一个权重向量，那么卷积层的前向传播在每个深度切片中可以看做是在计算神经元权重和输入数据体的<strong>卷积</strong>（这就是“卷积层”名字由来）。这也是为什么总是将这些权重集合称为<strong>滤波器（filter）</strong>（或<strong>卷积核（kernel）</strong>），因为它们和输入进行了卷积。下图演示了一个卷积过程，该图中几个超参数分别是K=2（卷积层深度），F=3（感受野尺寸），S=2（步长），P=1（零填充）：</p>
<p><img src="\img\20160707204048899.gif" alt="20160707204048899"></p>
<p>我们可以看到，在该图中对一个深度切片（蓝色部分每一个矩阵），都用相同的权重进行卷积的过程。</p>
<h3 id="汇聚层"><a href="#汇聚层" class="headerlink" title="汇聚层"></a>汇聚层</h3><p>  一般我们都会在连续的卷积层之间周期性的插入一个汇聚层，目的是为了降低数据体的空间尺寸，这样的话就能够减少网络中参数的尺寸，从而降低计算成本，另外还有控制过拟合的好处。</p>
<p>  汇聚层也是对输入数据体的每一个深度切片独立进行MAX操作，以改变其空间尺寸（高宽）。最常见的形式是汇聚层使用尺寸2x2的滤波器，以步长为2来对每个深度切片进行降采样，将其中75%的激活信息都丢掉。每个MAX操作是从4个数字中取最大值（也就是在深度切片中某个2x2的区域）。深度保持不变。</p>
<p>汇聚层也有计算公式：</p>
<p>  输入数据体高H1，宽W1，深度为D1</p>
<p>  MAX操作空间大小为F,步长为S</p>
<p>  那么输出数据体:</p>
<p>  宽度：W2=(W1-F)/S+1</p>
<p>  高度：H2=(H1-F)/S+1</p>
<p>  深度不变：D2=D1</p>
<p>一般来说MAX汇聚层只有两种形式：F=3，S=2还有前面说的最常用的F=2，S=2。</p>
<p><img src="\img\641c8846abcb02d35938660cf96cef1b_r.jpg" alt="641c8846abcb02d35938660cf96cef1b_r"></p>
<h4 id="汇聚层反向传播"><a href="#汇聚层反向传播" class="headerlink" title="汇聚层反向传播"></a>汇聚层反向传播</h4><p><strong>反向传播：</strong>回顾一下反向传播的内容，其中max(x,y)函数的反向传播可以简单理解为将梯度只沿最大的数回传。因此，在向前传播经过汇聚层的时候，通常会把池中最大元素的索引记录下来（有时这个也叫作<strong>道岔（switches）</strong>），这样在反向传播的时候梯度的路由就很高效。</p>
<p>有些人更倾向于在卷积层中使用更大的步长来降低数据体的尺寸，而不是在模型中使用汇聚层，另外有发现认为，在训练一个良好的生成模型时，弃用汇聚层也是很重要的。</p>
<h2 id="全连接层到卷积层的转换"><a href="#全连接层到卷积层的转换" class="headerlink" title="全连接层到卷积层的转换"></a>全连接层到卷积层的转换</h2><p>全连接层和卷积层之间唯一的不同就是卷积层中神经元只与输入数据中的一个局部区域连接，并且在卷积列中的神经元共享参数。但是两类层中神经元都是计算点积，它们的函数形式实际上是相同的。</p>
<p>我们可以把卷积层转化为一个全连接层，这个全连接层的权重矩阵是巨大的，除了某些特定的块，其余部分都是零（局部连接）。而大部分块中，元素都是相等的（参数共享）。</p>
<p>那么，全连接层也能够被转化为卷积层，因为卷积层连接局部，但是如果这个局部大小大到了和全局一样，那就成了全连接层了。<strong>以卷积层代替全连接层可以让卷积网络在一张更大的输入图片上滑动，得到每个区域的输出（这样就突破了输入尺寸的限制）。下面这段话全部看完可以理解它的意思：</strong></p>
<blockquote>
<p>举个例子，如果我们想让224x224尺寸的浮窗，以步长为32在384x384的图片上滑动，把每个经停的位置都带入卷积网络，最后得到6x6个位置的类别得分。上述的把全连接层转换成卷积层的做法会更简便。如果224x224的输入图片经过卷积层和汇聚层之后得到了[7x7x512]的数组，那么，384x384的大图片直接经过同样的卷积层和汇聚层之后会得到[12x12x512]的数组（因为途径5个汇聚层，尺寸变为384/2/2/2/2/2 = 12）。然后再经过上面由3个全连接层转化得到的3个卷积层，最终得到[6x6x1000]的输出（因为(12 - 7)/1 + 1 = 6）。这个结果正是浮窗在原图经停的6x6个位置的得分！</p>
<p>面对384x384的图像，让（含全连接层）的初始卷积神经网络以32像素的步长独立对图像中的224x224块进行<strong>多次评价</strong>，其效果和使用把全连接层变换为卷积层后的卷积神经网络进行<strong>一次</strong>前向传播是一样的。</p>
<p>自然，相较于使用被转化前的原始卷积神经网络对所有36个位置进行迭代计算，使用转化后的卷积神经网络进行一次前向传播计算要高效得多，因为36次计算都在共享计算资源。这一技巧在实践中经常使用，一次来获得更好的结果。比如，通常将一张图像尺寸变得更大，<strong>然后使用变换后的卷积神经网络来对空间上很多不同位置进行评价得到分类评分，然后在求这些分值的平均值。</strong></p>
</blockquote>
<h2 id="一些对于层的建议"><a href="#一些对于层的建议" class="headerlink" title="一些对于层的建议"></a>一些对于层的建议</h2><h3 id="层的排列"><a href="#层的排列" class="headerlink" title="层的排列"></a>层的排列</h3><p>一个最常见的神经网络结构如下：</p>
<p><strong>INPUT -&gt; [[CONV -&gt; RELU]<em>N -&gt; POOL?]</em>M -&gt; [FC -&gt; RELU]*K -&gt; FC</strong></p>
<p>其中POOL后面的？代表汇聚层是可选的，如果没有其他说明POOL层都是MAX汇聚。</p>
<p>一般而言，几个小滤波器卷积层的组合比一个大滤波器卷积层好。比如你一层一层地重叠了3个3x3的卷积层（层与层之间有非线性激活函数）。在这个排列下，第一个卷积层中的每个神经元都对输入数据体有一个3x3的视野。第二个卷积层上的神经元对第一个卷积层有一个3x3的视野，也就是对输入数据体有5x5的视野。同样，在第三个卷积层上的神经元对第二个卷积层有3x3的视野，也就是对输入数据体有7x7的视野。假设不采用这3个3x3的卷积层，二是使用一个单独的有7x7的感受野的卷积层，那么所有神经元的感受野也是7x7，但是就有一些缺点。</p>
<p>1.多层小的卷积层能更好的提取出深层次的特征</p>
<p>2.在这里，3个3*3的卷积层的参数数目是3*3*3<em>通道数N，而7\</em>7的单个卷积层则是7*7*通道数N，这个数目要大于前者。</p>
<h3 id="层的尺寸"><a href="#层的尺寸" class="headerlink" title="层的尺寸"></a>层的尺寸</h3><p>输入层图像大小应该能被2整除多次，比如32，或者是诸如96或者224，384，512这样的数。</p>
<p>卷积层应该使用小的滤波器，比如3*3或者5*5，大的滤波器如果采用了也一般是接上原始输入层的第一个卷积层，并且我们一般会用适当的零填充来保持数据在空间维度上的尺寸，步长一般是1。在实际应用中，更小的步长效果更好。<strong>上文也已经提过，步长为1可以让空间维度的降采样全部由汇聚层负责，卷积层只负责对输入数据体的深度进行变换。</strong>如果卷积层值进行卷积而不进行零填充，那么数据体的尺寸就会略微减小，那么图像边缘的信息就会过快地损失掉。</p>
<p>对汇聚层的选择一般都是用比较小的感受野，比如2*2，一旦感受野太大可能会使得数据信息丢失。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  卷积神经网络也由有学习能力的神经元组成，这些神经元中也有权重和偏差。整个卷积神经网络实为是一个可导的评分函数，在神经网络中我们实现的各种技巧和要点依旧适用于卷积神经网络。但是&lt;strong&gt;卷积神经网络与一般神经网络不同的是，它基于一个假设，即输入的数据是图像&lt;/strong&gt;。基于这个假设，我们添加了一些特有的特性，从而让我们的前向传播更为高效，&lt;strong&gt;同时也大大降低了网络中的参数数量&lt;/strong&gt;。降低参数数量是一个很好的特性，因为在一般的神经网络中，因为是全连接的，如果要处理一个大点的图像，比如一个200*200*3的图像，一个神经元就有12万个权重，显然这是不可接受的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Notes of CS231n:Neural network 4</title>
    <link href="http://yoursite.com/2018/03/11/Notes-of-Deep-Learning-Neural-network-4/"/>
    <id>http://yoursite.com/2018/03/11/Notes-of-Deep-Learning-Neural-network-4/</id>
    <published>2018-03-11T13:30:24.000Z</published>
    <updated>2018-03-13T03:56:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>  我们利用反向传播计算出解析梯度，然后利用计算出的解析梯度来进行参数更新，这里记录一些有些的最优化技巧，但不进行细节分析。</p>
<a id="more"></a>
<h2 id="参数更新方法"><a href="#参数更新方法" class="headerlink" title="参数更新方法"></a>参数更新方法</h2><h3 id="普通更新"><a href="#普通更新" class="headerlink" title="普通更新"></a>普通更新</h3><p>  沿着负梯度方向改变参数是一个简单有效的方法，比如一个参数向量x，它的梯度为dx，那么这个简单的方法可以表示为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x+=learning_rate*dx</div></pre></td></tr></table></figure>
<h3 id="动量更新"><a href="#动量更新" class="headerlink" title="动量更新"></a>动量更新</h3><p>  普通更新的缺点是，其更新方向完全依赖于当前的batch，使得更新非常不稳定，从物理角度得到启发，人们想出来一种在深度网络上有着更好收敛速度且更新更稳定的方法，即<strong>动量(Momentum)更新</strong>。</p>
<p>  在上面的普通更新中我们可以看到梯度的大小直接影响到了x的值的更新，<strong>而动量更新则不同，它会由梯度去影响“速度”，然后速度再去影响x的更新</strong>，研究这个方法的人把损失值理解为一个高地，而参数更新这个最优化过程可以看做是一个质量以初始速度0，慢慢的加速，把梯度看做是提供这种加速度的力。听起来很玄学，这也能扯上关系？实际上所做的就是改变了x的更新方式而已，把以前的learning_rate*dx增量变成了一个更加科学的“速度”，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">v = mu * v - learning_rate * dx</div><div class="line">x += v</div></pre></td></tr></table></figure>
<p>其中这个mu是一个超参数，叫做动量，它模拟的物体运动的惯性，即更新的时候在一定程度上保留之前更新的方向，同时利用当前batch的梯度微调最终的更新方向，实际上它的意义更加贴近于阻尼系数，mu<em>v提供了一个阻力，这个变量会抑制速度，<em>*一般mu设置为0.9</em></em>，也有一些研究表明mu随时间变化能略改善最优化效果，比如一个典型的设置是一开始mu=0.5，而随后在多个周期中慢慢提升到0.99，[0.5,0.9,0.95,0.99]。</p>
<h3 id="Nesterov动量更新"><a href="#Nesterov动量更新" class="headerlink" title="Nesterov动量更新"></a>Nesterov动量更新</h3><p>  对于动量更新，还有一个增强版的思路，理论上它对于凸函数的收敛有帮助，实践中似乎也确实比上面的标准动量更新表现好点。</p>
<p>  这个思路在于考虑到，更新时，mu*v这个项会稍加改变参数向量，我们最好是在x+mu*v这个近似未来的位置附近计算梯度，而不是在x处计算，这样我们的代码可以变为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x_ahead = x + mu * v</div><div class="line"><span class="comment"># 计算dx_ahead(在x_ahead处的梯度，而不是在x处的梯度)</span></div><div class="line">v = mu * v - learning_rate * dx_ahead</div><div class="line">x += v</div></pre></td></tr></table></figure>
<p><img src="\img\20150906103038485.png" width="600px\"></p>
<p>  首先，按照原来的更新方向更新一步（棕色线），然后在该位置计算梯度值（红色线），然后用这个梯度值修正最终的更新方向（绿色线）。上图中描述了两步的更新示意图，其中蓝色线是标准momentum更新路径。</p>
<h3 id="二阶方法"><a href="#二阶方法" class="headerlink" title="二阶方法"></a>二阶方法</h3><p>  实际上除了各种随机梯度下降算法以外还有一种方法是基于牛顿法的，但是因为实现起来比较困难并不常用。</p>
<h2 id="学习率动态设定"><a href="#学习率动态设定" class="headerlink" title="学习率动态设定"></a>学习率动态设定</h2><h3 id="学习率退火"><a href="#学习率退火" class="headerlink" title="学习率退火"></a>学习率退火</h3><p>学习率随着时间慢慢减小对深度学习训练很有帮助，我们并不想看着参数向量无规律的跳动，但是如果学习率过高这很可能发生，并且意味着我们很难达到最好的位置。一般我们有以下三种退火方式：</p>
<p><strong>随步数衰减</strong>：每隔几个周期就根据某些因素降低学习 率，比如每5个周期减半，或者每20个周期减少到之前的0.1。训练的同时观察验证集的错误率，每当验证集错误率停止下降，就将原来的学习率乘以一个常数比例来降低它。</p>
<p><strong>指数衰减</strong>：a=a[0]e^(-kt),a0和k是超参数，t是迭代次数或者周期</p>
<p><strong>1/t衰减</strong>：a=a[0]/(1+kt),a0和k是超参数，t是迭代次数或者周期</p>
<p>实践中一般都采用第一种方法。</p>
<h3 id="逐参数适应学习率方法"><a href="#逐参数适应学习率方法" class="headerlink" title="逐参数适应学习率方法"></a>逐参数适应学习率方法</h3><p>学习率调参是很耗费计算资源的过程，所以很多工作投入到发明能够适应性地对学习率调参的方法，甚至是逐个参数适应学习率调参。这里将记录一些常用的适应算法。</p>
<h4 id="Adagrad"><a href="#Adagrad" class="headerlink" title="Adagrad"></a>Adagrad</h4> <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 假设有梯度和参数向量x</span></div><div class="line">cache += dx**<span class="number">2</span></div><div class="line">x += - learning_rate * dx / (np.sqrt(cache) + eps)</div></pre></td></tr></table></figure>
<p>Adagrad的一个缺点是，在深度学习中单调递减的学习率被证明通常过于激进且过早停止学习。这里的<strong>eps是一个很小的数</strong>，通常为1e-4到1e-8之间，<strong>引入它的目的是为了防止出现除以0这种不合法情况出现</strong>。</p>
<h4 id="RMSprop"><a href="#RMSprop" class="headerlink" title="RMSprop"></a>RMSprop</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cache =  decay_rate * cache + (1 - decay_rate) * dx**2</div><div class="line">x += - learning_rate * dx / (np.sqrt(cache) + eps)</div></pre></td></tr></table></figure>
<p>RMSprop（Root Mean Square Propagation）方法是Adagrad的改进版本，没有公开发表，但是却非常高效，它来自Geoff Hinton的Coursera课程的<a href="http://link.zhihu.com/?target=http%3A//www.cs.toronto.edu/%257Etijmen/csc321/slides/lecture_slides_lec6.pdf" target="_blank" rel="external">第六课的第29页PPT</a>。上面的代码里decay_rate是一个超参数，常用值是[0.9,0.99,0.999]。你可以观察这个方法改变了cache的计算部分，而第二个式子却是相同的。RMSProp任然是基于梯度的大小来对每个权重的学习率进行修改，但是学习率不会再单调递减，这是和Adagrad的主要区别，也就是说该方法更不那么激进。</p>
<h4 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">m = beta1*m + (<span class="number">1</span>-beta1)*dx</div><div class="line">v = beta2*v + (<span class="number">1</span>-beta2)*(dx**<span class="number">2</span>)</div><div class="line">x += - learning_rate * m / (np.sqrt(v) + eps)</div></pre></td></tr></table></figure>
<p>Adam（Adaptive Moment Estimation）是推荐使用的方法，一般而言跑起来比RMSProp要好一点。但是也可以试试SGD+Nesterov动量。Adam方法看起来真的和RMSProp很像，除了使用的是平滑版的梯度<strong>m</strong>，而不是用的原始梯度向量<strong>dx</strong>。论文中推荐的参数值<strong>eps=1e-8, beta1=0.9, beta2=0.999</strong>。完整的Adam更新算法也包含了一个偏置<em>（bias）矫正</em>机制，因为<strong>m,v</strong>两个矩阵初始为0，在没有完全热身之前存在偏差，需要采取一些补偿措施。</p>
<h2 id="超参数调优"><a href="#超参数调优" class="headerlink" title="超参数调优"></a>超参数调优</h2><p>  你知道一个模型中往往存在着很多超参数，比如随机失活的概率p，以及我们上面提到的种种适应学习率算法中的超参数，我们上面已经给出了一些好的实践值，但是有可能你想去找到更好的值，或者你研究新算法需要有新的超参数。</p>
<h3 id="采用仆程序"><a href="#采用仆程序" class="headerlink" title="采用仆程序"></a>采用仆程序</h3><p>我们可以采用仆程序持续的设置参数然后进行最优化，并且它对各个周期后验证集的准确率进行监控，并将这个记录点的模型数据（记录点中有各种各样的训练统计数据，比如随着时间的损失值变化等）记录到相关文件中。</p>
<h3 id="只使用单个验证集"><a href="#只使用单个验证集" class="headerlink" title="只使用单个验证集"></a>只使用单个验证集</h3><p>为了让代码更简单，可以只采用一个合理尺寸的验证集，而不是采用几个数据集来交叉验证。</p>
<h3 id="使用随机搜索"><a href="#使用随机搜索" class="headerlink" title="使用随机搜索"></a>使用随机搜索</h3><p>比起“网格式”搜索（即相同的间距），随机搜索往往更容易实现也更加好。</p>
<h3 id="对于边界上的最优值要小心"><a href="#对于边界上的最优值要小心" class="headerlink" title="对于边界上的最优值要小心"></a>对于边界上的最优值要小心</h3><p>这种情况一般发生在你在一个不好的范围内搜索超参数（比如学习率）的时候。比如我们使用<strong>learning_rate = 10 \</strong> uniform(-6,1)**来进行搜索。假设我们得到一个比较好的值-6，一定要确认你的值不是出于这个范围的边界上，不然你可能错过更好的其他搜索范围,就像这里可能-6是边界值而最好的结果在-8和-6之间。</p>
<h3 id="从粗到细地分阶段搜索"><a href="#从粗到细地分阶段搜索" class="headerlink" title="从粗到细地分阶段搜索"></a>从粗到细地分阶段搜索</h3><p>在实践中，先进行初略范围（比如10 ** [-6, 1]）搜索，然后根据好的结果出现的地方，缩小范围进行搜索。进行粗搜索的时候，让模型训练一个周期就可以了，因为很多超参数的设定会让模型没法学习，或者突然就爆出很大的损失值。第二个阶段就是对一个更小的范围进行搜索，这时可以让模型运行5个周期，而最后一个阶段就在最终的范围内进行仔细搜索，运行很多次周期。</p>
<h2 id="模型集成"><a href="#模型集成" class="headerlink" title="模型集成"></a>模型集成</h2><p>实践中有一个方法总是能提升神经网络几个百分点的准确率，即在训练的时候训练几个独立模型，然后在测试的时候平均它们的预测结果。集成的模型数量增加，算法的结果也单调提升（但提升效果越来越少）。还有模型之间的差异度越大，提升效果可能越好。进行集成有以下几种方法：</p>
<p>1.相同的模型，不同的初始化。</p>
<p>2.使用不同的超参数的模型。这些模型都是分别训练的。</p>
<p>3.如果训练太耗时，可以采用一次训练中不同的记录点（仆程序记录）的模型来进行集成。</p>
<p>4.在训练的时候跑参数的平均值。和上面一点相关的，还有一个也能得到1-2个百分点的提升的小代价方法，这个方法就是在训练过程中，如果损失值相较于前一次权重出现指数下降时，就在内存中对网络的权重进行一个备份。这样你就对前几次循环中的网络状态进行了平均。你会发现这个“平滑”过的版本的权重总是能得到更少的误差。直观的理解就是目标函数是一个碗状的，你的网络在这个周围跳跃，所以对它们平均一下，就更可能跳到中心去。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  我们利用反向传播计算出解析梯度，然后利用计算出的解析梯度来进行参数更新，这里记录一些有些的最优化技巧，但不进行细节分析。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Notes of CS231n:Neural network 3</title>
    <link href="http://yoursite.com/2018/03/10/Notes-of-Deep-Learning-Neural-network-3/"/>
    <id>http://yoursite.com/2018/03/10/Notes-of-Deep-Learning-Neural-network-3/</id>
    <published>2018-03-10T05:41:24.000Z</published>
    <updated>2018-03-12T08:37:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>  在上一篇文章中，记录了如何构造一个神经网络，比如如何初始化参数，如何选择激活函数和损失函数，应该用哪种方法来防止过拟合等等，在这篇记录中，记录的是如何训练一个神经网络，包括如何学习参数以及如何将超参数最优化。</p>
<a id="more"></a>
<h2 id="梯度检测"><a href="#梯度检测" class="headerlink" title="梯度检测"></a>梯度检测</h2><p>  梯度检测就是把解析梯度和数值梯度进行比较，这里只是记录一些小技巧：</p>
<h3 id="使用中心化公式而不是有限差值来近似"><a href="#使用中心化公式而不是有限差值来近似" class="headerlink" title="使用中心化公式而不是有限差值来近似"></a>使用中心化公式而不是有限差值来近似</h3><p>即使用[f(x+h)+f(x-h)]/2h来计算数值梯度，该公式计算出的梯度会近似于O(h^2)，该结果是通过对f(x+h)，f(x-h)进行泰勒展开得到的。</p>
<h3 id="使用相对误差来进行梯度检测"><a href="#使用相对误差来进行梯度检测" class="headerlink" title="使用相对误差来进行梯度检测"></a>使用相对误差来进行梯度检测</h3><p>我们知道数值梯度和解析梯度的差值正负值都有可能，很明显我们需要取这个差值的绝对值，但是我们不得不考虑实际梯度的大小，即我们要考虑这个误差绝对值占实际梯度的百分比，如果梯度是1000，误差是0.1和梯度是1e-4梯度是1.0，实际上比率是一样的，如果一个梯度是1而误差达到了0.5这个样子显然我们就得考虑梯度计算是不是错了。</p>
<p>所以我们利用|f’[a]-f’[n]|/max(f’[a],f’[n])来计算相对误差作为我们的误差值，这是一个比率值，我们倾向于在实践中采用这种判断：</p>
<p>相对误差&gt;1e-2时，梯度可能出错了</p>
<p>1e-2&gt;相对误差&gt;1e-4：这个值可能不是很好，但勉强说得过去</p>
<p>1e-4&gt;相对误差：可以接受</p>
<p>1e-7或者更小：比较完美了</p>
<h3 id="注意误差伴随深度积累"><a href="#注意误差伴随深度积累" class="headerlink" title="注意误差伴随深度积累"></a>注意误差伴随深度积累</h3><p><strong>有时候我们还是得视情况而定</strong>，要知道误差是在不断积累的，随着深度的加深误差也在不断增大，那么我们可以改变上面的策略，比如一个网络深度达到数十层时1e-2就是可以接受的了。</p>
<h3 id="注意目标函数中存在的不可导点"><a href="#注意目标函数中存在的不可导点" class="headerlink" title="注意目标函数中存在的不可导点"></a>注意目标函数中存在的不可导点</h3><p>ReLU等函数存在着不可导点，我们知道ReLU中如果出现了x&lt;0的情况，在该点梯度就是0，但是如果这个x值比较小，比如-0.000001我们增加了一个小的增量h，可能此时的h就不是负数了，f(x+h)在可导的点上，从而梯度检查认为这个梯度计算错了。</p>
<p><strong>使用少量数据点。</strong>解决上面的不可导点问题的一个办法是使用更少的数据点。因为含有不可导点的损失函数(例如：因为使用了ReLU或者边缘损失等函数)的数据点越少，不可导点就越少，所以在计算有限差值近似时越过不可导点的几率就越小。还有，如果你的梯度检查对2-3个数据点都有效，那么基本上对整个批量数据进行梯度检查也是没问题的。所以使用很少量的数据点，能让梯度检查更迅速高效。</p>
<h3 id="梯度检查中h的设置"><a href="#梯度检查中h的设置" class="headerlink" title="梯度检查中h的设置"></a>梯度检查中h的设置</h3><p>h并不是越小越好，太小了会遇到精度和数值问题，一般可以设置为1e-4或者1e-6</p>
<h3 id="梯度检查前先“预热”"><a href="#梯度检查前先“预热”" class="headerlink" title="梯度检查前先“预热”"></a>梯度检查前先“预热”</h3><p>我们的梯度检查只是在参数空间中一个特定的单独的点进行的，所以并不能很稳的确定全局梯度都正确。一般来说我们不再一开始就进行梯度检查，而是等到损失函数开始下降之后在进行梯度检查。</p>
<h3 id="当心正则化损失"><a href="#当心正则化损失" class="headerlink" title="当心正则化损失"></a>当心正则化损失</h3><p>上一文记录损失函数最后的值是正则化损失和数据损失的和，有些情况梯度主要来源于正则化部分，因此会掩盖数据损失梯度不正确的事实。为了防止这种情况出现我们可以先关掉正则化对数据损失做单独检查，当然这也做会导致我们需要再对正则化损失做单独检查。</p>
<h3 id="关闭随机失活和数据扩张"><a href="#关闭随机失活和数据扩张" class="headerlink" title="关闭随机失活和数据扩张"></a>关闭随机失活和数据扩张</h3><p>在进行梯度检查时，记得关闭网络中任何不确定的效果的操作，比如随机失活，随机数据扩展等。不然它们会在计算数值梯度的时候导致巨大误差。关闭这些操作不好的一点是无法对它们进行梯度检查（例如随机失活的反向传播实现可能有错误）我们可以在计算f(x+h)和f(x-h)时强制增加一个特定是随机种子，在计算解析梯度时也同样如此。</p>
<h3 id="检查少量的维度"><a href="#检查少量的维度" class="headerlink" title="检查少量的维度"></a>检查少量的维度</h3><p>在实际中，梯度可以有上百万的参数，在这种情况下只能检查其中一些维度然后假设其他维度是正确的。注意：确认在所有不同的参数中都抽取一部分来梯度检查。在某些应用中，为了方便，人们将所有的参数放到一个巨大的参数向量中。在这种情况下，例如偏置就可能只占用整个向量中的很小一部分，所以不要随机地从向量中取维度，一定要把这种情况考虑到，确保所有参数都收到了正确的梯度。</p>
<h2 id="跟踪各个重要数值"><a href="#跟踪各个重要数值" class="headerlink" title="跟踪各个重要数值"></a>跟踪各个重要数值</h2><p>  跟踪并可视化我们的训练过程可以让我们尽早的发现一些问题，我们所跟踪的一般是一些比较重要的数值，我们通常每个<strong>周期</strong>进行一轮跟踪，这里的<strong>周期</strong>衡量了在训练中每个样本数据都被观察过次数的期望（一个周期意味着每个样本数据都被观察过了一次）。</p>
<p>1.跟踪损失值</p>
<p>以周期为x轴度量，损失值的曲线往往会反应我们所设置的学习率的问题，比如：</p>
<p><img src="\img\loss_learningrate.png" alt="loss_learningrate"></p>
<p>上图左图中我们可以观察到学习率与损失值的关系，右图则反应了损失值的震荡程度，这与批尺寸（batch size）有关（这里的批指的是我们一般把训练集拆分成多个批次，每次取一个训练），如果批尺寸太小了比如1，那么每次修正方向以各自样本的梯度方向修正，难以达到收敛震荡幅度就大，而如果以整个训练集大小为批尺寸则震荡幅度最小，但是这并不是一个好的想法，首先内存容量增加，第二我们可能得不到最好的结果，batchsize 的正确选择是为了在内存效率和内存容量之间寻找最佳平衡，比如我们可以看下图：</p>
<p><img src="\img\lU3sx.png" alt="lU3sx"></p>
<p>红色代表批尺寸为1，绿色为一个适中的尺寸，蓝色为不分批次，即全尺寸，我们可以观察到震荡程度是不同的。</p>
<p>2.跟踪训练集和验证集的准确率</p>
<p>跟踪准确率可以知道我们的模型是不是过拟合了，如图：</p>
<p><img src="\img\QQ图片20180310170549.png" alt="QQ图片20180310170549"></p>
<p>如果观察到我们的模型过拟合了，就应该增大正则化强度，比如调高随机失活率p，或者将L1损失换位到L2损失，采用更丰富的数据集等等，当然如果你的模型太小也会导致过拟合，这时候我们就应该考虑更换更大的模型了。</p>
<p>3.跟踪权重的跟新比例</p>
<p>  权重中更新值的数量和全部值的数量之间的比例也是我们值得更新的。注意：是<em>更新的</em>，而不是原始梯度（比如，在普通sgd中就是梯度乘以学习率）。需要对每个参数集的更新比例进行单独的计算和跟踪。一个经验性的结论是这个比例应该在1e-3左右。如果更低，说明学习率可能太小，如果更高，说明学习率可能太高。</p>
<p>4.跟踪每层激活数据和梯度分布</p>
<p>  我们可以观察激活函数的输出，把这些数据变成柱状与表示会更明显，比如对于tanh函数，如果神经元输出总是0，或者总是-1或1，那说明可能出现了某些问题了。</p>
<p>5.如果是图像数据考虑将第一层特征可视化</p>
<p>如果需要做的是图像方面的识别，我们考虑将第一层特征显示出来，比如：</p>
<p><img src="\img\96573094f9d7f4b3b188069726840a2e_r.jpg" alt="96573094f9d7f4b3b188069726840a2e_r"></p>
<p>  上图中，很明显前面的图，特征非常不平滑，很多噪点，而后面则好得多，一般如果我们训练模型得到的是第一张图这种特征你需要仔细考虑是不是要重新训练模型了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  在上一篇文章中，记录了如何构造一个神经网络，比如如何初始化参数，如何选择激活函数和损失函数，应该用哪种方法来防止过拟合等等，在这篇记录中，记录的是如何训练一个神经网络，包括如何学习参数以及如何将超参数最优化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Notes of CS231n:Neural network 2</title>
    <link href="http://yoursite.com/2018/03/01/Notes-of-Deep-Learning-Neural-network-2/"/>
    <id>http://yoursite.com/2018/03/01/Notes-of-Deep-Learning-Neural-network-2/</id>
    <published>2018-03-01T02:26:43.000Z</published>
    <updated>2018-03-12T08:36:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>  从上一篇博文，我们知道，神经网络其实就是一个一系列线性映射和非线性激活函数交织起来的评分函数，我们在输入层输入我们的数据，经过隐层的一系列点积和激活函数计算在输出层得到一个类型评分，然而要比较好地训练一个神经网络，我们需要更多的考虑，比如数据预处理，我们还需要考虑权重的初始值以及如何选择激活函数。</p>
<h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>  我们通常会对<strong>训练集</strong>数据进行预处理，当然这可能有很多种形式，比如我们如果要去除一些噪声可能要进行数据清洗，这一部分这里先不介绍了，我们这里主要介绍归一化，归一化可以有利于避免模型训练时出现数值问题，还有利于网络快速收敛，更具体的优点你可以查看<a href="http://nnetinfo.com/nninfo/showText.jsp?id=37" target="_blank" rel="external">这里</a>。</p>
<p>  归一化（Normalization）即把数据的所有维度都归一化，使其数值范围都近似相等，这个种预处理操作只在确信不同输入特征有不同的输入范围时才有意义，对于图像处理中，像素的范围都是0-255，所以这样做对于图片数据意义不大，但是数据如果是表示一个人，（体重（kg），身高（m），年龄）,这样的数据显然60Kg的体重和1.7m的身高不太对等，这会产生一些数值问题，我们有必要进行归一化。这里有两种方式进行<strong>归一化</strong>：</p>
<p>先假设数据矩阵M，尺寸是N*D,N为样本数目，D是数据维度</p>
<p>第一种：对数据先做零中心化(zero-centered)，如果用numpy表示：M-=np.mean(X,axis=0)，然后我们对每个维度都除以它的标准差就可以了，M/=np.std(X,axis=0)。</p>
<p>第二种：对每个维度归一化使得每个维度的最大和最小值是1和-1。</p>
<a id="more"></a>
<p>  实际上零中心化单独也可以看成是一种预处理操作，被称作是<strong>均值减法</strong>在实际中用的也比较多，另外由于近来BN层的引入，归一化在有BN层的情况下也就没有必要了，因为每次卷积后BN层会把数据拉到0均值1方差的分布（标准高斯分布）上，并且这个均值和方差还是更加精确的动态统计出来的，而非原始输入上统计，因此在BN引入后归一化没什么必要。</p>
<p>  我在前面就说过，数据预处理，归一化只是一种情况，还可能进行数据清洗，数据增强，白化和PCA等等操作，图片处理中有时候我们还会转换图片的格式，这也是一种预处理。预处理在模型训练中非常重要，有时候甚至决定着学习算法本身的好坏。</p>
<h2 id="权重初始化"><a href="#权重初始化" class="headerlink" title="权重初始化"></a>权重初始化</h2><p>  要训练我们的网络，我们确定好我们需要一个怎么样的模型，然后构建一个最开始的网络，这样的话，网络中各种参数的初始值就显得非常重要，权重就是其中之一。</p>
<p>  一些人可能会认为把权重都设置为0比较好，然而仔细思考一下，如果一开始整个网络中每一个神经元的输出都是一样的（权重相同），那么反向传播中他们会输出同样的梯度，从而进行同样的更新，这显然就是不对的，你相当于复制了神经元。</p>
<p>  因为数据进行了适当的归一化，又要避免相同的参数更新，我们可以让权重的初始值接近于0，但是却又不等于0，为了得到不同的权重，我们可以以随机数产生器器来初始化我们的权重，这里我们产生的随机数可以服从正态分布或者均匀分布。需要注意的时，最好不要让随机值太小，因为太小的权重值会导致计算出的额梯度非常小，以至于一致我们在反向传播中的梯度信号。</p>
<p>  为了保证神经元起始时有近似相同的输出分布，我们必须想办法校准方差，一般的方法是采用1/sqrt(N)，来做校准，其中N是输入数据的数量，这样我们可以把输出数据的分布的方差校准到1，如果用numpy表示，即：w=np.random.randn(N)/sqrt(n)。</p>
<p>  有一种被称作<strong>稀疏初始化</strong> 的方法，将索引权重设置为0，但是为了避免相同的参数更新，每个神经元都同下一层固定数目的神经元随机连接，连接权重的数值由一个小的高斯分布生成。</p>
<p>  当前比较推荐的方法是在激活函数是ReLU的情况下使用，w=np.random.randn(N)/sqrt(2/n)来进行权重初始化，另外我们一般把偏置设置为0。</p>
<p>  上面介绍数据预处理的时候我们提到过一个被称为BN层(Batch Normalization)的东西，中文翻译是：<strong>批量归一化</strong>，它不仅可以避免<strong>归一化</strong>操作，也可以帮助我们解决初始化神经网络这个问题，我们通常会在全连接或者卷积层与激活函数之间添加一个BN层，让数据服从标准高斯分布，详细操作可以看这篇<a href="https://arxiv.org/abs/1502.03167" target="_blank" rel="external">文章</a>。</p>
<h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><p>  我们在上一篇文章中知道了，正则化是避免过拟合的好方法，正则化也有很多种,比如最常见的L2正则化，以及你听的非常多的随机失活(dropout)方法。</p>
<h3 id="L1，L2正则化"><a href="#L1，L2正则化" class="headerlink" title="L1，L2正则化"></a>L1，L2正则化</h3><p>1.L2正则化</p>
<p>  <strong>L2正则化的思想是对大数值的权重向量进行严厉的惩罚，从而倾向于权重向量更加分散，即使网络更倾向于使用所有的特征。</strong>实际操作是对网络中的每个权重w，向目标函数中增加一个<strong>1/2（λ*w^2)</strong>,λ是正则化强度，而乘上常数1/2是数学上的小技巧，即让求导后梯度变成λw，而非2λw。在梯度下降和参数更新的时候，使用L2正则化意味着所有的权重都以<strong>w += -lambda * W</strong>向着0线性下降。</p>
<p>2.L1正则化</p>
<p>  <strong>L1正则化则倾向于让神经元最后使用它们最重要输入数据的稀疏子集，可看做特征选择</strong>，它的实际操作是对每个w都像目标函数增加一个λ*|w|，这样的话，你可以知道求导的时候，附加项的导数就与w的符号有关，如果w为正，最优化更新后的w变小（相比与没有添加L1正则项时），如果为负则更新后的w变大，即尽可能使权重值为0。在w为0时，我们把取符号的sgn(w）看作是0，即sgn(0)=0,sgn(w&gt;0)=1,sgn(w&lt;0)=-1。</p>
<p>一般来说，实践更倾向于使用L2正则化，除非我们需要特征选择。</p>
<h3 id="随机失活"><a href="#随机失活" class="headerlink" title="随机失活"></a>随机失活</h3><p>  目前我们经常看到随机失活(dropout)的字眼，<strong>其与L1，L2正则化，以及最大范式约束的方法互为补充</strong>，实际操作过程中，随机失活即是让神经元以超参数p为概率被设置为0或者被激活,<strong>p一般设置为0.5</strong>，这样我们可以看做对完整的神经网络抽样出一些子集，每次基于输入数据只更新子网络的参数。</p>
<p><img src="\img\dropout.jpg" alt="dropout"></p>
<p>  但实际上我们更倾向于使用Inverted dropout，这是因为如果我们在训练网络时使用前向随机失活，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_step</span><span class="params">(X)</span>:</span></div><div class="line">  <span class="comment"># 3层neural network的前向传播</span></div><div class="line">  H1 = np.maximum(<span class="number">0</span>, np.dot(W1, X) + b1)</div><div class="line">  U1 = np.random.rand(*H1.shape) &lt; p <span class="comment"># 第一个随机失活遮罩</span></div><div class="line">  H1 *= U1 <span class="comment"># drop!</span></div><div class="line">  H2 = np.maximum(<span class="number">0</span>, np.dot(W2, H1) + b2)</div><div class="line">  U2 = np.random.rand(*H2.shape) &lt; p <span class="comment"># 第二个随机失活遮罩</span></div><div class="line">  H2 *= U2 <span class="comment"># drop!</span></div><div class="line">  out = np.dot(W3, H2) + b3</div></pre></td></tr></table></figure>
<p>  上面这段代码中有p的概率，神经元会被激活，而又1-p的概率神经元会被设置为0，然后流向下一层，那么我们可以知道在随机失活进行后，输出为px，而在我们的测试过程中并不存在随机失活层，所以神经元对输入都是可见的，那么为了保持同样的预期输出，我们必须在测试时把输出结果乘以p,来缩放激活函数输出结果，以防止测试输出数值范围大于训练输出，如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(X)</span>:</span></div><div class="line">  <span class="comment"># 前向传播时模型集成</span></div><div class="line">  H1 = np.maximum(<span class="number">0</span>, np.dot(W1, X) + b1) * p <span class="comment"># 注意：激活数据要乘以p</span></div><div class="line">  H2 = np.maximum(<span class="number">0</span>, np.dot(W2, H1) + b2) * p <span class="comment"># 注意：激活数据要乘以p</span></div><div class="line">  out = np.dot(W3, H2) + b3</div></pre></td></tr></table></figure>
<p>  这样的话测试时要多乘一次p显得非常麻烦，为了让我们的测试效率更高，各种深度学习框架中实践的其实是inverted dropout,有翻译为<strong>反向随机失活</strong>，个人觉得这个翻译不太好，<strong>其实它就是在训练阶段对激活函数输出值进行放大，即是放大1/p倍，而测试阶段则保持不变。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_step</span><span class="params">(X)</span>:</span></div><div class="line">  <span class="comment"># 3层neural network的前向传播</span></div><div class="line">  H1 = np.maximum(<span class="number">0</span>, np.dot(W1, X) + b1)</div><div class="line">  U1 = (np.random.rand(*H1.shape) &lt; p) / p <span class="comment"># 第一个随机失活遮罩. 注意/p!</span></div><div class="line">  H1 *= U1 <span class="comment"># drop!</span></div><div class="line">  H2 = np.maximum(<span class="number">0</span>, np.dot(W2, H1) + b2)</div><div class="line">  U2 = (np.random.rand(*H2.shape) &lt; p) / p <span class="comment"># 第二个随机失活遮罩. 注意/p!</span></div><div class="line">  H2 *= U2 <span class="comment"># drop!</span></div><div class="line">  out = np.dot(W3, H2) + b3</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(X)</span>:</span></div><div class="line">  <span class="comment"># 前向传播时模型集成</span></div><div class="line">  H1 = np.maximum(<span class="number">0</span>, np.dot(W1, X) + b1) <span class="comment"># 不用数值范围调整了</span></div><div class="line">  H2 = np.maximum(<span class="number">0</span>, np.dot(W2, H1) + b2)</div><div class="line">  out = np.dot(W3, H2) + b3</div></pre></td></tr></table></figure>
<h2 id="损失函数的选择"><a href="#损失函数的选择" class="headerlink" title="损失函数的选择"></a>损失函数的选择</h2><p>  我们知道在<strong>分类问题中</strong>两个最常见的分类器对应的损失计算：</p>
<p>  SVM-&gt;折页损失/平方折页损失（下图没列出）</p>
<p>  Softmax-&gt;交叉熵损失</p>
<p><img src="\img\loss.jpg" alt="loss"></p>
<p>  如果我们面对的不是一个一般的分类问题，怎么办呢？上面的几种损失公式都只正确作用在每个样本只有一个正确的标签yi的假设成立的情况之下。但是你可以看到，在hexo博客中的一篇文章是可以打几个标签的，亦或者是新浪微博上的一张图片，比如你的女神正在日本旅游，发了一张在清水寺前不知道谁给它拍了一张照，可以打上美女，日本旅游，快乐等等几个标签。我们可以采取下面的一种损失评分策略：</p>
<p><img src="\img\loss2.png" alt="loss2"></p>
<p>其中yij的值为1或者-1，它表示第i个样本是否被贴上第j个标签，如果是就是1，如果不是就是-1，这样的话，可以发现，当一个正样本的得分小于+1，或者一个负样本得分大于-1的时候，算法就会累计损失值。</p>
<p>  再比如回归问题，比如你要预测北京的空气质量pm2.5的值，一般我们考虑计算预测值和真实值之间的损失，再用L2或者L1范式度量差异。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  从上一篇博文，我们知道，神经网络其实就是一个一系列线性映射和非线性激活函数交织起来的评分函数，我们在输入层输入我们的数据，经过隐层的一系列点积和激活函数计算在输出层得到一个类型评分，然而要比较好地训练一个神经网络，我们需要更多的考虑，比如数据预处理，我们还需要考虑权重的初始值以及如何选择激活函数。&lt;/p&gt;
&lt;h2 id=&quot;数据预处理&quot;&gt;&lt;a href=&quot;#数据预处理&quot; class=&quot;headerlink&quot; title=&quot;数据预处理&quot;&gt;&lt;/a&gt;数据预处理&lt;/h2&gt;&lt;p&gt;  我们通常会对&lt;strong&gt;训练集&lt;/strong&gt;数据进行预处理，当然这可能有很多种形式，比如我们如果要去除一些噪声可能要进行数据清洗，这一部分这里先不介绍了，我们这里主要介绍归一化，归一化可以有利于避免模型训练时出现数值问题，还有利于网络快速收敛，更具体的优点你可以查看&lt;a href=&quot;http://nnetinfo.com/nninfo/showText.jsp?id=37&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;  归一化（Normalization）即把数据的所有维度都归一化，使其数值范围都近似相等，这个种预处理操作只在确信不同输入特征有不同的输入范围时才有意义，对于图像处理中，像素的范围都是0-255，所以这样做对于图片数据意义不大，但是数据如果是表示一个人，（体重（kg），身高（m），年龄）,这样的数据显然60Kg的体重和1.7m的身高不太对等，这会产生一些数值问题，我们有必要进行归一化。这里有两种方式进行&lt;strong&gt;归一化&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;先假设数据矩阵M，尺寸是N*D,N为样本数目，D是数据维度&lt;/p&gt;
&lt;p&gt;第一种：对数据先做零中心化(zero-centered)，如果用numpy表示：M-=np.mean(X,axis=0)，然后我们对每个维度都除以它的标准差就可以了，M/=np.std(X,axis=0)。&lt;/p&gt;
&lt;p&gt;第二种：对每个维度归一化使得每个维度的最大和最小值是1和-1。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Notes of CS231n:Neural network 1</title>
    <link href="http://yoursite.com/2018/02/28/Notes-of-Deep-Learning-Neural-network-1/"/>
    <id>http://yoursite.com/2018/02/28/Notes-of-Deep-Learning-Neural-network-1/</id>
    <published>2018-02-28T07:17:09.000Z</published>
    <updated>2018-03-12T08:37:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="人工神经元"><a href="#人工神经元" class="headerlink" title="人工神经元"></a>人工神经元</h2><p>  其实神经元这个翻译有点唬人，有些学者也不喜欢借用某些生物词语来蹭热度，他们直接就把所谓的人工神经元称之为单元（unit），结合人工神经网络来看的话，你可以很容易的推测出，它是由这个所谓的人工神经元组成的。在一个人工神经网络中，神经元间会有一种单向的影响，因为人工神经网络可以看做是一张有向无环图。下图是一个常见的粗糙模型：</p>
<div align="center"><br><br><img width="600px" src="\img\QQ图片20180214181505.png"><br><br><img src="\img\QQ图片20180214180333.jpg"><br><br></div>

<p>从这张图中你可以看到，一个人工神经元有几个主要的部分，如果你把它看做是有向无环图里的一个节点，那么你可以观察到它的每一个入度，分别对应一个不同的输入和一个自身权重的乘积（w和x都是向量或者矩阵，这里准确来说应该是<strong>点积</strong>），所有入度的点积的累加加上节点对应的偏差值（偏置）(Σwixi+b）代入所入节点的激活函数，图中就是f，对应为f(Σwixi+b),然后这个输出结果（<strong>激活率</strong>）顺着节点的出度流入下一层网络中的神经元。</p>
<p>  现在你大概知道什么是所谓的人工神经元，如果硬要跟生物神经元扯上一毛钱关系的话，你学过高中生物，大概会知道突触，树突，突触小泡之类的，你也许能把这个和两个神经细胞里通过突触来传递兴奋的机制联系起来…然后对别人吹嘘一波，但是我是做不到的，可能是我不怎么了解生物吧。 </p>
<a id="more"></a>
<h2 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h2><p>  认识了人工神经元之后，我们就知道了这里面有一个叫做<strong>激活函数（activation function）</strong>的重要概念，激活函数的选择对最终训练出来的模型影响是很大的，如果你以前看过一些公众号中推送的文章，可能会经常看到Sigmoid和Tanh这样的字眼，这是都是激活函数的名称，但是你不要看着这些名字这么奇怪就觉得这个函数会不会很复杂啊，其实稍微用点脑子思考一下就知道激活函数不能是多么复杂的函数，因为我们最后需要通过反向传播这样的算法去计算梯度，从而进行参数调优，如果这个激活函数是非常复杂的，这个梯度就不太好算了，激活函数通常都是非线性函数，目的是为了模型有更强的表达能力，详情可以<a href="https://www.zhihu.com/question/22334626" target="_blank" rel="external">参考这里</a>，排名前几的答案基本上把这个问题讲清楚了。这里我记录3个激活函数：</p>
<h3 id="S型函数"><a href="#S型函数" class="headerlink" title="S型函数"></a>S型函数</h3><p>  S型函数就是Sigmoid，如果在你学高等数学或者微积分的时候，肯定是接触过这个函数的，这个函数由于它在平面直角坐标系上的曲线而得名。即：</p>
<blockquote>
<p>σ（x）=1/(1+e^(-x))</p>
</blockquote>
<p><img src="\img\QQ图片20180214194819.png" alt="QQ图片20180214194819"></p>
<h3 id="Tanh函数"><a href="#Tanh函数" class="headerlink" title="Tanh函数"></a>Tanh函数</h3><p>  Tanh函数是有S型函数转化过来的零中心函数，Tanh比S型函数更受欢迎，但是他们存在着饱和问题，即在接近极值的区间，梯度几乎为0，训练模型的时候使用反向传播算法，一个接近0的梯度反向传播下去，小数相乘会以指数形式收缩到0。</p>
<blockquote>
<p>tanh=2σ(2x)-1=2/(1+e^(-2x))-1</p>
</blockquote>
<p><img src="\img\QQ图片20180214195043.png" alt="QQ图片20180214195043"></p>
<h3 id="ReLU函数"><a href="#ReLU函数" class="headerlink" title="ReLU函数"></a>ReLU函数</h3><p>目前最流行的激活函数,非常简单粗暴有效,名字的由来是Rectified Linear Unit-&gt;ReLU</p>
<blockquote>
<p>ReLu(x)=max(0,x)</p>
</blockquote>
<p><img src="\img\QQ图片20180214200631.png" alt="QQ图片20180214200631"></p>
<h2 id="神经网络结构"><a href="#神经网络结构" class="headerlink" title="神经网络结构"></a>神经网络结构</h2><p>我们通过一个普通的神经网络来展开对它的层结构认知，比如下面这个两层的网络：</p>
<p><img src="\img\NN.jpg" alt="NN"></p>
<p>  一般来说输入层是不算做层数的，所以说这个网络是2层，即一个隐层和输出层，当然有些网络有很多隐层，我们在这个图片上看到的是一个有向无环图，但是经过前面的理解，你知道实际上它是一个做矩阵点积的数学函数。</p>
<p>  在这个普通的网络中，它的层都是<strong>全连接层</strong>，全连接层中的神经元与其前后两层的神经元是完全成对连接的，但是在同一个全连接层内的神经元之间没有连接。</p>
<p>  在神经网络中，输出层是没有激活函数的，因为它用来完成分类的打分。有时候我们要表示一个神经网络的尺寸，比如上面那个神经网络是怎么样的尺寸呢，它有着4（隐层）+2（输出层）=6个神经元，因为是全连接的，它有着3*4+4*2=20个权重，以及4+2=6个偏置，权重和偏置都是可学习的，那么我们训练这个神经网络的时候需要学习这个26个参数，以最优化算法求得他们的最优值。这样看起来似乎比较清晰了，但是一般的卷积神经网络有着10-20层，1亿个可学习参数，要求这个1一个参数的最优值可不是一个简单的工程，这也是为什么大部分做深度学习的同学都处在调参的路上的原因了。</p>
<p>  是不是层数越多的神经网络越好呢?视情况而定，一般的神经网络就是3层网络，再增加层数很难增强它的表达力度，而卷积神经网络则不同，因为要提取层次化特征，所以深度就是一个很重要的问题，一般都是数十层之多，谈到这个问题，我们又有新的问题，如何设置神经网络的层数和尺寸。我们知道神经网络其实是一个函数，如果在有着相同激活函数的情况下，整个函数更为复杂，则函数的表达能力就能更强，但是也会引起<strong>过拟合</strong>等问题，<strong>过拟合</strong>是指网络对数据中的噪点拟合过甚，导致整个模型的泛化能力不强。</p>
<p>  即便大的网络会有过拟合问题，我们还是会使用更大一点的网络作为模型，因为防止过拟合还有其他的方法，比如<strong>L2正则化或者dropout</strong>，特别是正则化。因此我们没有必要去牺牲整个网络模型的表达能力去换去泛化能力。另外小网络的极小值很容易收敛到，但是这些极值的损失值一般都很高，不利于我们构建一个优秀的模型，而大的网络极小值更多，虽然更不容易收敛，但是我们可以有更多的选择，从而得到一个更好的模型。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;人工神经元&quot;&gt;&lt;a href=&quot;#人工神经元&quot; class=&quot;headerlink&quot; title=&quot;人工神经元&quot;&gt;&lt;/a&gt;人工神经元&lt;/h2&gt;&lt;p&gt;  其实神经元这个翻译有点唬人，有些学者也不喜欢借用某些生物词语来蹭热度，他们直接就把所谓的人工神经元称之为单元（unit），结合人工神经网络来看的话，你可以很容易的推测出，它是由这个所谓的人工神经元组成的。在一个人工神经网络中，神经元间会有一种单向的影响，因为人工神经网络可以看做是一张有向无环图。下图是一个常见的粗糙模型：&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;img width=&quot;600px&quot; src=&quot;\img\QQ图片20180214181505.png&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;\img\QQ图片20180214180333.jpg&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;/div&gt;

&lt;p&gt;从这张图中你可以看到，一个人工神经元有几个主要的部分，如果你把它看做是有向无环图里的一个节点，那么你可以观察到它的每一个入度，分别对应一个不同的输入和一个自身权重的乘积（w和x都是向量或者矩阵，这里准确来说应该是&lt;strong&gt;点积&lt;/strong&gt;），所有入度的点积的累加加上节点对应的偏差值（偏置）(Σwixi+b）代入所入节点的激活函数，图中就是f，对应为f(Σwixi+b),然后这个输出结果（&lt;strong&gt;激活率&lt;/strong&gt;）顺着节点的出度流入下一层网络中的神经元。&lt;/p&gt;
&lt;p&gt;  现在你大概知道什么是所谓的人工神经元，如果硬要跟生物神经元扯上一毛钱关系的话，你学过高中生物，大概会知道突触，树突，突触小泡之类的，你也许能把这个和两个神经细胞里通过突触来传递兴奋的机制联系起来…然后对别人吹嘘一波，但是我是做不到的，可能是我不怎么了解生物吧。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Junit(4):Mock</title>
    <link href="http://yoursite.com/2018/02/01/Junit-4-Mock/"/>
    <id>http://yoursite.com/2018/02/01/Junit-4-Mock/</id>
    <published>2018-02-01T08:29:46.000Z</published>
    <updated>2018-02-01T15:39:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>  就像上篇文章所说，我们还可以用mock方式模拟一个没有完成的模块，从而完成测试，事实上如果测试的业务比较繁琐，比如涉及到输入啥的，我们也可以mock一个假的输入对象，mock object是在极限编程里提出的，而今天它已经广泛用于软件测试领域。</p>
<p>  就如mock这个单词的词义一样，mock object即是一个模制的对象，但这个对象的行为是人为故意给定的，不包含实际的业务。这样说可能非常抽象，如果让我们考虑用<strong>Scala</strong>写一个在商店里用pos机刷卡的例子,比如我们刷卡并且输入密码后会构造出这样的一个CreditCard对象：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">CreditCard</span>(<span class="params">val cardId:<span class="type">String</span>,val password:<span class="type">String</span></span>)</span></div></pre></td></tr></table></figure>
<p> 而我们的Pos机要负责转账处理：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pos</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">transfer</span></span>(amount:<span class="type">Double</span>,creditCard: <span class="type">CreditCard</span>, creditCard2: <span class="type">CreditCard</span>, accountManager: <span class="type">AccountManager</span>): <span class="type">Unit</span> = &#123;</div><div class="line">    <span class="keyword">val</span> account1: <span class="type">Account</span> = accountManager.findAccount(creditCard.cardId, creditCard.password);</div><div class="line">    <span class="keyword">val</span> account2: <span class="type">Account</span> = accountManager.findAccount(creditCard2.cardId, creditCard2.password);</div><div class="line">    accountManager.saveAccount(account1.copy(account1.balance - amount,account1.creditCard))</div><div class="line">    accountManager.saveAccount(account2 copy(account2.balance + amount, account2.creditCard))</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>，但是问题是此时我们根本没有构造号银行卡账户数据库，甚至我们连dao对象都只是一个接口，那么为了测试Pos代码逻辑能不能正确执行我们该怎么办呢？</p>
<a id="more"></a>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">AccountManager</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">saveAccount</span></span>(account: <span class="type">Account</span>)</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">findAccount</span></span>(cardId: <span class="type">String</span>, password: <span class="type">String</span>): <span class="type">Account</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>答案是我么可以建立一个mock object，这不仅可以很容易的测试Pos的代码逻辑，而且节省了很大的开销，设想一下，如果真正的去测试，我们不仅要确定整个容器环境无误，还要不断地去访问数据库，这肯定是不可以忍受的。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MockAccountManager</span>(<span class="params"></span>) <span class="keyword">extends</span> <span class="title">AccountManager</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> accounMap = <span class="type">Map</span> (</div><div class="line">      (<span class="string">"1001"</span>, <span class="type">Account</span>(<span class="number">1000</span>, <span class="type">CreditCard</span>(<span class="string">"1001"</span>, <span class="string">"123"</span>)))</div><div class="line">      , (<span class="string">"1002"</span>, <span class="type">Account</span>(<span class="number">1000</span>, <span class="type">CreditCard</span>(<span class="string">"1002"</span>, <span class="string">"123"</span>)))</div><div class="line">      )</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">findAccount</span></span>(cardId: <span class="type">String</span>, password: <span class="type">String</span>): <span class="type">Account</span> = &#123;</div><div class="line">      <span class="keyword">val</span> x=accounMap(cardId)</div><div class="line">      x <span class="keyword">match</span> &#123;</div><div class="line">        <span class="keyword">case</span> <span class="type">Account</span>(_,password)=&gt;x</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">saveAccount</span></span>(account: <span class="type">Account</span>): <span class="type">Unit</span> = &#123;</div><div class="line">      accounMap = accounMap ++ <span class="type">Map</span> (</div><div class="line">        (account.creditCard.cardId, account)</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样我们就可以利用这个，简单的mock object去测试我们的Pos逻辑了：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">testTransfer</span></span>(): <span class="type">Unit</span> = &#123;</div><div class="line">  <span class="keyword">val</span> pos = <span class="keyword">new</span> <span class="type">Pos</span>();</div><div class="line">  <span class="keyword">val</span> card = <span class="keyword">new</span> <span class="type">CreditCard</span>(<span class="string">"1001"</span>, <span class="string">"123"</span>)</div><div class="line">  <span class="keyword">val</span> card2 = <span class="keyword">new</span> <span class="type">CreditCard</span>(<span class="string">"1002"</span>, <span class="string">"123"</span>)</div><div class="line">  <span class="keyword">val</span> acm = <span class="keyword">new</span> <span class="type">MockAccountManager</span>()</div><div class="line">  pos.transfer(<span class="number">100.2</span>, card, card2, acm)</div><div class="line">  assertEquals(acm.findAccount(card2.cardId, card2.password).balance,<span class="number">1100.2</span>d,<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  我在这里手动写了一个mock object仅仅是为了演示一下大概的思想，实际上我们不需要手动写mock object，有大量的框架帮助我们完成这一点，比如在jvm平台上就有Jmock，EasyMock,Mockito等等，它们借助jvm的反射机制，以代理模式动态的生成了一个新的对象，我们可以给定这个对象特定方法的特定输入输出，十分方便，比如对于猜数字游戏：</p>
<p>随机给定一个4位数字，且每一位的数字都不重复，然后玩家在不知道这个数字的情况下输入一个4位数字每一位都不重复，如果位置相同且数字也相同就得到一个A，如果数字存在但是位置不同就得到B。</p>
<p>如：</p>
<p>给定1234,玩家猜测为1256，则结果为2A0B</p>
<p>给定1234，玩家猜测为3412，则结果为0A4B</p>
<p>如果玩家在6次之内得到了4A0B结果，就输出玩家胜利。</p>
<p>这样的话，我们可以来写一个简单的程序：</p>
<p>首先我们需要输入和输出,以下两个类用来读取数字和输出一个字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//输入</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberReader</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        String inputNumber = scanner.next();</div><div class="line">        <span class="keyword">if</span> (StringUtils.isNumeric(inputNumber) &amp;&amp; inputNumber.length() == <span class="number">4</span>) &#123;</div><div class="line">            <span class="keyword">return</span> inputNumber;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Invalid Input"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//输出</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Printer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String message)</span> </span>&#123;</div><div class="line">        System.out.println(message);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们需要一个随机数字生成器,它可以随机生成一个4位不同数字组成的字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberGenerator</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generate</span><span class="params">()</span> </span>&#123;</div><div class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>);</div><div class="line">        Collections.shuffle(list);</div><div class="line">        <span class="keyword">return</span> String.join(<span class="string">""</span>, list.subList(<span class="number">0</span>, <span class="number">4</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们需要一种数字类,它有一个比较方法，输出xAxB这样的表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Number</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMBER_LENGTH = <span class="number">4</span>;</div><div class="line">    <span class="keyword">private</span> String value;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Number</span><span class="params">(String value)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">compare</span><span class="params">(String stringToCompare)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUMBER_LENGTH; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (value.charAt(i) == stringToCompare.charAt(i)) &#123;</div><div class="line">                a++;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value.contains(stringToCompare.substring(i, i + <span class="number">1</span>))) &#123;</div><div class="line">                b++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> a + <span class="string">"A"</span> + b + <span class="string">"B"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后我们把上面的组件组成一个游戏：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Game</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String WIN_CODE = <span class="string">"4A0B"</span>;</div><div class="line">    <span class="keyword">private</span> Printer printer;</div><div class="line">    <span class="keyword">private</span> Number generatedNumber;</div><div class="line">    <span class="keyword">private</span> NumberReader reader;</div><div class="line"></div><div class="line">    <span class="comment">//我们有6次机会</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> remainingGuessCount = <span class="number">6</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Game</span><span class="params">(NumberGenerator numberGenerator, Printer printer, NumberReader reader)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.printer = printer;</div><div class="line">        <span class="keyword">this</span>.reader = reader;</div><div class="line">        <span class="keyword">this</span>.generatedNumber = <span class="keyword">new</span> Number(numberGenerator.generate());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">        printer.print(<span class="string">"please input a 4 digit number:"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (remainingGuessCount &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">              <span class="comment">//比较数字输入和生成的随机数</span></div><div class="line">                String result = generatedNumber.compare(reader.read());</div><div class="line">                <span class="keyword">if</span> (WIN_CODE.equals(result)) &#123;</div><div class="line">                    printer.print(<span class="string">"you win"</span>);</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                printer.print(result);</div><div class="line">                <span class="keyword">this</span>.remainingGuessCount--;<span class="comment">//机会使用了一次，所以减少</span></div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                printer.print(e.getMessage());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        printer.print(<span class="string">"Game Over"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们有一个简单的游戏了，如果玩家6次内猜对了4A0B，那么就输出you win,否则输出Game Over。现在我们要对这个游戏进行测试，但是我们可能会遇到以下的问题：</p>
<p>1.我们需要自动测试，而不是每次都手动输入</p>
<p>这是一个问题，我们的输入类NumberReader，调用的是系统的System.in但是我们却要求自动化测试，而不是每次手动输入，既然如此，我们就需要一种mock object，以代理的手段自动返回我们想输入的数字，我们可以自己手写字段反射，覆盖掉输入流，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberReaderTest</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> NumberReader reader = <span class="keyword">new</span> NumberReader();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setInputStream</span><span class="params">(String input)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</div><div class="line">        Field scannerField = reader.getClass().getDeclaredField(<span class="string">"scanner"</span>);</div><div class="line">        scannerField.setAccessible(<span class="keyword">true</span>);</div><div class="line">        Scanner scannerWithMockedStream = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> ByteArrayInputStream(input.getBytes()));</div><div class="line">        scannerField.set(reader, scannerWithMockedStream);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldReadNumber</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        setInputStream(<span class="string">"1234"</span>);</div><div class="line">        assertEquals(<span class="string">"1234"</span>, reader.read());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span>(expected = Exception.class)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldThrowExceptionForNonNumberInput</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        setInputStream(<span class="string">"123d"</span>);</div><div class="line">        reader.read();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>手写是一种手段，我们可以理解框架大概是怎么做到的，当然其实可以用代理来做，现实情况中我们能够使用mock框架，这里我用的是<a href="https://github.com/mockito/mockito" target="_blank" rel="external">mockito</a>,当然你也可以用其他的框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.junit.Before;</div><div class="line"><span class="keyword">import</span> org.junit.Test;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.Mockito.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameTest</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> NumberGenerator numberGenerator;</div><div class="line">    <span class="keyword">private</span> NumberReader numberReader;</div><div class="line">    <span class="keyword">private</span> Printer printer;</div><div class="line">    <span class="keyword">private</span> Game game;</div><div class="line"></div><div class="line">    <span class="meta">@Before</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="comment">//我们以mock方式生成了:</span></div><div class="line">        numberGenerator = mock(NumberGenerator.class);</div><div class="line">        numberReader = mock(NumberReader.class);</div><div class="line">        printer = mock(Printer.class);</div><div class="line">      <span class="comment">//我们给定generate的返回值必须是4879，因为随机生成一个数字可就不好写expected值了</span></div><div class="line">        when(numberGenerator.generate()).thenReturn(<span class="string">"4879"</span>);</div><div class="line">        game = <span class="keyword">new</span> Game(numberGenerator, printer, numberReader);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们可以写一些简单测试，来体验一下mock的作用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldPrintYouWin</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    when(numberReader.read()).thenReturn(<span class="string">"4879"</span>);</div><div class="line">    game.start();</div><div class="line">  <span class="comment">//使用verify可以在白盒情况下审视代码逻辑是不是正常运转</span></div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"please input a 4 digit number:"</span>);</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"you win"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldPrintYouWinAfterFifthAttempts</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  <span class="comment">//mockito支持我们每次返回不同的值</span></div><div class="line">    when(numberReader.read()).thenReturn(<span class="string">"7849"</span>,<span class="string">"7849"</span>,<span class="string">"7849"</span>,<span class="string">"7849"</span>,<span class="string">"7849"</span>,<span class="string">"4879"</span>);</div><div class="line">    game.start();</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"please input a 4 digit number:"</span>);</div><div class="line">    verify(printer, times(<span class="number">5</span>)).print(<span class="string">"2A2B"</span>);</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"you win"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldPrintYouWinAfterSecondAttempts</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    when(numberReader.read()).thenReturn(<span class="string">"7849"</span>,<span class="string">"4879"</span>);</div><div class="line">    game.start();</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"please input a 4 digit number:"</span>);</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"2A2B"</span>);</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"you win"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldPrintGameOver</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    when(numberReader.read()).thenReturn(<span class="string">"7849"</span>);</div><div class="line">    game.start();</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"please input a 4 digit number:"</span>);</div><div class="line">    verify(printer, times(<span class="number">6</span>)).print(<span class="string">"2A2B"</span>);</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"Game Over"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldRunNormallyAfterThrowsException</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  <span class="comment">//我们还可以设定抛出异常</span></div><div class="line">    when(numberReader.read()).thenThrow(<span class="keyword">new</span> IOException(<span class="string">"IO Exception Test"</span>))</div><div class="line">            .thenReturn(<span class="string">"7849"</span>,<span class="string">"7849"</span>,<span class="string">"7849"</span>,<span class="string">"7849"</span>,<span class="string">"7849"</span>,<span class="string">"4879"</span>);</div><div class="line">    game.start();</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"please input a 4 digit number:"</span>);</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"IO Exception Test"</span>);</div><div class="line">    verify(printer, times(<span class="number">5</span>)).print(<span class="string">"2A2B"</span>);</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"you win"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然上面这些简单的mock，我们也可以手动给它以代理方式写出来，有利于我们理解mockito这类框架的实际工作方式，感兴趣的朋友可以写写看，我这里就不写了~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  就像上篇文章所说，我们还可以用mock方式模拟一个没有完成的模块，从而完成测试，事实上如果测试的业务比较繁琐，比如涉及到输入啥的，我们也可以mock一个假的输入对象，mock object是在极限编程里提出的，而今天它已经广泛用于软件测试领域。&lt;/p&gt;
&lt;p&gt;  就如mock这个单词的词义一样，mock object即是一个模制的对象，但这个对象的行为是人为故意给定的，不包含实际的业务。这样说可能非常抽象，如果让我们考虑用&lt;strong&gt;Scala&lt;/strong&gt;写一个在商店里用pos机刷卡的例子,比如我们刷卡并且输入密码后会构造出这样的一个CreditCard对象：&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CreditCard&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;val cardId:&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;,val password:&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; 而我们的Pos机要负责转账处理：&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Pos&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;transfer&lt;/span&gt;&lt;/span&gt;(amount:&lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;,creditCard: &lt;span class=&quot;type&quot;&gt;CreditCard&lt;/span&gt;, creditCard2: &lt;span class=&quot;type&quot;&gt;CreditCard&lt;/span&gt;, accountManager: &lt;span class=&quot;type&quot;&gt;AccountManager&lt;/span&gt;): &lt;span class=&quot;type&quot;&gt;Unit&lt;/span&gt; = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; account1: &lt;span class=&quot;type&quot;&gt;Account&lt;/span&gt; = accountManager.findAccount(creditCard.cardId, creditCard.password);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; account2: &lt;span class=&quot;type&quot;&gt;Account&lt;/span&gt; = accountManager.findAccount(creditCard2.cardId, creditCard2.password);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    accountManager.saveAccount(account1.copy(account1.balance - amount,account1.creditCard))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    accountManager.saveAccount(account2 copy(account2.balance + amount, account2.creditCard))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;，但是问题是此时我们根本没有构造号银行卡账户数据库，甚至我们连dao对象都只是一个接口，那么为了测试Pos代码逻辑能不能正确执行我们该怎么办呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="软件测试" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
      <category term="TDD" scheme="http://yoursite.com/tags/TDD/"/>
    
      <category term="Junit" scheme="http://yoursite.com/tags/Junit/"/>
    
  </entry>
  
  <entry>
    <title>Junit(3):桩测试</title>
    <link href="http://yoursite.com/2018/01/29/Junit-3-Build-a-stub/"/>
    <id>http://yoursite.com/2018/01/29/Junit-3-Build-a-stub/</id>
    <published>2018-01-29T14:45:51.000Z</published>
    <updated>2018-01-30T15:40:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>  如果我们只是单纯测试一个类里的公共方法，那么使用简单的断言，就能满足我们的需求，可是我们的<strong>测试很多时候要依赖其他的类，或者说环境</strong>，比如你测试的方法可能要访问一些服务器获取资源，或者访问数据库获取数据，此时我们必须需要一个真实的环境么？实际上很多情况下，你根本拿不到真实的环境，比如你测试的是一个还没有完成的服务模块。既然有这种需求，我们就得想办法在开发环境中模拟一个模块来测试，这有两种策略，一种就是stub，还一种就是mock，<strong>这两种方法都是为了代替依赖部分，不同的是mock是构建一个假的对象，而stub是真实地简单实现一个对象</strong>，这一节我先讲这个stub，我们将以stub的方式，模拟一个对一个服务器发送http请求测试。</p>
<a id="more"></a>
<p>  stub是一段代码，常在运行期间代替真实的代码，它的目的在于模拟一个简单的行为，因为真实的代码可能过于复杂，或者根本不可得，使用stub技术就可以允许独立的测试真实代码中的一部分行为，<strong>其实你可以把stub代码理解为是对真实代码一部分行为的简单实现</strong>。</p>
<p>  有时候stub代码很难写，因为他可能要再现真实代码的复杂逻辑，你知道有的系统中即使是以小块功能逻辑也是非常复杂的，所以一般情况下stub只适合代码中的粗粒度部分的测试，以stub代码来代替成熟的外部系统，比如服务器的连接或者数据库。</p>
<p>比如我们要测试下面这个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> xin.saul;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.InputStream;</div><div class="line"><span class="keyword">import</span> java.net.HttpURLConnection;</div><div class="line"><span class="keyword">import</span> java.net.URL;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClient</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">(URL url)</span> </span>&#123;</div><div class="line">        StringBuffer content = <span class="keyword">new</span> StringBuffer();</div><div class="line">        HttpURLConnection connection = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            InputStream stream = url.openStream();</div><div class="line">            <span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2049</span>];</div><div class="line">            <span class="keyword">int</span> len;</div><div class="line">            <span class="keyword">while</span> ((len = stream.read(bs)) != -<span class="number">1</span>) &#123;</div><div class="line">                content.append(<span class="keyword">new</span> String(bs, <span class="number">0</span>, len));</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> content.toString();</div><div class="line">    &#125;</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>假如这个Myclient就是我们所构造应用的客户端，它可以通过url获取一个web资源，我们应该如何去测试它呢？这里会出现几种情况，一种就是我们的服务器已经构建完毕了，那么我们可以直接去测试它，但是很多时候我们的客户端开发完成后，我们的服务器并没有开发完成，那么我们测试前必须去先架构一个apache或者tomcat服务器么？答案肯定是否定的，apache和tomcat启动速度并不是很快，我们有一些代替方案，比如我们以Jetty来写一段stub代码，以模拟我们的客户端和服务器交互过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> xin.saul;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.eclipse.jetty.server.Handler;</div><div class="line"><span class="keyword">import</span> org.eclipse.jetty.server.Request;</div><div class="line"><span class="keyword">import</span> org.eclipse.jetty.server.Server;</div><div class="line"><span class="keyword">import</span> org.junit.Assert;</div><div class="line"><span class="keyword">import</span> org.junit.BeforeClass;</div><div class="line"><span class="keyword">import</span> org.junit.Test;</div><div class="line"></div><div class="line"><span class="keyword">import</span> javax.servlet.ServletException;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.PrintWriter;</div><div class="line"><span class="keyword">import</span> java.net.MalformedURLException;</div><div class="line"><span class="keyword">import</span> java.net.URL;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClientTest</span></span>&#123;</div><div class="line">    <span class="meta">@BeforeClass</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initClass</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Server server = <span class="keyword">new</span> Server(<span class="number">8080</span>);</div><div class="line">        MyClientTest test = <span class="keyword">new</span> MyClientTest();</div><div class="line">        server.setHandler(test.new SayHelloHandler());</div><div class="line">        server.setStopAtShutdown(<span class="keyword">true</span>);</div><div class="line">        server.start();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testClient</span><span class="params">()</span> <span class="keyword">throws</span> MalformedURLException </span>&#123;</div><div class="line">        MyClient client = <span class="keyword">new</span> MyClient();</div><div class="line">        String content = client.getContent(<span class="keyword">new</span> URL(<span class="string">"http://127.0.0.1:8080"</span>));</div><div class="line">        Assert.assertEquals(<span class="string">"Server response"</span>,content);</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SayHelloHandler</span> <span class="keyword">implements</span> <span class="title">Handler</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</div><div class="line">            response.setContentType(<span class="string">"text/plain; charset=utf-8"</span>);</div><div class="line">            response.setStatus(HttpServletResponse.SC_OK);</div><div class="line">            PrintWriter writer = response.getWriter();</div><div class="line">            writer.append(<span class="string">"Server response"</span>);</div><div class="line">            writer.close();</div><div class="line">        &#125;</div><div class="line">      <span class="comment">//注：此处省略了其他的方法重新，直接是ide自动生成的重写，我本人并没有改动</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  可以看到stub代码其实就是很傻乎乎的直接实现一个小模块小功能，当然这里是基于servlet服务,这里我以嵌入式服务器jetty来实现了这段stub，原因是它启动的很快，代码很简单。这里提一点，<strong>我们知道对于单元测试来说每个测试的不相干性是必要的，你不能因为上一个测试的执行而改变了服务器某些状态，于是我们希望没执行一个新的测试都能够拥有一个干净的环境</strong>，这也是诸如@Before这样的注解会做的，但是在打桩测试中你会发现一个jetty嵌入式服务器的启动时间可能是0.5秒，如果你要执行很多个stub测试，那就很有意思了，我不觉得你想在按下测试按钮以后在屏幕前等待十几分钟甚至几十分钟，然后发现某个地方测试没通过，重构之后又等一遍，于是我们可以尝试使用@BeforeClass注解，它只会执行一次，当然<strong>你得保证我们的服务器执行的具体逻辑和测试的执行顺序无关，测试之间不会相互影响</strong>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  如果我们只是单纯测试一个类里的公共方法，那么使用简单的断言，就能满足我们的需求，可是我们的&lt;strong&gt;测试很多时候要依赖其他的类，或者说环境&lt;/strong&gt;，比如你测试的方法可能要访问一些服务器获取资源，或者访问数据库获取数据，此时我们必须需要一个真实的环境么？实际上很多情况下，你根本拿不到真实的环境，比如你测试的是一个还没有完成的服务模块。既然有这种需求，我们就得想办法在开发环境中模拟一个模块来测试，这有两种策略，一种就是stub，还一种就是mock，&lt;strong&gt;这两种方法都是为了代替依赖部分，不同的是mock是构建一个假的对象，而stub是真实地简单实现一个对象&lt;/strong&gt;，这一节我先讲这个stub，我们将以stub的方式，模拟一个对一个服务器发送http请求测试。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="软件测试" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
      <category term="TDD" scheme="http://yoursite.com/tags/TDD/"/>
    
      <category term="Junit" scheme="http://yoursite.com/tags/Junit/"/>
    
  </entry>
  
  <entry>
    <title>Touch ThoughtWorks,Be a ThoughtWorker</title>
    <link href="http://yoursite.com/2018/01/22/Touch-ThoughtWorks-Be-a-ThoughtWorker/"/>
    <id>http://yoursite.com/2018/01/22/Touch-ThoughtWorks-Be-a-ThoughtWorker/</id>
    <published>2018-01-22T09:25:36.000Z</published>
    <updated>2018-01-24T14:55:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>  写下第一句话的时候，发现这好像是2018年第一篇博文，正好此文献给我的公司和即将共事的同事。</p>
<a id="more"></a>
<p>  对于同一期的小伙伴，思特沃克安排了一个文化培训，介绍思特沃克是一家怎么样的公司，而介绍是从同事的视角出发，由前辈自己讲述，领略他们与思特沃克的故事。在github上看到其他办公室的小伙伴好像把这个文化培训叫做思沃大讲堂。由于我个人原因不能去到现场，但是公司很贴心的为不能去到现场的同学准备了远程会议，这点是很值得称赞的。</p>
<p>  对于思特沃克，一定要介绍的肯定就是敏捷开发了，由于我本人是软件工程专业，这个词已经无限次的出现在我的各种书本上，但是事实上，我个人真的没有认认真真用过书上提到的各种开发模式，我相信也是大多数普通学生和我一样所做的都是非商业的练手软件，一般都是“佛性开发”。思特沃克肯定是敏捷方法论用的最出色的企业之一，所以在文化培训的第一天的有两节课讲的是敏捷开发，于我而言可以验证课本和工业界实际的应用有何异同。思特沃克的敏捷开发是有着自己的一套实践的，其的典型的敏捷开发团队角色一般有PM,BA,TL（Tech Lead）,QA,DEV以及UX。思特沃克对于敏捷的实践其实是融入了其骨髓之中，因为公司并不只是在开发时强调敏捷开发，而是整个公司的运作都是这种风格，比如公司很强调协作，回顾反馈，互动交流，甚至在我参加的这个文化培训的课程设置中也看的出来，培训的每一天最后都是一个回顾反馈环节。对于思特沃克有三大支柱，即1.可持续的商业（即首先要养活几千号人),2.卓越的技术(即有技术追求),3.拥护社会和经济正义(这个理由就很多了)。</p>
<div align="center"><br><img width="60%" src="\img\QQ图片20180122200726.jpg"><br><img width="60%" src="\img\mmexport1516621501982.jpg"><br></div><br>  上面第一张图里的小纸片是做回顾会议得出的一些反馈，后面这个板子普通版（叫普通板是因为它很普通，还有海星板等等），上面贴的纸张是回顾会议得到的一些结论，第一栏是well，代表了这次所要回顾的事件做的比较好的地方，第二栏是less well则表示了成员们觉得不太好的地方，可以看到less well还是挺多的，最后一个是puzzle，即不能确定的事情。如果把一个回顾会议开成表彰大会或者批斗大会就没什么意义了，所以在开回顾会议之前会有一个安全系数打分环节，这个打分环节的意义在于：如果小组成员觉得会议中有些人的存在将会影响自己的发言，就可以给一个低分，当组里的平均分低于某个数值的时候，“某些人”就需要被请出会议。这个环节大概意思我知道，但是实际上它是怎么确定哪些人是构成威胁的人，说实话我也不太清楚，因为我是远程参会，而且这次会议的打分并没有出现低于安全阈值的情况。右下角的action（补充完成后即图2），是这次回顾会议的产出物，这个产生出物应该是很明确的指明某个人应该以某个目标为改进的，这里的某个人指的是这个action的owner，你可以看到有些action右边是带名字的，团队在未来会跟踪这些action有没有实际的落实。个人觉得如果回顾会议以及根据action自我改进能够全部在理想情况下全部达到的话，团队的这种成长肯定是无法估量的，但是显然不存在这种理想状态，就像社会主义大概永远都是初级阶段一样，只求能达到社会主义初级阶段7%~12%的增长点也是很不错了。<br><br>  作为一个敏捷入了骨髓的公司，除了快速反馈之外，追求高效的协作也在这次文化培训中体现，主要的方式是通过几个游戏，当然对于一家软件公司，肯定要结合一些软件开发的形式在里面。其中一个游戏是以乐高积木来制造一个动物，以小组为单位，一共会有3轮需求，每轮需要完成一定量，积木材料并不是无限的，而不同轮的需求有可能是冲突的，这很像软件开发，人手有限而需求功能点却不断的变化。由于我是远程视频会议观战的，所以实际操作的小伙伴具体有什么感受我也不得而知了。<br><div align="center"><br><img width="60%" src="\img\mmexport1516621767905.jpg"><br><img width="60%" src="\img\mmexport1516621527004.jpg"><br><img width="60%" src="\img\mmexport1516621518022.jpg"><br><img width="60%" src="\img\mmexport1516621522872.jpg"><br><img width="60%" src="\img\mmexport1516621772621.jpg"><br><img width="60%" src="\img\mmexport1516621469111.jpg"><br><img width="60%" src="\img\mmexport1516621533091.jpg"><br></div><br>  在文化培训中还引入了测试驱动开发和重构的一些概念，当然这里需要完成两个小作业，分别是以mockito补充一个已经写好的小工程的部分单元测试，以及以TDD方式完成一个小工程，这个小工程必须是用git下小步提交的，以至于让检查的前辈知道你用的真的是TDD方式开发，为此写一个小程序我提交了39次。其实我并不很了解软件测试的，软件测试这门课应该是我在学校所有专业课里得分最低的，这源于当时我对软件测试的错误看法，思特沃克对代码质量非常看重，我估摸着也许我应该从新学一遍软件测试这本书。<br><div align="center"><br><img width="60%" src="\img\mmexport1516621460440.jpg"><br></div><br>  在思特沃克工作应该要有快速的学习能力，因为很可能你需要随时切换一种新的编程语言技术栈工作，像python,ruby，C#，Kotlin之类的国内还是用的很多的，有时候你可能要用诸如Sheme,Clojure，Scala这样的语言真刀真枪的实干，注意我这里说的是随时切换，也就是说可能你这个星期还在用java写着代码，下个星期你就要出差到另一个地方，比如深圳，北京，美国，印度，欧洲，用另一种编程语言写代码，当然对于用什么编程语言并不是什么大的问题，因为套路基本上是一样的。思特沃克需要员工能快速的适应新环境，最好能够用英语流利的交流，还希望你能够展现自己，在本次文化培训中也可以看出这一点，比如有个课程主题是演讲，鼓励大家作为一个主角来分享自己的知识和经验。另外由于思特沃克不是996上班，有大把的时间给职工自己把握，对于一个在大学和研究生生活中已经学会了自我驱动的人来说，无疑是一个喜讯，你可以学学诸如日语这样的编程以外的东西，对于那些本身并非计算机专业的应届同事，将有足够的时间去学习诸如编译原理，离散数学之类的重要的稍底层点的知识，你也可以参与很多社区活动，也可以加入公司的兴趣小组参与一些开源项目。当然，理想状态下时间的利用都是非常有价值的，高回报的，实际上可能因人而异，像我这种自我驱动能力比较弱的人，我指望能有30%就满足了。总的来说，思特沃克会给你机会去行万里路，在工作之外会给你时间去读万卷书，能不能利用好就是自己的事情了。<br><div align="center"><br><img width="60%" src="\img\mmexport1516706539552.jpg"><br><img width="60%" src="\img\mmexport1516621606612.jpg"><br><img width="100%" src="\img\mmexport1516621613035.jpg"><br></div>

<p>  好吧，最后祝我早日见到我的可爱的同事们吧，其实还有同一期的两个可爱的女同事也是远程的，没有在这张合照里，当然我也没有在这张合照里，但是为了让同一期同事都出现在一张照片里，我还是以一张我唯一的随意的截图p了一下，变成了下面这张照片。</p>
<p><img src="\img\QQ图片20180123202709_conew1.png" alt="QQ图片20180123202709_conew1"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  写下第一句话的时候，发现这好像是2018年第一篇博文，正好此文献给我的公司和即将共事的同事。&lt;/p&gt;
    
    </summary>
    
    
      <category term="闲谈" scheme="http://yoursite.com/tags/%E9%97%B2%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>冯诺依曼：《数学家》（下）</title>
    <link href="http://yoursite.com/2017/12/20/Von-Neumann-The-Mathematician-part-2/"/>
    <id>http://yoursite.com/2017/12/20/Von-Neumann-The-Mathematician-part-2/</id>
    <published>2017-12-20T08:09:29.000Z</published>
    <updated>2017-12-20T13:20:26.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>本文作者是冯诺依曼，英文名为《The Mathematician》，该文章在1947年发表在《Works of the Mind》上，后来也记录在《von Neumann’s Collected Works》中，这篇文章是我听讲座时偶然得知的，于是看了一下后翻译了出来，才疏学浅，只源于爱好，如有不对多多包涵——2017.12.20</em>  </p>
<p>本文接<a href="http://saul.xin/2017/12/13/Von-Neumann-The-Mathematician-part-1/#more" target="_blank" rel="external">上一部分</a></p>
<a id="more"></a>
<p>  然而，我不想进一步讨论这个问题，我将转向一个完全清晰的案例，即“数学基础”的讨论。在19世纪末和20世纪初，抽象数学的一个新分支——<strong>康托尔</strong>的集合论陷入了困境，某些理论导致了矛盾的结果，虽然这些推论不是集合论的核心”有用“的部分，而且很容易被某些正式标准识别，不过这些都不足以去阐明为什么这些理论的意义要低于集合论的“成功”部分。除了事后洞察到这些理论导致了灾难，但这说不清是什么样的先验动机，以及这种情况下的一致性理论，会允许人们把这些理论与想保留他们的集合论的那部分中分离开来。一个由<strong>罗素和外尔</strong>主导，后由<strong>布劳威尔</strong>总结的详细研究表明，不仅仅是集合论，而是大多数现代数学理论都反感“普遍有效”和“存在”的概念。<strong>布劳威尔</strong>发展了一个没有这些不受欢迎的特点的，被称为“直觉主义”的数学系统，在这个系统中上文提到的集合论困境和矛盾不复存在。然而，现代数学的半壁江山，在其不容置疑的最重要的部分，尤其是在分析方面，也受到这此“净化”的影响：它们要么变得无效，要么在证明时伴随次要的考虑非常复杂。在后一个过程中，会使理论明显丧失有效的普遍性和证明的优雅。然而，<strong>布劳威尔和外尔</strong>依然认为有必要根据这些观点修改数学严谨的概念。</p>
<p>  很难估量这些事件的重要性。在20世纪20年代，两个对数学有着深刻认识的顶级数学家，他们都提出了构成确切证明的数学严谨是概念应该被改变。随后的事态发展同样值得注意。</p>
<p>  1.只有少部分数学家愿意在日常使用中接受这种新的，迫切被采用的标准。很多人承认<strong>外尔</strong>和<strong>布劳威尔</strong>的理论咋看是正确的，但是他们自己却继续违背，用旧的，容易的方式来配合自己的数学工作。也许他们自己也希望有人能够在某个时间找到一个答案去应答这些直觉的批评，从而在事后证明这些理论的正确性。</p>
<p>  2.<strong>希尔伯特</strong>提出了以下巧妙的观点来证明“古典”数学的正当性：即使在直觉系统中也可能给出古典数学如何运作的严谨描述，即人们可以描述古典系统是如何工作的，虽然他们不能证明这种运作。因此，也许可以直观地证明，古典过程永远不会导致矛盾（相互冲突）。很明显这样一个证明是很难，不过有某些迹象表明它们是如何尝试的。一旦该方案有效，它将提供一个古典数学以与其相反的直觉系统为基础的最好的理由！至少，在大多数数学家愿意接受的数学哲学体系中，这种解释是合法的。</p>
<p>  3.在经历了十年的不断的尝试后，<strong>哥德尔</strong>得到了最好的结果。该结果三言两语无法完全准确地表述，而且该说明过于技术性，以至于无法在此表述。然而，它的本质含义是：如果一个数学系统没有导致矛盾，那么这个事实就不能用该系统的程序来证明。（哥德尔不完备定理）哥德尔的证明满足了数学严谨性的最严格标准–直观标准。这个结论对<strong>希尔伯特</strong>的计划影响存在争议（理由之与这篇文章显得太过技术性，我们不在此展开讨论）。我的个人和大多数人认同的观点相同，哥德尔已经证明希尔伯特的计划已经破灭。</p>
<p>  4.古典数学证明的主要希望已经消失（希尔伯特，或者布劳威尔和外尔那种意义上的），虽然人民再也无法确定古典数学的可靠性，但大多数数学家还是决定使用该体系，毕竟，古典数学产出的结果即优雅又有用，且至少建立在一个健全的基础上，就好像电子客观存在那样可靠。因此一个人愿意接受科学，就可以接受经典数学体系。即便直觉体系的一些原始参与者，也转而开始接受这种观点。目前，关于“基础”的争论还没有结束，但是除开少数人，摒弃古典体系变得不太可能。</p>
<p>  我如此详细的讲述了关于这场论战的故事，因为我认为它是不要把数学的严谨性的不可变性看得太过理所当然的最好的警示。这件事发生在我们的有生之年，我知道这段时间中我对于绝对数学真理的认知的改变，让我频繁地丢脸，我也知道他们是怎么样连续地改变了三次。</p>
<p>  我希望以上三个例子充分的说明了我的论文观点的一半，即最卓越数学灵感来自于经验，第二点是很难相信世上存在一个绝对的，不变的数学严谨性概念，且它完全和人类经验没有联系。在这个问题上，我试着抱着及其庸俗的态度。在这方面，无论人们在哲学或认识论上有什么偏好，数学家们的主体的实际经验几乎不支持存在一个先验的数学严谨概念的假设。然而，我的论文还有第二部分，现在我将转到这一部分。</p>
<p>  任何数学家都难以相信数学是一种纯经验主义科学或所有的数学观点源自于经验主义科学。让我们思考一下这句话的第二部分。现代数学的各个重要组成部分其经验性来源往往是不可追溯的。即使可以追溯也要回溯到很久以前，这些观点明显从它斩断经验性源头以来已经经历了完全的蜕变.几何符号是为了国内的数学用途而发明的，不过可能有理由断言它有很强的经验性瓜葛。然而，现代，“抽象”几何越来越多地往弱经验关联方向上发展，拓扑学也与其一样。在所有的这些领域中，数学家对于成功的主观标准和他们努力的价值体现，都是非常独立，优雅且自由（几乎自由）的经验性联系（我在后面会详细的讲）。在集合论中这一点一直很明显。无限集的“幂”和“序”的概念可能是有限集的数值概念的推广，不过在无限集形式中（特别是“幂”）他们几乎和真实世界没有关系。要不是我想避免技术性讨论，我可以用几个集合论的例子来描述这一点，这些例子诸如选择公理问题，无穷幂的可比性，连续性问题，等等。这同样适用于实函数理论和实点集理论。用微分几何和群论分别给出了两个奇怪的例子：它们被认为是抽象的、不实用的学科，而且几乎总是在这种态度中培养出来的.前者下经历了十年，后者经历了一个世纪，它们才在物理学中变得非常有用。并且它们仍然主要以指示性的、抽象的、不实用的态度来进行。</p>
<p>  所有这些条件及其各种组合的例子可以被成倍增加。但是，我更倾向于转到上面提到的第一点：数学是一门经验性科学吗？或者，更清晰的说：数学实际上是以经验科学的方式实践的吗？或者，更宽泛的说：数学家同他们学科的最基本关系是什么？他的成功的标准是什么，可取吗？怎么样的影响和考虑控制并引导着他的工作？</p>
<p>​    让我们来看看，在哪些方面数学家的日常工作方式和自然科学家的方式不同。一方面，在它们之间存在着区别，另一方面，随着数学不断发展，从理论学科向经验学科，再从经验学科向描述性学科的转变，这种区显著增大。因此，让我们把数学和最接近于它的范畴——理论学科，作一下比较。接着我们选出所有理论学科中最接近于数学的那个学科（如果我无法控制数学家的狂妄，而且说道：因为它是所有学科中最理论科学中发达的，请你不要对于批评的太过严厉）。这个学科就是理论物理学，数学和理论物理实际上有很多共同点。正如我前面指出的，欧几里德几何系统是经典力学公理化表述的原型，类似还支配着唯象热力学以及麦克斯韦电动力学系统的某些阶段以及狭义相对论。而且，理论物理学的作派是不解释现象，只做分类和关联，这种作派已经被当今大多数物理学家接受。这就意味着这种理论的成功标准仅仅是：能不能用一种简洁优美的分类关联方案，在使方案看起来不复杂混淆的情况下，覆盖大多数现象，无论在方案被演进时是否覆盖了没有被考虑或甚至不知道的现象（后两种说法当然表现了一种理论的统一性和预测力）。如前所述，现在，这种标准，明显在很大程度上具有美学性质。正因为如此，它非常接近于数学的成功标准，正如你所看到的，这些标准几乎完全是符合美学的。因此，我们现在把数学与最接近它的经验科学——理论物理学，进行比较，正如我希望我所展示的那样，它与数学有许多共同之处。然而，实际方法程序（modus procedendi）上的差异依然巨大且根本。理论物理学的目标主要是由“外部”给出，在大多数情况服从实验物理学的需要。它们几乎总是源于解决困难的需要。预先和统一的成就通常在随后出现。我们可以做一个比喻，进步（预测和统一）在工作从诞生，但在此之前必须与一些预先存在的困难作斗争（通常是现有体系中存在的明显矛盾）。有一部分物理学家的工作是寻找预示着“突破”的可能性的障碍。就如我所说，这些障碍通常源自于实验，不过有时候他们是各种被接受的理论主体中一些部分的矛盾。例子有很多。</p>
<p>  <strong>迈克尔逊</strong>的实验引出了狭义相对论，某些电离势和某些光谱结构的困难导致量子力学即使第一种情况的典型；狭义相对论和牛顿引力理论导致广义相对论之间的冲突就是第二种更罕见的情况的典型。至少，理论物理学中的问题都是客观给出；而且，正如我前面所说，指导成功开发的标准，主要是美学，而且该问题的一部分，即我上面提到的开创性的“突破”，是有力的客观事实。因此，理论物理学的学科几乎任何时候都是非常集中的，几乎所有时候，所有理论物理学家的大部分工作都集中在不超过一两个非常高度受限的领域–比如1920年代和1930年代早期的量子理论和1930年代中期以来的原子核的基本粒子和结构。</p>
<p>  对于数学来说，情况完全不同。数学被分为了大量子领域，他们彼此在特性，风格，目标和影响上广泛不同。这显得它和理论物理学极度的集中正好相反。一个好的理论物理学家可能今天仍然掌握这它的学科的一半以上的工作知识。我能不确定任何的现存的数学家都与超过四分之一的学科知识有大量关联。客观的说，一个重要的问题一般会出现在一个数学的子领域已经有了深远的发展且在某个难点上严重停滞之后。不过即便如此，数学家基本上可以自由的选择尝试解决它或者放弃转而去做其他的领域，一个理论物理学上的重要问题一般是一个必须解决的冲突或者矛盾。数学家有着很多领域可以转而从事，而且他在从事的这些领域上享有非常大自由。但是要说决定性的一点：我认为可以确切的说美学是他们选择的标准，同时也是成功的标准。我知道此断言是有争议的，在没有大量具体的技术案例分析的情况下，它不能够被“证明”，或者说真正的详细地去证实。所以我们就此打住吧，不然这会带来不适合于现在这篇文章场合下的高技术性讨论。只要知道美学特征甚至比在我上面提到的理论物理学的例子中更显著就够了。人们希望数学定理或者数学理论不仅可以以一种简单而优雅的方式描述和分类，而且要有很多先验的不同的特例，并且还希望“优雅”能融于它的“建筑”结构组成中。陈述这个问题的时候很容易，最大的难点在于在握住它，在每一次处理它的尝试中，获得一些惊喜的扭转，使得是在这次处理过程或部分处理过程中变得简单。当然，如果结论复杂而冗长，就应该引入一些简单的基本原则，这些原则能阐述那些绕脑的难题，将一些貌似的随意性转变为一些简单的指导动机。在一些潜在经验主义的世俗主题存在的背景之下，这些准则显然是创造性艺术标准。很多时候是一种非常久远的背景，随着美学的野蛮发展产生了大量的错综复杂的类型，这些类型都更贴近于纯粹和简单的艺术风格而不是经验科学氛围。</p>
<p>  你会注意到，我甚至没有提到数学与经验或描述性科学的比较。这里的方法的差异和总体氛围太明显。</p>
<p>  我认为虽然数学科学的谱系冗长而清晰，但数学观点源自于经验主义是比较近似于事实的（这个事实情况太复杂了，以至于只能说是近似于）。不过，一旦这些数学观点被构想出来，该主题就开始经历自己独特的存在方式，这种存在方式更近似与一个完全由美学动机驱动的创造性学科，而不是其他的学科，尤其不可能是经验科学学科。然而，我认为，还有一点需要强调。如果一门数学学科与它的经验性来源相距甚远，更甚如果只是在它的第二，三代间接地受到来自“现实”的思想的启发，那么它就面临巨大的危险。它变得越来越纯粹地美学化，越来越纯粹地艺术化（ I’art pour I’art）。如果该领域被相关主题包围，而这些学科仍然有着更紧密的经验联系，或者这个学科在有着特殊超前的鉴赏力的人的影响之下，这不一定是坏的。不过有一种情况很危险，就是这个学科独立的顺着最小阻力的路线发展，这个远离学科源头的流派，将会分成很多不重要的分支，以至于把这个学科弄成一大堆复杂的杂乱无章的细节。换句话说，在与它的经验性来源有着很大的距离或者在过多“抽象”的综错后，数学学科处于退化的危险之中。一开始这种风格很传统，当他显示出奇怪的迹象时，危险的信号就出现了。很容易给出一些例子，来探索导致风格变得奇怪或者非常奇怪的特定变化，但这又是太过技术了，我们不在这讨论。</p>
<p>  无论如何，一旦发展到这种情况，在我看来，唯一的解决办法是恢复到原点：重新注入或多或少直接的经验思想。我相信，这是一个保护该学科的新颖与活力的必要条件，该方法在未来同样适用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;本文作者是冯诺依曼，英文名为《The Mathematician》，该文章在1947年发表在《Works of the Mind》上，后来也记录在《von Neumann’s Collected Works》中，这篇文章是我听讲座时偶然得知的，于是看了一下后翻译了出来，才疏学浅，只源于爱好，如有不对多多包涵——2017.12.20&lt;/em&gt;  &lt;/p&gt;
&lt;p&gt;本文接&lt;a href=&quot;http://saul.xin/2017/12/13/Von-Neumann-The-Mathematician-part-1/#more&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;上一部分&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="译文" scheme="http://yoursite.com/tags/%E8%AF%91%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>JVM(5):字节码执行引擎</title>
    <link href="http://yoursite.com/2017/12/14/JVM-5-Execution-engine-of-bytecode/"/>
    <id>http://yoursite.com/2017/12/14/JVM-5-Execution-engine-of-bytecode/</id>
    <published>2017-12-14T05:41:54.000Z</published>
    <updated>2017-12-15T16:12:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>  经历过类加载以后，类文件结构就以JVM定义的形式存储在JVM的方法区中。但是程序如何执行的描述存储在我们前面介绍的方法表的Code属性中的字节码指令，字节码执行引擎，即是执行那些直接码指令，以至于让程序“跑”起来。字节码执行引擎相当于JVM的“处理器”。</p>
<p>  实际上JVM规范只定义了字节码执行引擎的概念模型，具体的实现可能是解释执行也可能是编译执行，或者混合起来。但是从外面看，所有的字节码执行引擎输入都是字节码文件，处理后输出的都是执行结果。</p>
<h2 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><p>  JVM的直接码指令是基于栈操作的，我们也知道在JVM的内存结构里，线程私有的3种内存，即虚拟机栈，本地方法栈，和程序计数器。Hotspot中没有本地方法栈和虚拟机栈的区别，在JVM里，这两种栈中的元素都被称之为<strong>栈帧</strong>。栈帧是VM进行方法调用和方法执行的数据结构，它存储了方法的<strong>局部变量表，操作数栈，动态链接和方法返回地址和一些附加信息</strong>。</p>
<a id="more"></a>
<p>  我们之前介绍过方法表的Code属性，你知道它是干嘛的，现在我要说的是，栈帧就是来源于Code属性，我们在这里再看一遍Code属性的具体结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">Code_attribute &#123;</div><div class="line">    u2 attribute_name_index;//固定指向值为Code的一个CONSTANT_Utf8_info</div><div class="line">    u4 attribute_length;</div><div class="line">    /*info部分*/</div><div class="line">    u2 max_stack;//操作数栈的最大深度</div><div class="line">    u2 max_locals;//局部变量表的存储空间，单位Slot(4个字节)</div><div class="line">    /*代码部分*/</div><div class="line">    u4 code_length;</div><div class="line">    u1 code[code_length];</div><div class="line">    /*显示异常处理表部分*/</div><div class="line">    u2 exception_table_length;</div><div class="line">    exception_info exception_table[exception_table_length];</div><div class="line">    /*属性表部分*/</div><div class="line">    u2 attributes_count;</div><div class="line">    attribute_info attributes[attributes_count];</div><div class="line">&#125;</div><div class="line"></div><div class="line">exception_info&#123;</div><div class="line">	u2 start_pc;</div><div class="line">	u2 end_pc;</div><div class="line">	u2 handler_pc;</div><div class="line">	u2 catch_type;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  仔细一看你可以发现Code属性中，把属于它的操作数栈的一些信息都给定死了，实际上却是如此，这些已经定下来的信息会映射到该方法在VM栈中对应的栈帧中。一个栈帧要分配多少内存，仅取决虚拟机的实现，因为运行期的变量所需的具体内存啥的，Code属性已经给你确定好了。</p>
<p>  你已经知道VM栈是一种<strong>线程私有</strong>的内存结构，每个线程一个，而当前线程执行的方法是由它的VM栈的栈顶元素决定的，栈顶元素又称为<strong>当前方法</strong>。执行引擎运行的所有字节码指令都是针对该线程的VM栈栈顶元素进行操作，准确来说是根据那个栈帧的<strong>局部变量表，操作数栈，动态链接和方法返回地址和一些附加信息</strong>进行操作。所以我们迫切需要知道五种数据结构是什么，介绍完之后我们才能来解释一个方法的调用过程。</p>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>  局部变量表和操作数栈其实我们在介绍Code的属性表里的StackMapTable属性时有过一些接触。另外Code属性中的max_locals字段限制的就是局部变量表的最大容量。</p>
<p>  局部变量表的最小容量单位也是Slot，我们在前面的文章中介绍过它，一个Slot一般是32位（这与虚拟机，操作系统有关）,既然是最小单位，那么像boolean，short这种定义上是低于32位的类型，其实在局部变量表中也是按一个Slot来分配的，64位的数据则以连续的两个Slot来表示。</p>
<p>  在介绍<strong>类加载</strong>的时候我们提到了<strong>准备阶段</strong>，这个阶段即是按类型对类变量赋默认值，相信如果你看了我的前一篇文章，应该还记得这一点，准备阶段的存在可以让类变量在没有赋值的情况下有一个默认值，但是方法中的局部变量可没有准备阶段这种东西。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">		<span class="keyword">int</span> m;</div><div class="line">		System.out.println(m);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>  现在我们知道在哪里存储我们的局部变量了，如果你写过一个逆波兰式的计算程序，那你肯定会接触到基于栈的一个计算方式，或许你当时并没有想太多，但是现在我可以告诉你<strong>操作数栈</strong>这个东西就和你当时做的那个小程序里的栈意义上是一样的，只不过我们我们的运算符已经是jvm直接码指令罢了，”基于栈的执行引擎”的名字由来就是操作数栈。</p>
<p>  操作数栈的单位容量也是32位的，如果一个数据类型是64位的那么就栈两个单位容量，这个我在介绍StackMapTable属性时也提到过，操作数栈的最大深度由Code属性中的max_stacks数据项给定。</p>
<p>  在周志明的书中提到过一个<strong>VM栈帧（是虚拟机栈，不是操作数栈，注意）共享的概念</strong>，就是在概念上完全独立的两个方法的VM栈帧，实际实现时，可能会出现前面一个栈帧的局部变量表与后面一个栈帧的操作数栈共用一部分内存区域的情况，这种情况发生在方法调用变量的传递时。</p>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>  栈帧中存在一个指向运行池常量池的该栈帧所属方法的引用 ，这个引用的目的是为了支持<strong>动态链接</strong>。这个我们在类加载的解析阶段提到过，类的解析过程中并非所有的对类文件常量池的符号引用都转化为了直接引用，还有一部分是在运 行时转化，即<strong>动态链接</strong>。</p>
<h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>  在方法中调用另一个方法，被调用的方法无论是异常退出还是正常的完成都会涉及到一个返回之后，调用者方法从哪里继续的问题，如果是异常退出，则VM可以通过异常处理表来确定执行下一条指令的位置，如果是正常退出则就需要<strong>方法返回地址</strong>这个东西了，它主要是保存了调用时的线程的PC计数器的值。</p>
<p>  方法退出时当前帧出栈，然后恢复上层方法的局部变量表和操作数栈，有返回值的话还要把这个返回值压入操作数栈（如果是前面提到的<strong>VM栈帧共享</strong>，也可能不是这样做），然后要把PC计数器按照方法返回地址调整。</p>
<h3 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h3><p>  当然以上是JVM规范中强制要求的几个数据结构，有可能JVM自己需要添加一些信息，用于调试之类的操作，这类信息通通成为附加信息。</p>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>  <strong>方法调用阶段的唯一目的是确定被调用方法的版本。</strong></p>
<p>  在讨论<strong>类文件结构</strong>的时候你就已经知道，在Class文件中方法是以符号引用方式存在的，在类加载的解析过程中，一部分符号引用转化为了直接引用，但是还有一部分动态链接的方法只有等到运行时才能确定直接引用。为了在这些情况都能使得方法成功正确的调用，就有了这个<strong>方法调用</strong>阶段。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>  在类加载的解析阶段，能确定下来“编译期可知，运行期不可变”这个要求的方法，主要包括<strong>静态方法</strong>和<strong>私有方法</strong>两大类。聪明的人稍微想一下就知道了，静态方法是不可以重写的，而私有方法只能在内部访问，所以这两种方法根本不需要考虑会有什么动态变化之类的事情发生，对这两种方法的“版本”只有一种可能，在类编译期就可以确定，在解析阶段直接由符号引用变成直接引用。解析是一个静态过程。</p>
<h3 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h3><p>  首先我要说解析和分派并不是互斥的两个过程，然后我们讨论分派过程，<strong>这个过程涉及到重载和重写在jvm中的实现，总的来说这个过程就是在进一步确定具体要调用那个方法</strong>，我们首先来看看jvm中的方法调用指令。</p>
<p>  虚拟机调用方法的字节码有5条：</p>
<ol>
<li>invokestatic：调用静态方法</li>
<li>invokespecial:调用实例构造器&lt;init&gt;,私有和父类方法。</li>
<li>invokevirtual：调用<strong>虚方法</strong></li>
<li>invokeinterface：调用接口方法，运行期确定一个接口的实现对象</li>
<li><p>invokedynamic：在运行期对调用点限定符动态解析，然后执行该方法，该指令的<strong>分派逻辑</strong>由用户设定的引导方法决定。</p>
<p>上面提到了两个说法：分派逻辑和虚方法，我们先来解释一下虚方法。</p>
<p>invokestatic和invokespecial这两个指令调用的方法，都是在类解析阶段就可以确定其版本。除了上面说明的方法以外，final修饰的方法也是可以唯一确定的，稍微思考一下就知道。这些方法都称之为<strong>非虚方法</strong>，进行指令调用时你不需要考虑多态选择，一个方法不是<strong>非虚的</strong>就是<strong>虚方法</strong>。</p>
</li>
</ol>
<p>分派，分派可以是<strong>静态的也可以是动态的</strong>。</p>
<h4 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h4><p>静态分派是指依赖<strong>静态类型</strong> 来定位目标方法的分派动作。</p>
<p>静态类型的概念我们可以用一句代码来解释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Car car=<span class="keyword">new</span> Benz();</div></pre></td></tr></table></figure>
<p>上面的这句代码中Car就是静态类型，也称之为<strong>外观类型</strong>，外观类型这个词语可能更能让你有一个理解。而Benz则是<strong>实际类型</strong>。</p>
<p>那么什么是依赖静态类型来定位目标方法呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blue</span> </span>&#123;</div><div class="line">		  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startUp</span><span class="params">(Car car)</span></span>&#123;</div><div class="line">		    System.out.println(<span class="string">"You startup a car"</span>);</div><div class="line">		  &#125;</div><div class="line"></div><div class="line">		  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startUp</span><span class="params">(Benz benz)</span></span>&#123;</div><div class="line">		    System.out.println(<span class="string">"You startup a benz"</span>);</div><div class="line">		  &#125;</div><div class="line">		  </div><div class="line">		  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">		      Car benz=<span class="keyword">new</span> Benz();</div><div class="line">		      startUp(benz);</div><div class="line">		  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Benz</span> <span class="keyword">extends</span> <span class="title">Car</span></span>&#123;&#125;;</div></pre></td></tr></table></figure>
<p>对于上面的代码我们输出了”You startup a car”，即它是按照静态类型Car来确定该调用哪个方法的，所以这就是<strong>静态分派</strong>。</p>
<p>静态类型是编译器可知的，在编译期间编译器就会根据静态类型来决定使用哪个重载版本，如果你学过C++的话，那么那本基础书上应该非常明白的翻来覆去的讲过“运行期多态”和“编译期多态”。</p>
<p>  实际上不同的jvm上语言对静态分派的态度也不同，有时候，特别是用了…符号的变长参数的时候，有可能会产生多个分派结果都符合要求的情况，javac往往会用自己定义的规则来选择一个分派，然而scalac就直接报错了，会提示一个不允许混淆的错误，实际上javac的做法我个人认为有时会让编程者感到很疑惑。</p>
<h4 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h4><p>  动态分派涉及到重写，这个应该是常见面试题了，我们这里就不列出代码了。</p>
<p>  动态分派根据实际类型来确定方法，现在我要说明的就是具体的执行过程。首先我们先来认识一下jvm中的多态查找，该过程实际上就是invokevirtual指令的执行过程，也是java语言中重写的本质：</p>
<ol>
<li>首先找到操作数栈栈顶元素所指向对象的<strong>实际类型</strong> ：C。</li>
<li>如果在C中找到与常量中的<strong>描述符和简单名称</strong> 都相同的方法，就验证访问权限，如果通过就返回该方法的直接引用，不通过者抛出java.lang.IllegalAccessError异常</li>
<li>否则递归的寻找父类中的对应方法，如果递归到最后的Object还没有找到就抛出java.lang.AbstractMethodError异常。</li>
</ol>
<h4 id="单分派与多分派"><a href="#单分派与多分派" class="headerlink" title="单分派与多分派"></a>单分派与多分派</h4><p>  我们把目标方法的所有者类型，称之为方法的<strong>接收者</strong>。</p>
<p>  接受者和方法的参数统称为方法的宗量。多分派和单分派的区别就在于是不是方法选择是否是根据多个总量而定的，若不是则为单分派。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Benz</span> <span class="keyword">extends</span> <span class="title">Car</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Car car)</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"hello,Benz"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Benz benz)</span> </span>&#123;</div><div class="line">		System.out.println(<span class="string">"hi,benz"</span>);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">		Car car=<span class="keyword">new</span> Benz();</div><div class="line">		car.sayHello(car);</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>  比如对于这样的一段代码，在静态分派时，编译器根据静态类型和方法参数确定了方法为Car.sayHello(Car);。并生成了相应的invokevirtual指令，这里就是属于多分派。</p>
<p>  在程序实际执行过程中，编译器已经决定了方法必须是sayHello(Car),在invokevirtual执行时，jvm只判断方法的实际接收者类型是Benz还是Car，这就是一个典型的单分派过程。</p>
<p>  到java1.8为止，java依然是动态单分派语言。</p>
<h4 id="分派的实现"><a href="#分派的实现" class="headerlink" title="分派的实现"></a>分派的实现</h4><p>  仔细考虑一下就能想到，用一个遍历元数据的方法去实现对方法版本的查找肯定不是一个商业虚拟机的实现方式。为了使性能更加优越，虚拟机常用手段是以建立虚方法表的方式来加快搜索。虚方法表一般是存储在方法区中，每个表对应一个类，里面存储了各个方法的实际入口地址，如果一个子类没有重写父类的方法，那么它的虚方法表中的地址就是父类方法表中的那个对应方法的地址，且在父子类虚方法表中相同签名的方法有同样的索引号。（回忆一下的话，class文件中是不会包含未重写的父类方法的，虚方法表和class文件的存储method_info的数据区不同）</p>
<p>  虚方法表在类加载的准备阶段（类变量默认值赋值完成后）初始化。</p>
<p>  虚方法表只是一种优化方式，商用虚拟机为了保证最高的效率肯定做了其他优化。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  经历过类加载以后，类文件结构就以JVM定义的形式存储在JVM的方法区中。但是程序如何执行的描述存储在我们前面介绍的方法表的Code属性中的字节码指令，字节码执行引擎，即是执行那些直接码指令，以至于让程序“跑”起来。字节码执行引擎相当于JVM的“处理器”。&lt;/p&gt;
&lt;p&gt;  实际上JVM规范只定义了字节码执行引擎的概念模型，具体的实现可能是解释执行也可能是编译执行，或者混合起来。但是从外面看，所有的字节码执行引擎输入都是字节码文件，处理后输出的都是执行结果。&lt;/p&gt;
&lt;h2 id=&quot;运行时栈帧结构&quot;&gt;&lt;a href=&quot;#运行时栈帧结构&quot; class=&quot;headerlink&quot; title=&quot;运行时栈帧结构&quot;&gt;&lt;/a&gt;运行时栈帧结构&lt;/h2&gt;&lt;p&gt;  JVM的直接码指令是基于栈操作的，我们也知道在JVM的内存结构里，线程私有的3种内存，即虚拟机栈，本地方法栈，和程序计数器。Hotspot中没有本地方法栈和虚拟机栈的区别，在JVM里，这两种栈中的元素都被称之为&lt;strong&gt;栈帧&lt;/strong&gt;。栈帧是VM进行方法调用和方法执行的数据结构，它存储了方法的&lt;strong&gt;局部变量表，操作数栈，动态链接和方法返回地址和一些附加信息&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>冯诺依曼：《数学家》（上）</title>
    <link href="http://yoursite.com/2017/12/13/Von-Neumann-The-Mathematician-part-1/"/>
    <id>http://yoursite.com/2017/12/13/Von-Neumann-The-Mathematician-part-1/</id>
    <published>2017-12-13T10:56:43.000Z</published>
    <updated>2017-12-13T15:11:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><em>本文作者是冯诺依曼，英文名为《The Mathematician》，该文章在1947年发表在《Works of the Mind》上，后来也记录在《von Neumann’s Collected Works》中，这篇文章是我听讲座时偶然得知的，于是看了一下后翻译了出来，才疏学浅，只源于爱好，如有不对多多包涵——2017.12.13</em>  </p>
<a id="more"></a>
<p>  对于脑力工作的本质的论述在任何领域都是一项艰巨的任务，即使是在数学这样一个接近于人类智慧共同努力的中心地带的领域一样如此。无论如何，对于知识成果的本质的论述都是困难的，远远难于对特定领域的知识的运用。比如理解飞机的结构，以及它的升力和推力理论，比纯粹地去驾驶和乘坐，即便是比之控制航向，前者都要难的多。庆幸的是，一个人在通过直觉和经验深刻理解一个流程之前，就应当能够在没有事先很熟悉运转和使用的情况下，获得对这个流程的理解。</p>
<p>  因此，除了本身设定就是简单或者日常的领域，对所有知识成果的论述都是困难的，在数学中，如果讨论停留在非数学层次上，这种限制就变得非常严重,然后讨论将必然表现出一些非常坏的特征；指出这是永远不能正确证明，然后某种完全肤浅的讨论变得不可避免。</p>
<p>  我很清楚在我将要说的这些话中存在的缺陷，所以我提前道歉。此外，我要表达的观点可能并不是很多其他数学家完全同意的，你会得到一个人不太系统化的印象和解释，而我只能给你一点帮助，来裁决他们到底有多中肯。</p>
<p>  尽管存在一些障碍，然而，我必须承认尝试向你解释数学研究的本质是一件有趣而又富有挑战性的任务。我只希望这件事情上我不会太失败。</p>
<p>  在我看来，数学最本质的特点是，它与自然科学有着非常特殊的关系，更普遍地说，应该是任何阐释实践高于纯粹描述的科学。</p>
<p>  很多人，包括数学家，会同意数学不是一门以观察或实验为依据的科学（经验科学），至少在实践上，它的决定性层面和很多经验科学不同。当然，它的发展和很多自然科学有着紧密联系。它的一个主要分支——几何学，实际上是起源于自然科学，或者说经验科学。现代数学中一些最精妙的灵感（我相信是最精妙的）源于自然科学。数学中的一些方法遍及和支配着自然科学的“理论性”分支。在现代经验科学中，这些方法已成为越来越重要的成功标准，无论它们变得接近数学方法还是近似数学的物理方法。 事实上，在整个自然科学中，一连串连续不断的学科交叉现象已经变得越来越明显，所有这些学科交叉现象都与数学沾点边，且几乎与科学进步的理念一致。生物学日益弥漫着化学和物理，化学串着实验和理论物理，物理学中又串着非常数学形式化的理论物理学。 </p>
<p>  数学本质上有一种非常特别的两面性，一个人必须认识到这种两面性，然后接受它，并将它融入到他对这个问题的思考中去。数学本身就是两面的，我不相信能够在不牺牲本质的情况下做出简化的，统一的观点。</p>
<p>  因此，我将不会呈现给你一个统一的版本。我将尽可能地用多种现象去描述数学。</p>
<p>  不可否认的是，数学（我们能想到的纯粹数学中）中的一些最优秀的灵感源于自然科学。我们将提到两个最重要的事实。</p>
<p>  第一个例子，显然应该是几何。几何是古代数学的重要部分。它的几个分支，至今仍是现代数学的几个主要分支之一。毫无疑问，它起源于古代，是经验性的，今天的它开始成为一门学科，就像理论物理学那样。除开所有其他的证据，单单是“几何”这个名字也指明的这一点。欧几里得的公设法（postulational treatment）是远离经验主义的一大步。但捍卫这一立场并不简单，这是具备决定性的，也是最后一步，这伴随着与经验主义完全分离。欧几里得的公理化在少数地方不符合现代公理的严谨性要求，但是在该方面显得不那么重要。更关键的是：其他的无疑是经验性的学科，如力学和热力学，通常表现为或多或少的公设，在一些作者的表现方法很难与欧几里得的那种过程区分开来。我们这个时代的理论物理学的经典——牛顿定理，在它的文学形式和一些最关键部分的核心上，很像欧几里得的手法。当然，在所有这些例子中，在所呈现的假设的背后，都能通过物理洞察力来证实假设，通过实验验证来证明定理，在几何学获得至今数千年的稳定性和现代的理论物理学体系明显缺失的那种权威性之前，有人可能会认为类似欧几里得这种说法是可以接受的，尤其那种古代的观点。</p>
<p>  进一步来说，从欧几里得时代开始几何学的去经验主义逐步发展，但它没有变得更加完备，直到现代依然如此。关于非欧几里得几何学的讨论正好说明了这一点，它也说明了数学思想的矛盾性。讨论早已集中在一个高度抽象层面上，它处理的是一个纯粹的逻辑问题，即欧几里得的“第五公设”能不能由其他公设的引出。形式冲突被<strong>克莱因</strong>的纯数学范例所终结，这个范例展示了欧几里得平面可以利用重新定义的某些基本概念在非欧几里得理论中构建出来。然而经验主义阴霾从始至终都存在。在所有的欧几里得公设中，第五个受到了质疑的原因很明显只能来自于整个无限平面概念的这种非经验主义特点。最伟大数学家<strong>高斯</strong>的脑海里肯定存在着这个至少有重要意义的观点，尽管所有决定性的数学逻辑分析表明欧几里得几何学可能必须是经验主义的。在<strong>波尔约，罗巴切夫斯基，黎曼，克莱因</strong>取得更多的抽象结论之后，今天我们考虑原争论的结论，经验主义，更确切的说是物理学，依然有着最终的话语权。广义相对论的提出，迫使我们在新的设定下重新审视我们的几何学观点，它也带来了纯粹数学重点的全新的分配。最后我们来做一个完全的对比，最后这次发展发生在同一代人中，这一代人目睹了在现代公理逻辑数学家手中，欧几里得公理化方法的完全去经验化和去抽象化。，这两种矛盾的态度在一个数学家的脑中很好的相容了；可以看出，希尔伯特在公理化和广义相对论中都做出了巨大的共享。</p>
<p>  第二例子是微积分，可以说所有的解析，都是由它产生。微积分是现代数学的第一个成就，它的重要性大到难以估计，我认为它比任何其他东西都更明确的定义现代数学的开端，它的逻辑推导铸就了数学分析系统，现仍然是精确思想中最伟大的技术进步。</p>
<p>  微积分的显然起源于经验主义，开普勒首次正式尝试就是定义被称为“dolichometry”的方法，即对带有曲面的物体进行体积测量的方法。这是几何，但不是欧几里得几何，在那个时代，它是非公理化的经验主义几何。关于这点，开普勒非常清楚。牛顿和莱布尼茨的主要成果和发现，都明确的源自于物理。牛顿发明了“流数法”微积分，本质上是为了力学目的。实际上对于微积分和力学，这两个学科或多或少的一起发展，微积分的第一个公式在数学上是不严谨的。在牛顿之后的150年里这样一个不严谨的半物理公式是唯一的可选项。与这个不严谨，数学发展也不充分的时代背景相反，在这期间，解析学发生了很多重大的突破。这个时代的一些主要的数学思想肯定是不严谨的，比如<strong>欧拉</strong>；当然另外一些人，总体上是严谨的，比如<strong>高斯</strong>或者<strong>雅可比</strong>。虽然没有数学家会忽略那个时代（那个时代的数学获得了空前的发展），但是这一发展过程既混乱又模糊，它与经验主义的关系显然不是根据我们当前(或欧几里得的)抽象和严谨的思想而定的。甚至是在<strong>柯西</strong>重新从根本上确立统治地位之后，一个非常特殊的从新回归半物理方法的倒退却随着黎曼而生，黎曼的学术个性本身就是数学双重本质的一个最具说明性的例子，正如<strong>黎曼和魏尔斯特拉斯</strong>的论战，我们就此打住吧，如果我再深入研究下去的话就是技术细节了。从魏尔斯特拉斯开始，分析看起来变得完全抽象，严谨且不再经验性。即便不是绝对正确。关于数理和逻辑“基础”的论战，发生在过去的两代人里，消除了很多关于真相的错误观念。</p>
<p>  这给我带来了第三个例子，这个例子和判断有关，它所涉及的是数学与哲学或者认知论的关系，而非数学与自然科学的关系。这个例子以一种非常新颖的方式说明了“完全”的数学严谨性的绝对观念并非是不可变的。严谨这一概念的多变性表明除了数学抽象以外的一些东西必定参与到了数学的构成中。在分析关于“基础”的论战中，我无法说服自己接受必须迎合其他因素的经验性质的结论。虽然至少在某些阶段的讨论中，赞成这些解释的理由是非常有力的。但我不认为它是完全让人信服的。然而，有两件事是清楚地。首先，一些非数学的东西，某种程度上与经验性科学或哲学联系在一起，或者两者兼而有之，确实从本质上进入了，他们的非经验特征能够维持下去，取决于一个人是否认为哲学（或者认识论）可以独立的存在（这种假设是必要的，但是不够充分）。第二，一些例子强力支持着数学的经验性起源，比如我们上面提到的两种例子（集合和微积分），这与“基础”论战的最佳解释是什么无关。</p>
<p>  在分析数学严谨性概念的易变性时，我想强调上文所提到的“基础”论战，然而，我会先简要地细想一下这个问题的次要方面，这个方面加强了我的论点，但是我认为它的次要的，因为比之“基础”论战的分析，它可能不那么确切。我指的是数学“风格”的变化。众所周知，数学证明的写作风格已经经历了相当大的波动。这里讨论波动而不是某种趋势是因为在某些方面上十八、十九世纪的某些作者和现在之间的风格差异比现在和欧几里得时代更大。但是，在其他方面却具有非常显著的稳定性。在存在差异的领域中，主要差异是存在于表现上，这些差异可以再不引入任何新思想的情况下消除。然而，在很多情况下这些差异大到让人怀疑在不需要考虑他们是否真的对数学的严谨性有同样的想法，仅仅通过不同的风格，品味和教育水平，就可以把不同方式展现它们的作者给区分开来。结果，在极端情况下（例如，在上面提到的，18世纪晚期的分析工作），差异无法避免，即便可以补救，也要在全新而重要的理论的帮助下才行得通，而这些理论的发展需要数百年。一些在那种于今天而言是不严谨的方式（当时有一些同僚批评）下工作的数学家已经很清楚的意识到他们自身的工作方式缺乏严谨性。更客观的说，他们自身渴望数学处理方法应该和我们今天的观点一样，而不是只拘于他们手头上做的那种。不过那个时代的一些大师，比如欧拉，显得对于那种方法十分信任且对他们自己的标准很满意。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;本文作者是冯诺依曼，英文名为《The Mathematician》，该文章在1947年发表在《Works of the Mind》上，后来也记录在《von Neumann’s Collected Works》中，这篇文章是我听讲座时偶然得知的，于是看了一下后翻译了出来，才疏学浅，只源于爱好，如有不对多多包涵——2017.12.13&lt;/em&gt;  &lt;/p&gt;
    
    </summary>
    
    
      <category term="译文" scheme="http://yoursite.com/tags/%E8%AF%91%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>ES6(2):Destructuring assignment</title>
    <link href="http://yoursite.com/2017/12/08/ES6-2-Destructuring-assignment/"/>
    <id>http://yoursite.com/2017/12/08/ES6-2-Destructuring-assignment/</id>
    <published>2017-12-08T15:57:12.000Z</published>
    <updated>2017-12-09T07:13:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>  本世纪以来的很多新语言都提供了各种赋值或者模式匹配判断的语法糖，es6也提供了对解构赋值的一系列支持使得我们可以在很多情况下节省很多行代码。但是对一个复杂模式的解构赋值很可能让维护代码的人员感到很疑惑，所以这里记录的解构赋值没有那么多奇技淫巧。</p>
<a id="more"></a>
<h2 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h2><p>我们在es6中，可以向scala中操作元组和集合那样，用模式匹配的方式来对数组进行解构赋值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> [a, [b, c], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</div><div class="line">    alert(c);<span class="comment">//输出3</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> [a, b] = [, <span class="number">2</span>];</div><div class="line">    alert(a);<span class="comment">//a没有匹配项，解构不成功，输出undefined</span></div><div class="line">    alert(b);<span class="comment">//输出2</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> [a, b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">    alert(b);<span class="comment">//输出2</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">    <span class="comment">// 我们可以用...来表示一个多值匹配</span></div><div class="line">    <span class="keyword">let</span> [a, [...b], c] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>];</div><div class="line">    alert(b);<span class="comment">//输出2,3,4</span></div><div class="line">    alert(c);<span class="comment">//输出5</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line">    alert(b);<span class="comment">//输出2,3,4</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="提供默认值的解构"><a href="#提供默认值的解构" class="headerlink" title="提供默认值的解构"></a>提供默认值的解构</h3><p>我们可以为解构需要的变量赋默认值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> [a, b = <span class="number">4</span>] = [<span class="number">1</span>];</div><div class="line">    alert(b);<span class="comment">//输出4</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> [a, b = <span class="number">4</span>] = [<span class="number">1</span>, <span class="literal">undefined</span>];<span class="comment">//不严格等于undefined，所以赋默认值</span></div><div class="line">    <span class="keyword">let</span> [c,d=<span class="number">4</span>]=[<span class="number">1</span>,<span class="literal">null</span>];</div><div class="line">    alert(b);<span class="comment">//输出4</span></div><div class="line">    alert(d);<span class="comment">//输出null</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> [a, b = a] = [<span class="number">1</span>];<span class="comment">//你甚至可以这样</span></div><div class="line">    alert(b);<span class="comment">//输出1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="惰性求值"><a href="#惰性求值" class="headerlink" title="惰性求值"></a>惰性求值</h3><p>es6中也有惰性求值这种东西的存在，比如如果结构中默认值是一个表达式那么，默认值其实是惰性求值的，即如果结构成功这个表达式根本不执行<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">lazy</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        alert(<span class="string">"execute lazy"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="string">"abc"</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> [m = lazy(), k] = [<span class="number">1</span>, <span class="number">2</span>];<span class="comment">//不出现弹窗</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="数组结构与可遍历性"><a href="#数组结构与可遍历性" class="headerlink" title="数组结构与可遍历性"></a>数组结构与可遍历性</h3><p>数组解构赋值的进行实际上是利用了右边集合的可遍历性，如果右边的集合不具有可遍历性则直接报错<br>相反的，如果右边的集合是一个可遍历的结构，当然就是可以解构的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> [k] = <span class="literal">NaN</span>;<span class="comment">//Uncaught TypeError: NaN is not iterable</span></div><div class="line">    <span class="comment">// let [k]=1;</span></div><div class="line">    <span class="comment">// let [k]=&#123;&#125;;</span></div><div class="line">    <span class="comment">// let [k]=null;</span></div><div class="line">    <span class="comment">// let [k]=false;</span></div><div class="line">    <span class="comment">// let [k]=undefined;</span></div><div class="line">  <span class="comment">//全部报类似错误</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><p>对象也可以使用解构方式来赋值，不过对象不再要求右边的值是一个可遍历的解构了<br>这种方式类似于scala中的函数传参<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> &#123;tom, jack&#125; = &#123;<span class="attr">jack</span>: <span class="string">"jack"</span>, <span class="attr">tom</span>: <span class="string">"tom"</span>&#125;;</div><div class="line">    <span class="comment">//相当于 let &#123;tom:tom, jack:jack&#125; = &#123;jack: "jack", tom: "tom"&#125;;</span></div><div class="line">    alert(tom);<span class="comment">//输出tom</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="对象结构中的默认值使用"><a href="#对象结构中的默认值使用" class="headerlink" title="对象结构中的默认值使用"></a>对象结构中的默认值使用</h3><p>当然我们可以赋默认值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> &#123;tom=<span class="string">"TOM"</span>,mary, jack&#125; = &#123;<span class="attr">jack</span>: <span class="string">"jack"</span>&#125;;</div><div class="line">    alert(tom);</div><div class="line">    alert(mary);<span class="comment">//输出undefined</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这种语法糖更是提供了我们对对象属性的赋值，和将对象属性直接转化为变量<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">   <span class="keyword">let</span> man=&#123;<span class="attr">clz</span>:<span class="string">"Man"</span>,<span class="attr">old</span>:<span class="number">18</span>&#125;;</div><div class="line">   <span class="keyword">let</span> &#123;<span class="attr">clz</span>:clz,<span class="attr">old</span>:od&#125;=man;<span class="comment">//以属性名:变量名的方式来确定赋值</span></div><div class="line">    alert(clz);</div><div class="line">    alert(od);</div><div class="line"></div><div class="line">   <span class="keyword">let</span> woman=&#123;<span class="attr">clz</span>:<span class="string">"woman"</span>,<span class="attr">old</span>:od&#125;;<span class="comment">//变量作为实际值</span></div><div class="line">   alert(woman.old);<span class="comment">//输出18</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="嵌套匹配结构"><a href="#嵌套匹配结构" class="headerlink" title="嵌套匹配结构"></a>嵌套匹配结构</h3><p>嵌套的匹配<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> course=&#123;</div><div class="line">        <span class="attr">name</span>:<span class="string">"Operation System"</span>,</div><div class="line">        <span class="attr">detail</span>:&#123;</div><div class="line">            <span class="attr">score</span>:<span class="number">3.5</span>,</div><div class="line">            <span class="attr">teacher</span>:[<span class="string">"Mark Watson"</span>,<span class="string">"John Joy"</span>]</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    <span class="keyword">let</span> &#123;name,<span class="attr">detail</span>:&#123;score,<span class="attr">teacher</span>:[t1,t2]&#125;&#125;=course;</div><div class="line">    <span class="comment">//如果你想获取整个detail的值，可以这样let &#123;name,detail,detail:&#123;score,teacher:[t1,t2]&#125;&#125;=course;</span></div><div class="line">    alert(name);</div><div class="line">    alert(score);</div><div class="line">    alert(t2);<span class="comment">//正确输出了John joy，可见新的语法糖给我们带来的便利是很明显的，虽然很少会用到</span></div><div class="line">&#125;</div><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> k=[];</div><div class="line">    (&#123;<span class="attr">z</span>:k[<span class="number">1</span>],<span class="attr">m</span>:k[<span class="number">0</span>]&#125;=&#123;<span class="attr">m</span>:<span class="number">2</span>,<span class="attr">z</span>:<span class="number">1</span>&#125;);<span class="comment">//加小括号的理由是&#123;开头会被解释器认为是一个代码块的开始</span></div><div class="line">    alert(k[<span class="number">0</span>]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="提取函数和转化字符串"><a href="#提取函数和转化字符串" class="headerlink" title="提取函数和转化字符串"></a>提取函数和转化字符串</h3><p>我们可以这样讲对象中的函数提取出来<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> &#123;sin,cos,log,tan&#125;=<span class="built_in">Math</span>;</div><div class="line">    alert(tan);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于字符串，我们可以将它解构为一个个字符<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">   <span class="keyword">let</span> [a,b,c]=<span class="string">"abc"</span>;</div><div class="line">   alert(a+<span class="string">"~"</span>+b+<span class="string">"~"</span>+c);<span class="comment">//输出a~b~c</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="函数解构"><a href="#函数解构" class="headerlink" title="函数解构"></a>函数解构</h2><p>对函数的数组参数进行解构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    function hello([x,y]) &#123;</div><div class="line">        alert(x+&quot; &quot;+y);</div><div class="line">    &#125;</div><div class="line">    let v=[&quot;hello&quot;,&quot;world&quot;];</div><div class="line">    hello(v);//输出hello world</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>提供默认值和默认参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    function halo(&#123;x=&quot;halo&quot;,y=&quot;world&quot;&#125;=&#123;&#125;) &#123;</div><div class="line">        alert(x+&quot; &quot;+y);</div><div class="line">    &#125;</div><div class="line">    halo(&#123;x:&quot;hello&quot;&#125;);</div><div class="line">    halo(&#123;y:&quot;Jack&quot;&#125;);</div><div class="line">    function hi(&#123;x,y&#125;=&#123;x:&quot;hi&quot;,y:&quot;world&quot;&#125;) &#123;</div><div class="line">        alert(x+&quot; &quot;+y);</div><div class="line">    &#125;</div><div class="line">    hi(&#123;x:&quot;hello&quot;&#125;);//提供了参数&#123;x:&quot;hello&quot;&#125;，不使用默认参数，输出hello undefined</div><div class="line">    hi();//使用默认参数，输出hello world</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="解构的应用"><a href="#解构的应用" class="headerlink" title="解构的应用"></a>解构的应用</h2><p>用于交换<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="keyword">let</span> [x,y]=[<span class="number">1</span>,<span class="number">2</span>];</div><div class="line">    [x,y]=[y,x];</div><div class="line">    alert(y);<span class="comment">//输出1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>用于解构函数的返回值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnArray</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">returnObj</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> &#123;<span class="attr">x</span>:<span class="string">"hey"</span>,<span class="attr">y</span>:<span class="string">"Daisy"</span>&#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> [a,b,c]=returnArray();</div><div class="line"><span class="keyword">let</span> &#123;<span class="attr">x</span>:m,<span class="attr">y</span>:k&#125;=returnObj();</div><div class="line">alert(k);<span class="comment">//Daisy</span></div><div class="line">alert(b);<span class="comment">//2</span></div></pre></td></tr></table></figure></p>
<p>快速提取json对象中的数据<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> json=&#123;<span class="attr">name</span>:<span class="string">"Jack"</span>,<span class="attr">score</span>:[<span class="number">83</span>,<span class="number">91</span>],<span class="attr">old</span>:<span class="number">15</span>&#125;;</div><div class="line"><span class="keyword">let</span> &#123;<span class="attr">name</span>:x,<span class="attr">score</span>:s,<span class="attr">old</span>:o&#125;=json</div><div class="line">alert(s[<span class="number">1</span>]);<span class="comment">//91</span></div></pre></td></tr></table></figure></p>
<p>提取map中的键值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</div><div class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</div><div class="line">    alert(key + <span class="string">" is "</span> + value);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  本世纪以来的很多新语言都提供了各种赋值或者模式匹配判断的语法糖，es6也提供了对解构赋值的一系列支持使得我们可以在很多情况下节省很多行代码。但是对一个复杂模式的解构赋值很可能让维护代码的人员感到很疑惑，所以这里记录的解构赋值没有那么多奇技淫巧。&lt;/p&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Learning ES6(1):块作用域</title>
    <link href="http://yoursite.com/2017/12/06/Learning-ES6-1-Block-scope/"/>
    <id>http://yoursite.com/2017/12/06/Learning-ES6-1-Block-scope/</id>
    <published>2017-12-06T06:46:19.000Z</published>
    <updated>2017-12-06T08:42:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>  最近主要是在学习3个东西，一个就是单元测试，第二个就是jvm，还有一个就是es6了，目前的话jvm已经学完了，就差把笔记搬运从笔记本上到博客上，单元测试和es6的话都是正在进行，es6的是阮一峰的<a href="https://github.com/ruanyf/es6tutorial" target="_blank" rel="external">ECMAScript 6 入门</a>，大神已经把书开源道github上了，推荐大家去看那本书，博客这里主要用于我个人用于以后回忆某些知识用的。</p>
<p>  至于es6是什么可以自行使用搜索引擎，或看上面那本书的第1章，这里我就不介绍了。</p>
<hr>
<p>  在ES6之前，js中是没有<strong>块级作用域</strong>这个东西的，只有<strong>函数</strong>和<strong>全局</strong>作用域<br>  ES6中的第一个特性，即以let来声明一个变量，这个变量只在当前代码块中有效，比如对于如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">let</span> k = <span class="number">3</span>;<span class="comment">//k作用域只在当前代码块中</span></div><div class="line">    &#125;</div><div class="line">    alert(k); <span class="comment">//报错，外层代码不能去引用内层代码块中的k，如果上面是var则输出3</span></div><div class="line">&#125;();</div><div class="line"></div><div class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> k = <span class="number">3</span>;</div><div class="line">    &#123;</div><div class="line">        alert(k);<span class="comment">//正常输出3</span></div><div class="line">    &#125;</div><div class="line">&#125;();</div><div class="line"></div><div class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> k = <span class="number">4</span>;</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">let</span> k = <span class="number">5</span>;</div><div class="line">        alert(k);<span class="comment">//输出k=5</span></div><div class="line">    &#125;</div><div class="line">    alert(k);<span class="comment">//输出k=4</span></div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="let变量特性"><a href="#let变量特性" class="headerlink" title="let变量特性"></a>let变量特性</h2><h3 id="变量提升和暂时性死区"><a href="#变量提升和暂时性死区" class="headerlink" title="变量提升和暂时性死区"></a>变量提升和暂时性死区</h3><p>  对于var声明的变量会有变量提升问题，即是在作用域开头变量已经存在但是没有赋值，<strong>var定义的变量只能是函数或者全局作用域有效的，没有块这个概念</strong>。比如对于以下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    alert(f);<span class="comment">//输出undefined，var声明的变量标识在函数作用域有效，有变量提升</span></div><div class="line">    <span class="keyword">var</span> f = <span class="number">1</span>;</div><div class="line">&#125;();</div><div class="line"></div><div class="line"><span class="comment">//实际相当于执行代码：</span></div><div class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  	<span class="keyword">var</span> f = <span class="literal">undefined</span>;</div><div class="line">    alert(f);</div><div class="line">    f = <span class="number">1</span>;</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>但是对于let来说，这样声明就报错，<strong>let声明的变量没有变量提升</strong>，作用域是块级。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">//TDZ开始</span></div><div class="line">    alert(k);<span class="comment">//报错:Uncaught ReferenceError: k is not defined</span></div><div class="line">    <span class="keyword">let</span> k = <span class="number">1</span>;<span class="comment">//TDZ结束</span></div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>现在我们来引入一个概念：暂时性死区(temporl dead zone,TDZ),这个概念是对于let和const变量而言的，es6引入它的目的在于，让js程序员养成使用前先定义的好习惯。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">* 在阮一峰的《ECMAScript 6 入门》中提到</div><div class="line">* ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。</div><div class="line">* 凡是在声明之前就使用这些变量（任何操作），就会报错。</div><div class="line">*</div><div class="line">* 在块中，let定义一个变量n之前的区域，都称之为“展暂时性死区”</div></pre></td></tr></table></figure>
<p>总之，暂时性死区的本质就是，<strong>只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</strong></p>
<h3 id="不可重复声明"><a href="#不可重复声明" class="headerlink" title="不可重复声明"></a>不可重复声明</h3><p>在同一个作用域中，var声明的变量可以重复声明，会取后声明的值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//正常运行</span></div><div class="line">    <span class="keyword">var</span> f = <span class="number">1</span>;</div><div class="line">    <span class="keyword">var</span> f = <span class="number">2</span>;</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>而在同一个作用域中，let声明的变量不可以重复声明，会报错</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//报错</span></div><div class="line">    <span class="keyword">let</span> k = <span class="number">4</span>;</div><div class="line">    <span class="keyword">let</span> k = <span class="number">5</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//如果同一个变量已经被var声明，那么如果它再用let声明同样报错</span></div><div class="line">    <span class="comment">//let f=3;</span></div><div class="line">&#125;();</div><div class="line"></div><div class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> f = <span class="number">4</span>;</div><div class="line">    </div><div class="line">    <span class="comment">//如果同一个变量已经被var声明，那么如果它再用let声明同样报错</span></div><div class="line">    <span class="comment">//相反一样</span></div><div class="line">    <span class="keyword">let</span> f=<span class="number">3</span>;<span class="comment">//这一行报错</span></div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<h3 id="用let做for循环参数"><a href="#用let做for循环参数" class="headerlink" title="用let做for循环参数"></a>用let做for循环参数</h3><p>ES5中由于闭包关系，我们不得不用一段不太漂亮的代码来实现for循环中i的不同取值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">!function () &#123;</div><div class="line">    var a = &#123;&#125;;</div><div class="line">    for (let i = 0; i &lt; 10; i++) &#123;</div><div class="line">        a[i] = function (arg) &#123;//闭包函数，以变量arg来保存当前i的值，从而传递给内部的返回函数</div><div class="line">            return function () &#123;</div><div class="line">                alert(arg)</div><div class="line">            &#125;</div><div class="line">        &#125;(i);</div><div class="line">    &#125;</div><div class="line">    a[6]()</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>在ES6中我们可以这样做:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> a = &#123;&#125;;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">        a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            alert(i);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    a[<span class="number">6</span>]()</div><div class="line">&#125;();</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> 这里很多人可能会理解错误，因为for语句和&#123;&#125;代码块其实是两个作用域</div><div class="line"> 而let只能在当前作用域有效，那么&#123;&#125;代码块里的数据是怎么来的呢？</div><div class="line"> 其实这里每次循环都创建了一个新的i，这个新的i的值在旧的i的基础上计算</div><div class="line"> */</div><div class="line"> </div><div class="line"><span class="comment">//类似于执行一个这样的，过程</span></div><div class="line"><span class="keyword">var</span> a = &#123;&#125;;</div><div class="line">&#123; <span class="keyword">let</span> k = <span class="number">0</span>;  </div><div class="line">    <span class="keyword">for</span> (;k &lt; <span class="number">10</span>;) &#123;</div><div class="line">      <span class="keyword">let</span> i = k; </div><div class="line">      a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        alert(i);</div><div class="line">      &#125;;</div><div class="line">      k++;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></div><div class="line"></div><div class="line"><span class="comment">//在babel中转成es代码是这样的：</span></div><div class="line"><span class="keyword">var</span> a = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> _loop = <span class="function"><span class="keyword">function</span> <span class="title">_loop</span>(<span class="params">i</span>) </span>&#123;</div><div class="line">    a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        alert(i);</div><div class="line">    &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    _loop(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="const变量"><a href="#const变量" class="headerlink" title="const变量"></a>const变量</h2><p>  const声明常量，一旦声明就不能被改变，所以const声明时必须立刻赋值<br>如果下代码不赋值就抛出：Uncaught SyntaxError: Missing initializer in const declaration</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> k;</div><div class="line">alert(k);</div></pre></td></tr></table></figure>
<p><strong>const同样只在块作用域内有效，不可重复声明，且存在暂时性死区</strong></p>
<p>  const只能保证它所指向的地址不可变，但是这个地址的数据结构怎么变它管不了，比如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> man=&#123;&#125;;</div><div class="line">man.name=<span class="string">"Tom"</span>;</div><div class="line">man.name=<span class="string">"Jack"</span>;</div><div class="line">alert(man.name);<span class="comment">//输出jack</span></div></pre></td></tr></table></figure>
<p>  如果要保证对象不可变，还是必须用Object.freeze去冻结一个对象，比如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> man=<span class="built_in">Object</span>.freeze(&#123;<span class="attr">name</span>:<span class="string">"Tom"</span>&#125;);</div><div class="line">man.name=<span class="string">"Jack"</span>;<span class="comment">//不报错，但是不起作用，如果是严格模式就报错了</span></div><div class="line">alert(man.name);</div></pre></td></tr></table></figure>
<p>这种冻结方式对对象的对象引用属性没效果，但是你可以以递归去写一个冻结函数。</p>
<h2 id="块级作用域和函数"><a href="#块级作用域和函数" class="headerlink" title="块级作用域和函数"></a>块级作用域和函数</h2><p>在es5浏览器中，下面的代码是可以正常运行的，并输出I am inside，因为function声明会提升到函数作用域顶端</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>); &#125;</div><div class="line">    !<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</div><div class="line">            <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>); &#125;</div><div class="line">        &#125;</div><div class="line">        f();</div><div class="line">    &#125;();</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>  在es5浏览器中，上面的代码是可以正常运行的，并输出I am inside，因为function声明会提升到函数作用域顶端，实际上执行下面这段：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>); &#125;</div><div class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>); &#125;</div><div class="line">        <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</div><div class="line">        &#125;</div><div class="line">        f();</div><div class="line">    &#125;());</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>  在es6浏览器中，在块级作用域中声明函数，类似var声明变量，下面这段代码会抛出错误:Uncaught TypeError: f is not a function<br>实际上es6浏览器执行的代码，是类似于下面这段：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>); &#125;</div><div class="line">    (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> f = <span class="literal">undefined</span>;</div><div class="line">        <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</div><div class="line">            f=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>); &#125;</div><div class="line">        &#125;</div><div class="line">        f();</div><div class="line">    &#125;());</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>  最佳实践是：避免在块级作用域内声明函数，在有必要的情况下，也应该写成函数表达式，而不是函数声明语句。</p>
<h2 id="全局作用域的let和const"><a href="#全局作用域的let和const" class="headerlink" title="全局作用域的let和const"></a>全局作用域的let和const</h2><p>在es5中，我们知道浏览器中的顶层对象指的是window和self对象(Node中是global)</p>
<p>浏览器中对于var和function命令声明的全局变量，其实就是window的属性</p>
<p>es6为了改变这种含糊的表达方式，但是又不得不得向以前的代码妥协，于是它做出了以下区分：<br>首先它对于var和function命令声明的全局变量意义不变<br>对于let,const,class声明的全局变量，不再是顶层对象的属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">abc</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    alert(<span class="string">"abc"</span>);</div><div class="line">&#125;</div><div class="line"><span class="built_in">window</span>.abc();</div><div class="line"></div><div class="line"><span class="keyword">var</span> k=<span class="string">"kkk"</span>;</div><div class="line">alert(<span class="built_in">window</span>.k);</div><div class="line"></div><div class="line"><span class="keyword">let</span> i=<span class="string">"iii"</span>;</div><div class="line">alert(<span class="built_in">window</span>.i);<span class="comment">//undefinded</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  最近主要是在学习3个东西，一个就是单元测试，第二个就是jvm，还有一个就是es6了，目前的话jvm已经学完了，就差把笔记搬运从笔记本上到博客上，单元测试和es6的话都是正在进行，es6的是阮一峰的&lt;a href=&quot;https://github.com/ruanyf/es6tutorial&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;ECMAScript 6 入门&lt;/a&gt;，大神已经把书开源道github上了，推荐大家去看那本书，博客这里主要用于我个人用于以后回忆某些知识用的。&lt;/p&gt;
&lt;p&gt;  至于es6是什么可以自行使用搜索引擎，或看上面那本书的第1章，这里我就不介绍了。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;  在ES6之前，js中是没有&lt;strong&gt;块级作用域&lt;/strong&gt;这个东西的，只有&lt;strong&gt;函数&lt;/strong&gt;和&lt;strong&gt;全局&lt;/strong&gt;作用域&lt;br&gt;  ES6中的第一个特性，即以let来声明一个变量，这个变量只在当前代码块中有效，比如对于如下代码：&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;!&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; k = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;&lt;span class=&quot;comment&quot;&gt;//k作用域只在当前代码块中&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    alert(k); &lt;span class=&quot;comment&quot;&gt;//报错，外层代码不能去引用内层代码块中的k，如果上面是var则输出3&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;!&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; k = &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        alert(k);&lt;span class=&quot;comment&quot;&gt;//正常输出3&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;!&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; k = &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; k = &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        alert(k);&lt;span class=&quot;comment&quot;&gt;//输出k=5&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    alert(k);&lt;span class=&quot;comment&quot;&gt;//输出k=4&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>JVM(4):类加载器机制</title>
    <link href="http://yoursite.com/2017/12/05/JVM-4-Class-Loader/"/>
    <id>http://yoursite.com/2017/12/05/JVM-4-Class-Loader/</id>
    <published>2017-12-05T03:45:40.000Z</published>
    <updated>2017-12-05T10:23:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>  类加载执行的前提是我们能以一个类的全限定名来获取字节流，至于字节流在哪里生成，我们从哪里获取这并不是虚拟机所关心的，作为一个出色的设计团队，Java的设计者最初为了满足Java Applet，设计了大名鼎鼎的类加载器机制，<strong>即让通过全限定名获取字节流的这个动作，放到JVM的外部，用户可以选择自行实现一些特殊的加载方案</strong>，现在你知道的随着flash的流行，Java Applet这种技术已经淘汰了，现在随着html5的新起，flash也基本上接近夕阳了，可见技术的变化是普遍而剧烈的。虽然Applet死了很多年，但是类加载器却被作为一种精髓留在了java体系中，原因是它在OSGi,代码加密，热部署等等应用中有了新生的土壤。</p>
<p>  类加载器还有一个作用就是和类的标识一起来确定这个类的唯一性，若N1是类C的全限定名称标识，而L1是加载类C类加载器，那么如果存在一个类D的全限定名称为N2,而L2是类D的加载器，那么：</p>
<p> 当且仅当，N1=N2且L1=L2时C和D才被认为是同一个类，即C&lt;N1,L1&gt;=D&lt;N2,L2&gt;</p>
<p> 这种相等，关系到类的Class对象的equals方法，isAssignableFrom()方法以及isInstance()方法和instanceof关键字的判断结果。</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException </span>&#123;</div><div class="line">      	<span class="comment">//从写一个自定义类加载器，用于加载同路径下的类，如果一个类名不是同路径下的就用父类加载器加载</span></div><div class="line">		ClassLoader loader=<span class="keyword">new</span> ClassLoader() &#123;</div><div class="line">			<span class="keyword">public</span> java.lang.Class&lt;?&amp;gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</div><div class="line">				<span class="keyword">try</span> &#123;</div><div class="line">					String fn=name.substring(name.lastIndexOf(<span class="string">"."</span>)+<span class="number">1</span>)+<span class="string">".class"</span>;</div><div class="line">					InputStream resourceAsStream = getClass().getResourceAsStream(fn);</div><div class="line">                  	  <span class="comment">//同路径下没有该类，用父类加载器加载</span></div><div class="line">					<span class="keyword">if</span>(resourceAsStream==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</div><div class="line">					<span class="keyword">byte</span>[] bs=<span class="keyword">new</span> <span class="keyword">byte</span>[resourceAsStream.available()];</div><div class="line">					resourceAsStream.read(bs);</div><div class="line">					<span class="keyword">return</span> defineClass(name, bs, <span class="number">0</span>, bs.length);</div><div class="line">				&#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">					e.printStackTrace();</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">			&#125;;</div><div class="line">		&#125;;</div><div class="line">		Object newInstance = loader.loadClass(<span class="string">"test.Hello"</span>).newInstance();</div><div class="line">		Hello hello = <span class="keyword">new</span> Hello();</div><div class="line">		System.out.println(newInstance.getClass().getName());</div><div class="line">		System.out.println(hello.getClass().getName());</div><div class="line">		System.out.println(newInstance.getClass().equals(hello.getClass()));</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//可以看出虽然全限定名相同但是却是不同的类</span></div><div class="line">输出：</div><div class="line">test.Hello</div><div class="line">test.Hello</div><div class="line"><span class="keyword">false</span></div></pre></td></tr></table></figure>
<h2 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h2><p>  在官方文档中，我们中看到了两种类加载器的区分，一种就是<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3.1" target="_blank" rel="external">启动类加载器</a>（Bootstrap Class Loader ）还一种就是<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.3.2" target="_blank" rel="external">用户定义加载器</a>（ User-defined Class Loader ）。</p>
<p>原文：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">There are two kinds of class loaders: the bootstrap class loader supplied by the Java Virtual Machine, and user-defined class loaders. Every user-defined class loader is an instance of a subclass of the abstract class ClassLoader</div></pre></td></tr></table></figure>
<h3 id="启动类加载器"><a href="#启动类加载器" class="headerlink" title="启动类加载器"></a>启动类加载器</h3><p>  这个<strong>启动类加载器</strong>是虚拟机本身定义的，它是以C++来实现的，用于加载java的核心库&lt;JAVA_HOME&gt;\lib中或者-Xbootclasspath参数指定的，这些库都要被虚拟机所识别比如rt.jar，随便定义一个库放到以上文件夹里是不会被虚拟机加载的。</p>
<h3 id="用户自定义类加载器"><a href="#用户自定义类加载器" class="headerlink" title="用户自定义类加载器"></a>用户自定义类加载器</h3><p>  对于<strong>用户定义类加载器</strong>来说，它的工作步骤大概是这样的：</p>
<p>  首先JVM判断用户定义加载器L是不是已经记录为全限定名为N的类或者接口的初始加载器，如果是就直接返回这个类C，没必要从新创建一个类。</p>
<p>  否则，JVM就调用L的loadClass方法，参数为N，这此调用创建一个新的类或者接口C并返回，然后JVM会记录L是C的初始加载器。详细来说这个过程会执行接下来的两个操作中的一个：</p>
<p>  <strong>操作1</strong>：类加载器L可以创建一个字节数组用于表示C在Class文件结构中的字节流，之后L调用Classloader类中的defineClass方法，defineClass方法会让JVM用这个字节数组派生出一个类&lt;N,L&gt;（类的唯一性标识，上面提到过）</p>
<p>  <strong>操作2</strong>：类加载器L可以把C的加载委托给另一个加载器L’,这个过程通过用N直接或者间接地调用L‘的方法的完成，一般是loadClass方法，然后调用的结果是C。</p>
<p>无论是操作1还是操作2，如果类加载器不能加载全限定名为N的类，就会抛出ClassNotFoundException异常实例。</p>
<p>用户定义类加载器这个分类，并不是指这个加载器一定是用户定义的，比如有两个系统定义的加载器也属于这个分类：</p>
<p>1.扩展类加载器(extensions class loader)：用于加载Java的扩展库，即&lt;JAVA_HOME&gt;\lib\ext目录中的或者由java.ext.dirs系统变量指定的。</p>
<p>2.应用类加载器(Application class loader)：根据Java应用的类路径CLASSPATH来加载Java类，一般Java应用的类都由它加载，我们可以通过ClassLoader中的getSystemClassLoader方法来获取它。</p>
<h2 id="双亲委派模式"><a href="#双亲委派模式" class="headerlink" title="双亲委派模式"></a>双亲委派模式</h2><p><img src="\img\QQ图片20171205143304.png" alt="QQ图片20171205143304"></p>
<p>从图中（这里箭头不是继承关系）可以看出，除了顶层的启动类加载器以外，其余的类加载器都应当有自己委派类加载器，一般用组合关系来实现这种委派关系。</p>
<p>双亲委派模式是指：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求为派给上层的加载器去完成，只有当<strong>上层加载器不能加载的时候才会尝试自己去加载</strong>，这样就保证了java类有一种层次关系，保证了即使你用不同的类加载器去执行类加载，但是实际上我们一般都会得到相同的&lt;N,L&gt;,不会导致类关系的错乱。</p>
<p>双亲委派模式是保证Java程序稳定运行的重要部分。但并不是强制约束模型，实际上在OSGi等环境下这种模式已经被改造，不再基于树桩结构而是基于网状结构。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  类加载执行的前提是我们能以一个类的全限定名来获取字节流，至于字节流在哪里生成，我们从哪里获取这并不是虚拟机所关心的，作为一个出色的设计团队，Java的设计者最初为了满足Java Applet，设计了大名鼎鼎的类加载器机制，&lt;strong&gt;即让通过全限定名获取字节流的这个动作，放到JVM的外部，用户可以选择自行实现一些特殊的加载方案&lt;/strong&gt;，现在你知道的随着flash的流行，Java Applet这种技术已经淘汰了，现在随着html5的新起，flash也基本上接近夕阳了，可见技术的变化是普遍而剧烈的。虽然Applet死了很多年，但是类加载器却被作为一种精髓留在了java体系中，原因是它在OSGi,代码加密，热部署等等应用中有了新生的土壤。&lt;/p&gt;
&lt;p&gt;  类加载器还有一个作用就是和类的标识一起来确定这个类的唯一性，若N1是类C的全限定名称标识，而L1是加载类C类加载器，那么如果存在一个类D的全限定名称为N2,而L2是类D的加载器，那么：&lt;/p&gt;
&lt;p&gt; 当且仅当，N1=N2且L1=L2时C和D才被认为是同一个类，即C&amp;lt;N1,L1&amp;gt;=D&amp;lt;N2,L2&amp;gt;&lt;/p&gt;
&lt;p&gt; 这种相等，关系到类的Class对象的equals方法，isAssignableFrom()方法以及isInstance()方法和instanceof关键字的判断结果。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM(3):类加载过程</title>
    <link href="http://yoursite.com/2017/12/04/JVM-3-Class-Loading/"/>
    <id>http://yoursite.com/2017/12/04/JVM-3-Class-Loading/</id>
    <published>2017-12-04T04:41:21.000Z</published>
    <updated>2017-12-09T07:17:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>  一般来说，我们以.class文件的形式将类保存到磁盘上，在介绍类结构的时候我已经说了，jvm并不关系你的类从哪儿来，只要它符合jvm类结构的规范就好了，无论是以传统方式从磁盘上加载.class文件，还是从网络来获取一段流，亦或者以Proxy动态生成一个类，都没有问题，它们最终会被自己所属的<strong>类加载器</strong>加载到虚拟机的方法区中，成为jvm可以直接使用的java类型。</p>
<p>  类的生命周期有7个阶段，它们分别是：</p>
<p><code>加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化-&gt;使用-&gt;卸载</code></p>
<p>其中<code>验证-&gt;准备-&gt;解析</code>这三个阶段被称为链接（Linking）阶段</p>
<p><code>加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化</code>这5个阶段称为<strong>类加载阶段</strong></p>
<p>  在上面的声明周期七个阶段中，<strong>加载，验证，准备，初始化，卸载</strong>这5个阶段是<strong>按顺序开始</strong>的，注意这里是只是说开始，实际上它们的执行过程是<strong>交叉进行</strong>，相当于你按顺序执行了一个线程，线程里又执行了一个新的线程，如此往复的执行了5个，实际上它们是交叉执行的。</p>
<p>  上面的<strong>箭头部分有误导倾向</strong>，因为<strong>解析</strong>这个过程，为了支持Java的运行时绑定机制，<strong>有些时候在初始化过程之后开始</strong>。</p>
<a id="more"></a>
<p>  <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html#jvms-5.5" target="_blank" rel="external">虚拟机规范</a>并没有规定加载阶段在什么时候开始，但是它规定了初始化阶段，<strong>有且只有</strong>在以下<strong>6种情况（Java1.8中）</strong>下必须立刻执行，当然我们上面提到过的，初始化阶段必须在<strong>加载，验证，准备</strong>之后才能执行，所以那个时候其实已经开始了前三个阶段了，类初始化实际上就是执行clinit方法，下面列出这六种情况，<strong>如果类没有被初始化，那么先初始化</strong>：</p>
<p>  1.遇到new,getstatic,putstatic,invokestatic四条字节码指令时，比如new一个对象，或者获取或修改一个类的静态变量</p>
<p>  2.使用了某些反射方法对类进行反射调用，比如Class类中或者java.lang.reflect包中的某些方法</p>
<p>  3.初始化一个类时，发现其父类没有被初始化，那么先初始化父类</p>
<p>  4.一个被选定为虚拟机启动时初始化类的类</p>
<p>  5.首次调用方法句柄解析结果是REF_getStatic, REF_putStatic, REF_invokeStatic,REF_newInvokeSpecial这几种类型的 java.lang.invoke.MethodHandle实例，且方法句柄所对应的类没有被初始化</p>
<p>  6.如果一个接口声明了一个非抽象且非静态的方法，在初始化它的实现类之前应该初始化。</p>
<p>  以上6种情况，统称为对一个类进行主动引用，有主动引用就有被动引用，被动引用不会触发对类的初始化，比如如下几种情况的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">----------案例一------------</div><div class="line">public class Hello &#123;</div><div class="line">	</div><div class="line">	public static int alpha=123;</div><div class="line">	</div><div class="line">	//这种区域会直接编译到clinit方法中去</div><div class="line">	static &#123;</div><div class="line">		System.out.println(&quot;hello&quot;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//注意main方法是在父类Hello中，如在子类中，会因为这个main方法导致子类初始化</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		/*</div><div class="line">		*用子类A调用了父类中的字段alpha，</div><div class="line">		*但是实际上A不会被初始化，从类结构上考虑下我们就可以知道为什么，</div><div class="line">		*因为子类中根本不会有父类的字段，而父类的static在父类的clinit方法中初始化，和子类没半毛钱关系</div><div class="line">		*/</div><div class="line">		System.out.println(A.alpha);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">class A extends Hello &#123;</div><div class="line">	</div><div class="line">	static &#123;</div><div class="line">		System.out.println(&quot;m&quot;);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div><div class="line"></div><div class="line">输出：</div><div class="line">hello</div><div class="line">123</div><div class="line"></div><div class="line"></div><div class="line">--------------案例二----------</div><div class="line">class Init&#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">	/*</div><div class="line">	这种情况既不会初始化A也不会初始化Hello，为什么呢？因为数组这种类是由jvm自己生成的，而且new一个数组的字节码也是newarray而不是new</div><div class="line">	*/</div><div class="line">		A[] hello=new A[100];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">输出：</div></pre></td></tr></table></figure>
<h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>  我们首先来讨论一下<strong>类加载</strong>过程中的第一个阶段——<strong>加载</strong>，这个阶段主要就是做这样两件事情：</p>
<p> 1.把一个类的全限定名获取来的字节流转化为方法区的运行时数据结构</p>
<p> 2.在内存中（hotspot是在方法区中），生成一个代表该类的java.lang.Class对象，以作为该类各种数据的访问入口</p>
<hr>
<p><strong>数组的加载</strong></p>
<p>对于数组而言，上面我们看到了数组这种东西是JVM自己创建的，那么它的加载方式也不同，但是对于数组的元素类型（<strong>数组去掉所有维度对应的那个类型</strong>）还是要用类加载器去加载的。</p>
<p>下面的步骤用于使用类加载器L类装载器创建由描述符N表示的数组类C，L可以是引导类加载器或用户定义类加载器。</p>
<p>第一步JVM判断，如果L已被记录为具有与描述符为N的类或者接口的组件类型的数组类的启动装入器，则该类是C，并且不需要创建数组类。 （就是该数组类型已经被在加载了，就不再加载）</p>
<p>否则，执行以下步骤以创建C：</p>
<p>如果组件类型（<strong>数组去掉一个维度的类型</strong>）是引用类型，类加载器L递归的使用这一节说到的类加载算法，从而创建的组件类型C.</p>
<p>java虚拟机创建一个新的显示组件类型和维数的数组类。</p>
<p>如果组件类型是引用类型，那么C被标记为由组件类型的定义类装入器定义的。</p>
<p>否则（比如int k[],这基本类型），C被标记为由引导类装入器定义的。</p>
<p>在以上两种的任何情况下，接下来java虚拟机都会记录L是C的类加载器。如果组件类型是引用类型，则数组类的可访问性取决于其组件类型的可访问性。否则，数组类的可访问性是公共的。 </p>
<hr>
<p>  有些人可能会好奇方法区中怎么存储类，这个问题我可能会写一篇新的文章来说明，目前我们只讨论类加载过程，实际上JVM规范是没有给出方法区以什么数据结构出现的，但是我们可以在未来讨论一下Hotspot中的实现，正如上面所说的，Hotspot会在方法区中创建一个标识类的java.lang.Class对象。</p>
<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>  我们把验证，准备，解析3个阶段统称为链接阶段，链接阶段是与加载阶段交替进行的，即一边加载一边链接。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>  首先我们来看看验证阶段，这个阶段并不是运行是必须的，你完全可以不验证类，只要你保证它一定是符合虚拟机规范正常运行的，比如对于一些软件中运行了不知道多少年的类，你可以认为他们不需要浪费时间去验证，因为以前已经验证过了（验证是非常耗时的），我们可以使用-Xverify:none参数来关闭大部分类验证措施。</p>
<p>  虽然验证并非是必要的，但是不代表它不是重要的，它是虚拟机能够稳定运行的重要防线，我们虽然会浪费时间对一个类进行重复的验证，不过我们也可以防止一些恶意的意想不到的字节流对我们的虚拟机造成不可预测的破坏。</p>
<p>  如果验证阶段验证到字节流不符合Class规范，那么虚拟机会抛出java.lang.VerifyError或者其子异常。</p>
<p>以HotSpot验证过程大概分为四个部分：</p>
<p>1.文件结构验证</p>
<p>  这个阶段是验证里唯一一个基于二进制字节流的阶段，通过了该阶段之后字节流就变成方法区的数据结构了，该阶段主要是验证像魔术，版本，是否符合UTF8编码等等不需要语义分析的验证。</p>
<p>2.元数据验证</p>
<p>  这个阶段主要是对类的继承，抽象等等语义进行验证，即对类的元数据进行语义验证</p>
<p>3.字节码验证</p>
<p>  主要通过数据流和控制流分析看程序语义是否合法，还有就是对方法体进行校验，在上篇文章中我们提到的额StackMapTable属性就是在这个阶段中使用的，它描述了方法体中所有的基本代码块开始是本地变量表和操作数栈应有的关系，验证期间对着它来推导状态的合法性。</p>
<p>4.符号引用验证</p>
<p>  这个阶段的验证发生在解析阶段中，主要对符号引用转化为直接引用的可行性进行验证，如果通过不了就会抛出一个java.lang.IncompatibleClassChangeError异常的子类型。</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>  该阶段涉及到为类创建静态字段（static fields）并为他们设置初始值。</p>
<p>  这里的初始值并不是指用户在诸如<code>static int k=1;</code>这样的语句中设定的k的值为1（这个阶段是clinit做的）,而是对于int类型给定初始值为0，对boolean则是为false，对reference则是null，等等。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>  解析阶段即是<strong>虚拟机将常量池内的符号引用替换为直接引用的过程</strong>。</p>
<p>  JVM中<em>anewarray</em>, <em>checkcast</em>, <em>getfield</em>, <em>getstatic</em>, <em>instanceof</em>,<em> invokedynamic</em>, <em>invokeinterface</em>, <em>invokespecial</em>, <em>invokestatic</em>,<em>invokevirtual</em>, <em>ldc</em>, <em>ldc_w</em>, <em>multianewarray</em>, <em>new</em>, <em>putfield</em>,  <em>putstatic</em>都把符号引用映射到在运行时常量池（run-time constant pool），所以在执行这些语句之前都需要先执行对应符号引用的解析。</p>
<p>  对于除了invokedynamic之外的指令，对同一个符号引用的多次解析是非常平常的，因此虚拟机会把第一次解析结果进行缓存，从而实现只解析一次，实际操作方式是在运行时常量池中把直接引用标记为已解析状态。这样一来如果一个符号以前被正确解析过，那么解析请求就应当一直成功，如果第一次失败了，那么后续失败抛出的异常也应该相同。这些指令都可以在刚刚完成加载阶段就开始解析。</p>
<p>  对应invokedynamic来说，它是要等到程序运行到这条指令才开始解析，所以我们说类的解析阶段不固定，可能是在初始化之后才完成也说不定。当碰到前面某个已经由invokedynamic触发过解析的符号引用时，并不意味着该解析结果对于其他的invokedynamic同样适用。</p>
<p>  解析动作主要针对7中符号：</p>
<p>  类和接口，字段，类方法，接口方法，方法类型，方法句柄以及调用点</p>
<h4 id="类和接口解析"><a href="#类和接口解析" class="headerlink" title="类和接口解析"></a>类和接口解析</h4><p>对类和接口的解析我们这样来描述：</p>
<p> 如果当前代码所属类D，现在要解析一个未解析的符号N为一个类或者接口的直接引用，那么：</p>
<ol>
<li>如果C不是数组，那么VM把代表N的权限定名给用D的类加载器，然后D的类加载器去加载C。</li>
<li><p>如果C是数组则按照第一点加载数组的元素类型。接着虚拟机生成一个代表此数组维度和元素的数组对象</p>
<p>3.上面的步骤正常执行完，那么最后进行符号引用验证，确认D是否具备对C的访问权，不具备就抛出java.lang.IllegalAccessError。</p>
</li>
</ol>
<h4 id="字段解析"><a href="#字段解析" class="headerlink" title="字段解析"></a>字段解析</h4><p>  解析一个未被解析过的字段的符号引用，首先对该字段表内class_index项中索引的CONSTANT_Class_info符号引用进行解析（即先解析这个对应的类，参照上面的对类和接口的解析）。</p>
<p>如果C本身就包含了简单名称和字段描述符的字段都与目标相匹配的字段，则字段查找成功。返回这个字段的直接引用，查找结束。</p>
<p>否则，如果C定义了接口那么会按照继承关系递归的搜索各个接口和他的父接口，如果接口中包含了简单名称和字段的全部描述符都于目标相匹配的字段，则返回这个字段的直接引用，查找结束。</p>
<p>否则，如果C不是java.lang.Object就递归搜索其父类，如果父类中包含了简单名称和字段描述都与目标相匹配的字段，则返回该字段的直接引用，查找结束。</p>
<p>否则，字段查找失败，抛出java.lang.NoSuchFieldError异常</p>
<p>上面的步骤正常执行完，那么最后进行符号引用验证，上下文是否具备对字段的访问权，不具备就抛出java.lang.IllegalAccessError。</p>
<h4 id="类方法解析"><a href="#类方法解析" class="headerlink" title="类方法解析"></a>类方法解析</h4><p>  第一步先解析出类方法表中class_index所属的<strong>类引用</strong>,我们用C代表这个类。</p>
<p>  这里首先明确一点类方法和接口方法引用的常量定义是分开的，如果类方法表中class_index指向一个接口的索引就抛出java.lang.IncompatibleClassChangeError异常。</p>
<p>  如果C中有简单名称和描述符都相匹配的方法，有则返回该方法的直接引用，查找结束。</p>
<p>  否则递归寻找父类中是否有简单名称和描述符都相匹配的方法，有则返回该方法的直接引用，查找结束。</p>
<p>  否则递归寻找C实现的接口即接口的父接口中简单名称和描述符都相匹配的方法，有则说明C是抽象类，抛出java.lang.AbstractMethodError异常。</p>
<p>  否则肯定查找失败了，直接抛出java.lang.IllegalAccessError。</p>
<p>  上面的步骤正常执行完，那么最后进行符号引用验证，上下文是否具备对方法的访问权，不具备就抛出java.lang.IllegalAccessError。</p>
<h4 id="接口方法解析"><a href="#接口方法解析" class="headerlink" title="接口方法解析"></a>接口方法解析</h4><p>第一步先解析出类方法表中class_index所属的<strong>接口引用</strong>,我们用C代表这个接口。</p>
<p>  这里首先明确一点类方法和接口方法引用的常量定义是分开的，如果类方法表中class_index指向一个类的索引就抛出java.lang.IncompatibleClassChangeError异常。</p>
<p>  如果C中有简单名称和描述符都相匹配的方法，有则返回该方法的直接引用，查找结束。</p>
<p>  否则递归寻找C的父接口中简单名称和描述符都相匹配的方法，直到找到java.lang.Object类， 如果找到有简单名称和描述符都相匹配的方法，有则返回该方法的直接引用，查找结束。</p>
<p>  否则肯定查找失败了，直接抛出java.lang.NoSuchMethodError异常</p>
<p>  接口中的方法默认都是public和static的,不存在访问权限问题。</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>  初始化阶段(Initialization)一般是类加载的最后一步(解析阶段有时候可能在这之后发生)，我们知道在链接过程中的准备阶段，我们的类变量就已经赋了类型默认值，但是<code>static int k=3;</code>这个3是的赋值就是发生在初始化阶段的,准确来说它发生在类构造器clinit方法执行的过程中。</p>
<p>  我们在讨论类的方法表的时候说过，编译器可能会自动给你加一些你没有写过的方法，比如类构造器就是一个这样的方法。</p>
<p>  编译器自动收集类中所有的类变量的赋值动作和静态代码块(static标注)，这个顺序由Java源代码给出的顺序决定，这里有一个很有意思的经常出面试题的部分，就是<strong>static块对出现在它之前类变量可以赋值但是不可以访问</strong></p>
<p>比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public class Hello &#123;</div><div class="line">	static &#123;</div><div class="line">		alpha=1;</div><div class="line">		System.out.println(alpha);//该句报错</div><div class="line">	&#125;</div><div class="line">	public static int alpha=124;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//如果改为，则没问题</div><div class="line">class A extends Hello &#123;</div><div class="line">	public static int alpha=124;</div><div class="line">	static &#123;</div><div class="line">		alpha=1;</div><div class="line">		System.out.println(alpha);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  第二点要注意的就是，clinit不需要现实的调用父类的clinit，它会自动保证在执行子类的类构造器方法前已经执行了父类的类构造器。</p>
<p>  一个<strong>类或者接口</strong>中根本没有静态语句块和对静态变量赋值操作那么编译器可以不生成clinit方法，注意接口也可能有clinit来做对静态变量的初始化操作。</p>
<p>  VM会自动保证clinit方法在多线程环境中的同步和加锁操作，只能有一个线程去执行clinit，且同一个类加载器下，一个类型只会初始化一次，所以即使有多个线程同时执行这个类型的clinit，也只会有一个线程执行成功。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  一般来说，我们以.class文件的形式将类保存到磁盘上，在介绍类结构的时候我已经说了，jvm并不关系你的类从哪儿来，只要它符合jvm类结构的规范就好了，无论是以传统方式从磁盘上加载.class文件，还是从网络来获取一段流，亦或者以Proxy动态生成一个类，都没有问题，它们最终会被自己所属的&lt;strong&gt;类加载器&lt;/strong&gt;加载到虚拟机的方法区中，成为jvm可以直接使用的java类型。&lt;/p&gt;
&lt;p&gt;  类的生命周期有7个阶段，它们分别是：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;加载-&amp;gt;验证-&amp;gt;准备-&amp;gt;解析-&amp;gt;初始化-&amp;gt;使用-&amp;gt;卸载&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;验证-&amp;gt;准备-&amp;gt;解析&lt;/code&gt;这三个阶段被称为链接（Linking）阶段&lt;/p&gt;
&lt;p&gt;&lt;code&gt;加载-&amp;gt;验证-&amp;gt;准备-&amp;gt;解析-&amp;gt;初始化&lt;/code&gt;这5个阶段称为&lt;strong&gt;类加载阶段&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;  在上面的声明周期七个阶段中，&lt;strong&gt;加载，验证，准备，初始化，卸载&lt;/strong&gt;这5个阶段是&lt;strong&gt;按顺序开始&lt;/strong&gt;的，注意这里是只是说开始，实际上它们的执行过程是&lt;strong&gt;交叉进行&lt;/strong&gt;，相当于你按顺序执行了一个线程，线程里又执行了一个新的线程，如此往复的执行了5个，实际上它们是交叉执行的。&lt;/p&gt;
&lt;p&gt;  上面的&lt;strong&gt;箭头部分有误导倾向&lt;/strong&gt;，因为&lt;strong&gt;解析&lt;/strong&gt;这个过程，为了支持Java的运行时绑定机制，&lt;strong&gt;有些时候在初始化过程之后开始&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM(2):类文件结构（下）</title>
    <link href="http://yoursite.com/2017/11/29/JVM-2-Structure-of-class-file-II/"/>
    <id>http://yoursite.com/2017/11/29/JVM-2-Structure-of-class-file-II/</id>
    <published>2017-11-29T03:55:41.000Z</published>
    <updated>2017-12-03T13:47:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>  如上篇文章所说，这篇文章我介绍一下类文件结构里比较复杂的<strong>属性表</strong>，属性列表这项数据可能存在于字段表，方法表，和类文件本身结构以及Code属性表中，我们可以 参照面的类C结构，来确认这一点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">类文件结构</div><div class="line">*/</div><div class="line">ClassFile &#123;</div><div class="line">    u4             magic;</div><div class="line">    u2             minor_version;</div><div class="line">    u2             major_version;</div><div class="line">    u2             constant_pool_count;</div><div class="line">    cp_info        constant_pool[constant_pool_count-1];</div><div class="line">    u2             access_flags;</div><div class="line">    u2             this_class;</div><div class="line">    u2             super_class;</div><div class="line">    u2             interfaces_count;</div><div class="line">    u2             interfaces[interfaces_count];</div><div class="line">    u2             fields_count;</div><div class="line">    field_info     fields[fields_count];</div><div class="line">    u2             methods_count;</div><div class="line">    method_info    methods[methods_count];</div><div class="line">    /*属性表*/</div><div class="line">    u2             attributes_count;</div><div class="line">    attribute_info attributes[attributes_count];</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*方法表（和字段表结构相同）*/</div><div class="line">field_info &#123;</div><div class="line">    u2             access_flags;</div><div class="line">    u2             name_index;</div><div class="line">    u2             descriptor_index;</div><div class="line">    /*属性表*/</div><div class="line">    u2             attributes_count;</div><div class="line">    attribute_info attributes[attributes_count];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>  属性表的结构要求比之class文件中的其他数据项要弱的多，其他数据项由于是完全按照偏移来确定的，所以顺序必须要是JVM规范给定的顺序，而这个属性表不一样，属性表相当于一种<strong>键值结构</strong>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">attribute_info &#123;</div><div class="line">    u2 attribute_name_index;</div><div class="line">    u4 attribute_length;</div><div class="line">    u1 info[attribute_length];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  这个构造是属性表的基本构造，由于有很多种不同的属性表，所以对于第三个数据项这个info（相当于值），可能内部被划分为了很多个其他的数据项，现在我们暂时先放下这个疑问，上面我说属性表相当于一种键值结构，attribute_name_index相当于键，它指向了一个CONSTANT_Utf8_info结构，代表了这个属性的名字。</p>
<p>  有了这个键值的概念我们就不难理解为什么属性表并不需要按一定顺序排列每一个属性，因为JVM是按照这个attribute_name_index指向的名字来确定这个属性是什么属性，它的info的具体结构是怎么样的，所以你如果自己实现JVM和编译器，你可以自己定义属性名（不能与已有的属性重复），然后为了提供解析操作的实际代码，对于JVM来说，如果碰到它不认识的属性名，它就选择直接忽略了。</p>
<p>  JVM规范给出了一些预定义的属性，要求java虚拟机应当能识别这些属性，在<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7" target="_blank" rel="external">官方文档</a>（Java虚拟机规范 SE8）中，我们可以从4.7节得到所有的23项属性的详细信息。</p>
<p>首先我们来看看5项关乎到class文件能不能被JVM正确解释的属性:</p>
<h3 id="ConstantValue"><a href="#ConstantValue" class="headerlink" title="ConstantValue"></a>ConstantValue</h3><p>ConstantValue的作用是通知虚拟机自动为静态变量赋值（即被static属性标识的字段），只有被static标识的字段虚拟机才查看ConstantValue属性，否则即使有该属性也被忽略，静态变量其实有两种赋值方式：</p>
<p><strong>clinit赋值</strong></p>
<p>一种就是非常量型静态变量，如<code>static int k=1</code>，这种变量是在类加载的初始化阶段，执行clinit函数来进行赋值的，clinit函数是编译器自动生成的，赋值字节码指令已经被写在了里面。</p>
<p><strong>ConstantValue赋值</strong></p>
<p>对于如<strong>基本类型和String</strong>（其他引用类型不支持），如果字段被static和final同时修饰，这种情况在编译期你就可以确定它是哪个值了，所以直接生成ConstantValue属性来进行初始化（编译期）。</p>
<p>以上两种种赋值的条件差异是javac自行决定的，如果你自己实现一个编译器也可以对没有final修饰的static变量进行编译期初始化，JVM规范（SE 8）上是这么说的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">这段话里没有提到final字段，那么我们可以猜测javac对只有static修饰的字段，根本不生成ConstantValue属性</div><div class="line">*/</div><div class="line">If the ACC_STATIC flag in the access_flags item of the field_info structure is set, then the field represented by the field_info structure is assigned the value represented by its ConstantValue attribute as part of the initialization of the class or interface declaring the field (§5.5). This occurs prior to the invocation of the class or interface initialization method of that class or interface (§2.9). </div><div class="line">Otherwise, the Java Virtual Machine must silently ignore the attribute.</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">ConstantValue_attribute &#123;</div><div class="line">    u2 attribute_name_index;</div><div class="line">    u4 attribute_length;</div><div class="line">    /*info部分*/</div><div class="line">    u2 constantvalue_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  具体你可以看到constantvalue_index是一个指向常量池的u2类型，而常量池中字面量常量只有基本类型和String，所以对于其他引用类型，你根本不可能用ConstantValue这种东西来定值。</p>
<h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>Code属性只<strong>可能</strong>存在于method_info中，抽象方法之类的没有方法体的当然就没有Code属性这种东西了，具体的code属性如下表所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">Code_attribute &#123;</div><div class="line">    u2 attribute_name_index;//固定指向值为Code的一个CONSTANT_Utf8_info</div><div class="line">    u4 attribute_length;</div><div class="line">    /*info部分*/</div><div class="line">    u2 max_stack;//操作数栈的最大深度</div><div class="line">    u2 max_locals;//局部变量表的存储空间，单位Slot(4个字节)</div><div class="line">    /*代码部分*/</div><div class="line">    u4 code_length;</div><div class="line">    u1 code[code_length];</div><div class="line">    /*显示异常处理表部分*/</div><div class="line">    u2 exception_table_length;</div><div class="line">    exception_info exception_table[exception_table_length];</div><div class="line">    /*属性表部分*/</div><div class="line">    u2 attributes_count;</div><div class="line">    attribute_info attributes[attributes_count];</div><div class="line">&#125;</div><div class="line"></div><div class="line">exception_info&#123;</div><div class="line">	u2 start_pc;</div><div class="line">	u2 end_pc;</div><div class="line">	u2 handler_pc;</div><div class="line">	u2 catch_type;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>字节码部分</strong></p>
<p>code_length和code[]一起构成了方法体被编译之后的字节码指令流,jvm的字节码指令是单字节的基于栈的字节码，单字节意思就是最多256条，目前只用了200多条，详细是怎么样的，我以后会写关于<strong>字节码执行引擎</strong>的文章，详细讨论这个问题。</p>
<p><strong>显示异常处理表部分</strong></p>
<p>显示异常处理表部分与try/catch语句有关，我们可以看到exception_info这个结构，指示了字节码从start_pc行到end_pc行（不包含），出现了catch_type类型或者其子类的话，就转跳到handler_pc行进行处理。</p>
<p><strong>属性表部分</strong></p>
<p>code中的属性表中的属性一般都是运行时非必须的，但这些熟悉往往会在程序员编程和调试时有着巨大的作用，比如我们编程时的方法的参数的参数名，或者调试时出现异常标识的异常出现的行号等等，主要有下面几种:</p>
<p>1.<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.12" target="_blank" rel="external">LineNumberTable</a>  //用于标识java代码中实际行号和字节码偏移量的对应关系</p>
<p>2.<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.13" target="_blank" rel="external">LocalVariableTable</a>  //用于描述局部变量表中变量与java源码中定义变量的对应关系</p>
<p>3.<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.14" target="_blank" rel="external">LocalVariableTypeTable</a>  //1.5引入泛型后用来代替LocalVariableTable</p>
<p>4.<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.4" target="_blank" rel="external">StackMapTable</a>    //用于做类加载阶段的类型验证，下面我们会详细介绍它。</p>
<p>以上属性的具体表现形式我已经表示了官方文档超链接，大家可以自己去看看，或者参考一下周志明的<a href="https://book.douban.com/subject/24722612/" target="_blank" rel="external">《深度理解java虚拟机》</a>，里面有一个简单的描述。</p>
<h3 id="StackMapTable"><a href="#StackMapTable" class="headerlink" title="StackMapTable"></a>StackMapTable</h3><p>如上面所说，StackMapTable是一个只会存在于Code中的属性，它是在jdk 1.6后被引入的，用于代替以前开销极大的通过数据流分析的类型推导。如果一个Code的属性表里不包含StackMapTable属性，那么虚拟机默认它包含了一个隐式的stack map attribute，相当于一个StackMapTable但是number_of_entries为0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">StackMapTable_attribute &#123;</div><div class="line">    u2              attribute_name_index;</div><div class="line">    u4              attribute_length;</div><div class="line">    u2              number_of_entries;</div><div class="line">    stack_map_frame entries[number_of_entries];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>每一个stack_map_frame都显示或者隐式的指明它所应用的字节码偏移量，以及该偏移量对应的一组局部变量和操作数栈项目的验证类型（Verifiacation Types）。</strong></p>
<p>我还是在这里详细说一下这个stack_map_frame，以及它内部可能会包含的标识验证类型的另一个结构verification_type_info,如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">这里用union标识的意思是这种结构是C语言中类似union的结构，就是说这里面的项目只会出现一项</div><div class="line">*/</div><div class="line">union stack_map_frame &#123;</div><div class="line">    same_frame;</div><div class="line">    same_locals_1_stack_item_frame;</div><div class="line">    same_locals_1_stack_item_frame_extended;</div><div class="line">    chop_frame;</div><div class="line">    same_frame_extended;</div><div class="line">    append_frame;</div><div class="line">    full_frame;</div><div class="line">&#125;</div><div class="line"></div><div class="line">union verification_type_info &#123;</div><div class="line">    Top_variable_info;</div><div class="line">    Integer_variable_info;</div><div class="line">    Float_variable_info;</div><div class="line">    Long_variable_info;</div><div class="line">    Double_variable_info;</div><div class="line">    Null_variable_info;</div><div class="line">    UninitializedThis_variable_info;</div><div class="line">    Object_variable_info;</div><div class="line">    Uninitialized_variable_info;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="verification-type-info"><a href="#verification-type-info" class="headerlink" title="verification_type_info"></a>verification_type_info</h4><p>verification_type_info用于指示一个或者两个<strong>位置</strong>（如果是64位类型则占2个slot）的类型，<strong>位置指的是一个局部变量或者一个操作数栈中的项目</strong>，验证类型就是用这个类似于union结构的verification_type_info来表示的，由一个单字节的tag来表示这个union里用的是哪一个项目，在tag后跟着零个或者多个字节，用来表示更多的信息。具体的union可能表示的项目有9个，我们这里列举几个，其余的你可以参考<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.4" target="_blank" rel="external">官方文档</a>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">如果verification_type_info中的tag是5，那么它指示对应位置的验证类型是null</div><div class="line">*/</div><div class="line">Null_variable_info &#123;</div><div class="line">    u1 tag = ITEM_Null; /* 5 */</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">/*</div><div class="line">如果tag是7,那么它表示该位置验证类型是由常量池的index为cpool_index的CONSTANT_Class_info结构指示的</div><div class="line">*/</div><div class="line">Object_variable_info &#123;</div><div class="line">    u1 tag = ITEM_Object; /* 7 */</div><div class="line">    u2 cpool_index;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">如果tag是8，则说明这个位置的验证类型还没有初始化，offset项目指示了包含该StackMapTable属性的Code的code数组中的偏移，该偏移对应的字节码是一个new指令，将会创建存储在该位置的对象</div><div class="line">*/</div><div class="line">Uninitialized_variable_info &#123;</div><div class="line">    u1 tag = ITEM_Uninitialized; /* 8 */</div><div class="line">    u2 offset;</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">这里还存在一个Top_variable_info类型可能大家看名字也看不明白，我在这里说一下</div><div class="line">对于Long和Double这两种类型来说，他们是64位的，所以是占2个slot，那么他们该怎么确定类型呢？</div><div class="line">如果第一个位置是一个局部变量，那么</div><div class="line">它一定不是最大index的那个局部变量，它的下一个变量的验证类型是top</div><div class="line">如果第一个位置是一个操作数栈项目，那么</div><div class="line">它一定不是栈顶元素</div><div class="line">它上面的那个元素（更靠近栈顶的）的验证类型是top</div><div class="line">*/</div></pre></td></tr></table></figure>
<h4 id="stack-map-frame"><a href="#stack-map-frame" class="headerlink" title="stack_map_frame"></a>stack_map_frame</h4><p>  接下来我们来看一下stack_map_frame这个结构，中文就把它叫做<strong>栈映射帧</strong>，它同样是类似于union的，然后它也有一个单字节的frame_type数据项来指示这union到底表示的是哪一种项目,一共有7种可能上面已经列出来了。</p>
<p>  每一个<strong>栈映射帧</strong>都会依赖于前一个frame中的一些语义，第一个<strong>栈映射帧</strong>其实是隐式的，这个隐式的frame会被类型检查器（type checker）根据Code属性的所在的方法描述符给计算出来，在上面的entries[]中的0号元素其实是第二个,所以上面有提到过<code>如果一个Code的属性表里不包含StackMapTable属性，那么虚拟机默认它包含了一个隐式的stack map attribute，相当于一个StackMapTable但是number_of_entries为0。</code></p>
<p>  栈映射帧所用的字节码偏移是通过它里面指定的offset_delta计算出来的，并且offset_delta+1还会作为前个帧的字节码偏移，除非前一个帧是首帧（initial frame），这种情况下字节码偏移就是首帧指定的offset_delta。</p>
<p>  为什么使用<strong>偏移增量</strong>（即offset_delta），而不是存储实际的字节码偏移量，是因为根据定义，我们可以确保栈映射帧处于正确的排序顺序。</p>
<p>我这里同样拿出几种来介绍，其余的可以参考<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.4" target="_blank" rel="external">官方文档</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">当frame_type在0-63之间，就代表了这个frame中存储的是一个same_frame，它表明这个frame所代表的局部变量与前一个frame相同而且操作数栈为空，frame_type的数值就是offset_delta</div><div class="line">*/</div><div class="line">same_frame &#123;</div><div class="line">    u1 frame_type = SAME; /* 0-63 */</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">只有当fram_type为247的时候才确定类型为same_locals_1_stack_item_frame_extended，它表明这个frame所代表的局部变量与前一个frame相同而且操作数栈为空，但是明确给出了offset_delta，然后后面跟着类型数据项，上面我们已经介绍过了</div><div class="line">*/</div><div class="line">same_locals_1_stack_item_frame_extended &#123;</div><div class="line">    u1 frame_type = SAME_LOCALS_1_STACK_ITEM_EXTENDED; /* 247 */</div><div class="line">    u2 offset_delta;</div><div class="line">    verification_type_info stack[1];</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">这个类型中，它表明这个frame所代表的局部变量与前一个frame相同而且操作数栈为空，除非最后的k个局部变量缺失，k等于251-frame_type。</div><div class="line">*/</div><div class="line">chop_frame &#123;</div><div class="line">    u1 frame_type = CHOP; /* 248-250 */</div><div class="line">    u2 offset_delta;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h3><p>异常属性和上面code属性中提到的显示异常处理表不同，它指示了方法签名中throws后面标识的可能会抛出的异常</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Exceptions_attribute &#123;</div><div class="line">    u2 attribute_name_index;</div><div class="line">    u4 attribute_length;</div><div class="line">    u2 number_of_exceptions;</div><div class="line">    u2 exception_index_table[number_of_exceptions];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个属性比较简单，exception_index_table[]的每个u2项目都指向常量池中一个标识了异常类型的CONSTANT_Class_info型的常量。</p>
<h3 id="BootstrapMethods"><a href="#BootstrapMethods" class="headerlink" title="BootstrapMethods"></a>BootstrapMethods</h3><p>BootstrapMethods属性在jdk 1.7后增加，它仅存在于类文件属性表里，目的是为了保存invokedynamic指令引用的引导方法限定符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">BootstrapMethods_attribute &#123;</div><div class="line">    u2 attribute_name_index;</div><div class="line">    u4 attribute_length;</div><div class="line">    u2 num_bootstrap_methods;</div><div class="line">    bootstrap_method bootstrap_methods[num_bootstrap_methods];</div><div class="line">&#125;</div><div class="line"></div><div class="line">bootstrap_method&#123;   </div><div class="line">	u2 bootstrap_method_ref;//指向常量池中的一个CONSTANT_MethodHandle_info</div><div class="line">	u2 num_bootstrap_arguments;</div><div class="line">	u2 bootstrap_arguments[num_bootstrap_arguments];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>bootstrap_arguments[]中的每一个项目，都是对常量池中的以下几种结构之一的索引</p>
<p>1.CONSTANT_String_info, CONSTANT_Class_info<br>2.CONSTANT_Integer_info, CONSTANT_Long_info<br>3.CONSTANT_Float_info, CONSTANT_Double_info<br>4.CONSTANT_MethodHandle_info<br>5.CONSTANT_MethodType_info</p>
<p>然后我们来看看在Java平台下类关乎到文件能否正确解析的属性，一共有12个，这里我也说几个：</p>
<p>1.InnerClasses<br>2.EnclosingMethod<br>3.Synthetic<br>4.Signature<br>5.RuntimeVisibleAnnotations<br>6.RuntimeInvisibleAnnotations<br>7.RuntimeVisibleParameterAnnotations<br>8.RuntimeInvisibleParameterAnnotations<br>9.RuntimeVisibleTypeAnnotations<br>10.RuntimeInvisibleTypeAnnotations<br>11.AnnotationDefault<br>12.MethodParameters</p>
<h3 id="InnerClasses"><a href="#InnerClasses" class="headerlink" title="InnerClasses"></a>InnerClasses</h3><p>首先看看这个InnerClasses,看名字就知道，这个属性就是记录内部类的，准确来说它记录了内部类和宿主类之间的关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">InnerClasses_attribute &#123;</div><div class="line">    u2 attribute_name_index;</div><div class="line">    u4 attribute_length;</div><div class="line">    u2 number_of_classes;</div><div class="line">    inner_class_info classes[number_of_classes];</div><div class="line">&#125;</div><div class="line"></div><div class="line">inner_class_info&#123;   </div><div class="line">	u2 inner_class_info_index;</div><div class="line">	u2 outer_class_info_index;</div><div class="line">	u2 inner_name_index;</div><div class="line">    u2 inner_class_access_flags;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  对于inner_class_info来说，开始4个字节就是两个个指向常量池中某个CONSTANT_Class_info的常量索引，分别代表了内部类和宿主类的符号引用。</p>
<p>  inner_name_index是一个CONSTANT_Ut8_info常量索引，这个常量即内部类类名，如果是<strong>匿名内部类</strong>，则这项值为0，即没有引用任何常量（上一篇文章中说过这个问题）。</p>
<p>  最后的inner_class_access_flags是访问标志位，这个具体有哪些标志可以参考<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.6" target="_blank" rel="external">官方文档</a>。</p>
<h3 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h3><p>1.5之后，为了支持擦出法实现的伪泛型，jvm引入Singature。如果一个类型，接口，构造器，方法，或者字段（field）的声明中包含了类型变量或者参数化类型，则javac必须为他们添上signature属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Signature_attribute &#123;</div><div class="line">    u2 attribute_name_index;</div><div class="line">    u4 attribute_length;</div><div class="line">    u2 signature_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>signature_index是一个指向常量池CONSTANT_Utf8_info的符号引用，里面包含的字符串表示类，方法或者字段签名，具体取决于Signature属于哪个表结构，签名字符串的表述形式类似于我们上面介绍过的描述符，具体可以看<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.9.1" target="_blank" rel="external">官方文档</a>。</p>
<p>我们运用java的反射api可以获取到泛型的信息，实际上就是来源于Signature属性。</p>
<h3 id="MethodParameters"><a href="#MethodParameters" class="headerlink" title="MethodParameters"></a>MethodParameters</h3><p>最后我们来看看方法参数表,他只存在方法表(method_info)中，且每个方法表最多只能有一个。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">MethodParameters_attribute &#123;</div><div class="line">    u2 attribute_name_index;</div><div class="line">    u4 attribute_length;</div><div class="line">    u1 parameters_count;</div><div class="line">    parameter_info parameters[parameters_count];</div><div class="line">&#125;</div><div class="line"></div><div class="line">parameter_info&#123;  </div><div class="line">	u2 name_index;</div><div class="line">	u2 access_flags;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于parameter_info来说</p>
<p>name_index是一个指向CONSTANT_Utf8_info的符号引用，它的值如果为0，那么表示这是一个无名的形参，如果非0则表示了一个<strong>有效的</strong>参数限定名称。</p>
<p>access_flags,有三种值</p>
<p>0x0010 (ACC_FINAL),这个大家都用过，表示这个参数是不可变的</p>
<p>另外两种可能大家没有接触过</p>
<p>0x1000 (ACC_SYNTHETIC)和 0x8000 (ACC_MANDATED)</p>
<p>ACC_SYNTHETIC表示这个参数不是由用户代码生成的，而是由比如编译器这样的东西加进去的，比如this这个参数。</p>
<p>ACC_MANDATED则表示这个形参是隐式声明在代码中的</p>
<p>还有6项属性不是运行时必须的，但是我们在编写代码时很多信息来源于他们：</p>
<p><strong>SourceFile</strong></p>
<p>  在类属性表，指定该类对应的源文件名</p>
<p><strong>SourceDebugExtension</strong></p>
<p>这个属性用于提供额外的调试信息，有些字节码的来源并不是.java文件，比如可以来自JSP，对于JSP的调试我们是无法通过但但从LineNumberTable来定位到JSP行号和堆栈的对应关系的，于是1.6后引入了该属性，以至于新的调试标准机制（JSR-45中定义）可以用它来作为调试信息。</p>
<p><strong>下面三个属性，我在介绍Code属性时已经说过了</strong></p>
<p><strong>LineNumberTable</strong><br><strong>LocalVariableTable</strong><br><strong>LocalVariableTypeTable</strong></p>
<p><strong>Deprecated</strong></p>
<p>  Deprecated指定某个类，字段或者方法不再推荐使用，即在源码中用@deprecated标识</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  如上篇文章所说，这篇文章我介绍一下类文件结构里比较复杂的&lt;strong&gt;属性表&lt;/strong&gt;，属性列表这项数据可能存在于字段表，方法表，和类文件本身结构以及Code属性表中，我们可以 参照面的类C结构，来确认这一点。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;/*&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;类文件结构&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;*/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;ClassFile &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    u4             magic;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    u2             minor_version;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    u2             major_version;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    u2             constant_pool_count;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    cp_info        constant_pool[constant_pool_count-1];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    u2             access_flags;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    u2             this_class;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    u2             super_class;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    u2             interfaces_count;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    u2             interfaces[interfaces_count];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    u2             fields_count;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    field_info     fields[fields_count];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    u2             methods_count;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    method_info    methods[methods_count];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    /*属性表*/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    u2             attributes_count;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    attribute_info attributes[attributes_count];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;/*方法表（和字段表结构相同）*/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;field_info &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    u2             access_flags;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    u2             name_index;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    u2             descriptor_index;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    /*属性表*/&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    u2             attributes_count;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    attribute_info attributes[attributes_count];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM (1):类文件结构（上）</title>
    <link href="http://yoursite.com/2017/11/25/JVM-1-Structure-of-class-file/"/>
    <id>http://yoursite.com/2017/11/25/JVM-1-Structure-of-class-file/</id>
    <published>2017-11-25T06:02:15.000Z</published>
    <updated>2017-11-28T07:26:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>  <strong>平台无关性</strong>是Java语言最重要的特性之一，这个特性由<strong>字节码</strong>这种中间码作为虚拟机执行的文件载体被大家所认识，<strong>一次编译到处运行</strong>的这种<strong>平台无关性</strong>在一个学习者在刚刚学习编程而且选择的是Java语言时就会了解，但是随着学习者技术视野不断扩张，就会意识到jvm不是提供了java运行的平台，而是提供了字节码运行的平台，像Scala，Groovy，Ruby，Python等等语言通过他们自己的编译器，也可以编译成字节码从而在jvm平台上运行，即<strong>语言无关性</strong>。</p>
<p>  一个非凡的公司去设计一款非凡的程序平台，Java在诞生之初，JVM和Java语言的规范就是分开来的，JVM只关心Class文件里的字节码，并不关心它是怎么来的，你甚至可以用16进制编辑器自己写一份字节码，前提你对它的结构非常的清楚，你也可自己设计一门语言，然后让这门语言编译成字节码，运行在jvm平台上，以作为你的毕业设计或者开源项目。</p>
<a id="more"></a>
<h2 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h2><p>  上面一段中我提到过”一个非凡的公司去设计一款非凡的程序平台，Java在诞生之初，JVM和Java语言的规范就是分开来的”,你可能会怀疑句话，因为一个程序语言编译成一个中间载体，完成这个过程时就顺便实现了所谓的<strong>语言无关性</strong>。实际上高超的设计团队，并不会为了迎合某种语言的需求去设计一种中间载体，而是在这个中间载体的语义范围之内去设计一门能提高生产力的分工度的语言。</p>
<p>  一言蔽之：“<strong>字节码不是但但为了java而设计的，字节码有着比java更强大的语义</strong>”。比如对于函数重载，但但是返回值不同在java语言中是不能判定为不同函数的，但是在class文件中则不然，class文件中只要一个类中方法的描述字段不相同，那么他们就是两个方法。虽然在具体语言上实现这一语义，这会带来新的运行时的麻烦。</p>
<h2 id="Class文件"><a href="#Class文件" class="headerlink" title="Class文件"></a>Class文件</h2><p>  <strong>Class文件对应着唯一一个类或接口的定义信息</strong>，注意这里有几个重点，首先是<strong>唯一一个</strong>，第二是<strong>类或接口</strong>，第三点是<strong>定义信息</strong></p>
<p>  Class文件，并不一定是指磁盘上的具体文件，它也许是动态生成的比如由CGlib生成，也可能是一个JSP文件生成，也有可能是一段网络流直接读取到内存里，但是不管它怎么样来，这段字节流都符合jvm规范里定义的类的结构，它的基础单位就是字节，各个项目数据严格按照规范排列在这段字节数据中，没有空隙存在，也没有分隔符存在，如果一个数据项不能以8位字节来表示，那么就用若干个字节，以高位在前方式来表示。</p>
<p>  从高级语言编译成字节码的那一刻开始，<strong>在Class文件中每一个数据项都有它存在的意义</strong>，当并非都是运行时必须的，因为<strong>类的属性表（后面会介绍）</strong>要求更为宽泛一些，存在一些如LineNumberTable,LocalVariableTable这样的属性是用来帮助我们编程和调试期间能够确定错误行行号，以及避免局部变量显示的名称是arg0,arg1这样没有意义的符号。<strong>这些运行期不必要的数据项都可通过编译时使用特别的参数来拒绝生成</strong>，但是我建议不要这么做，因为会导致别人很难复用和审查你的代码。</p>
<p>  Class文件格式并不是键值型的（属性表内属性除外），对数据的区分完全是看顺序和偏移。</p>
<h3 id="Class文件的组成"><a href="#Class文件的组成" class="headerlink" title="Class文件的组成"></a>Class文件的组成</h3><p>  要搞清楚什么组成了Class文件，首先要清楚的明白宽泛的讲，Class文件里只有两种数据类型：</p>
<ol>
<li><p>基本数据类型：<strong>无符号数</strong>，包括了u1,u2,u4,u8几种分别代表了<strong>不同字节数的无符号数</strong>，这些无符号数用来描述<strong>数字</strong>和<strong>索引引用</strong>,并且可以按照<strong>缩略UTF-8</strong>来表示字符串。这里缩略和普通的UTF-8编码的具体区别大家可以看卡wiki上这段话：</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">The Unicode strings, despite the moniker &quot;UTF-8 string&quot;, are not actually encoded according to the Unicode standard, although it is similar. There are two differences (see UTF-8 for a complete discussion). The first is that the codepoint U+0000 is encoded as the two-byte sequence C0 80 (in hex) instead of the standard single-byte encoding 00. The second difference is that supplementary characters (those outside the BMP at U+10000 and above) are encoded using a surrogate-pair construction similar to UTF-16 rather than being directly encoded using UTF-8. In this case each of the two surrogates is encoded separately in UTF-8. For example, U+1D11E is encoded as the 6-byte sequence ED A0 B4 ED B4 9E, rather than the correct 4-byte UTF-8 encoding of F0 9D 84 9E.</div></pre></td></tr></table></figure>
</code></pre></li>
<li><p>复合数据类型：<strong>表</strong>，“表”可由<strong>其他表</strong>和<strong>无符号数</strong>组成，你可以把Class文件整个看成一张大表，里面有无符号数和许多小表，小表里又有小表，这些表设计者都以”_info”为结尾来命名，但是这些名称并不会体现在class文件里面，这里再次声明一遍，class文件格式没有键（属性表内属性除外）这种东西，完全是靠偏移来确定这个字段是什么，以及某个字段在哪里。</p>
</li>
</ol>
<p>整个Class文件结构如下表顺序所示：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u4</td>
<td>magic</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>minor_version</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>major_version</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>constant_pool_count</td>
<td>1</td>
</tr>
<tr>
<td>cp_info</td>
<td>constant_pool</td>
<td>constant_pool_count-1</td>
</tr>
<tr>
<td>u2</td>
<td>assess_flags</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>this_class</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>super_class</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces_count</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces</td>
<td>interface_count</td>
</tr>
<tr>
<td>u2</td>
<td>fields_count</td>
<td>1</td>
</tr>
<tr>
<td>field_info</td>
<td>fields</td>
<td>fields_count</td>
</tr>
<tr>
<td>u2</td>
<td>methods_count</td>
<td>1</td>
</tr>
<tr>
<td>method_info</td>
<td>methods</td>
<td>methods_count</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attributes_count</td>
</tr>
</tbody>
</table>
<p>下面我们来拆解这张表，但是我们把比较特别的attribute部分，也就是最后两行另外以一篇新的文章来讲。</p>
<h4 id="magic-minor-major-version"><a href="#magic-minor-major-version" class="headerlink" title="magic,minor/major_version"></a>magic,minor/major_version</h4><p>class文件打头的6个字节就是<strong>魔术</strong>，<strong>次版本号</strong>以及<strong>主版本号</strong>。</p>
<p><strong>魔术固定为：0xCAFEBABY</strong>，这个字段唯一的目的就是类加载时验证阶段确定这个类是不是一个class类</p>
<p><strong>次版本号</strong>和<strong>主板本号</strong>确定这个class文件所支持最低的JDK版本,高版本的JDK能向下兼容，如果JVM检测到版本标识超过了自己支持的版本，就拒绝执行。</p>
<p>比如，你把一个JDK7编译的class文件放到基于JDK6的项目中运行，就可能得到unsupporter major.minor 51.0异常。</p>
<p>jdk7的版本号即51，jdk的版本号是从45开始（1.0和1.1都是45，小版本号不同），1.2开始每一个大版本号加1，jdk1.2是46,1.6是50，1.8是52。</p>
<h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>接下来常量池，由于每个类中的常量不是固定的，所以这部分数据由2个部分组成</p>
<ol>
<li><p>constant_pool_count，它是一个数值量，用来指定常量词中包含了多少个常量，但<strong>这个数值量不是从0开始计数的，这点需要特别注意，它从1开始计数，1表示没有任何常量，2表示有1个常量</strong>，然后依次后推，至于为什么不从0开始，因为后面的一些表中的引用字段，可能会存在不指向任何常量的情况，这时候就用0做为引用对于常量池的偏移。</p>
</li>
<li><p>即  constant_pool_count-1个cp_info，cp_info是常量项的表结构，它有14种类型（截止jdk1.7），每种类型的常量项的表结构都不同，但是这种表结构的开头都是一个u1类型的tag字段，来指定不同的数值标识这个表结构是哪种类型。</p>
<p>这14种类型你可以查看wiki：<a href="https://en.wikipedia.org/wiki/Java_class_file,里面的The" target="_blank" rel="external">https://en.wikipedia.org/wiki/Java_class_file,里面的The</a> constant pool项目就很清楚的说明了14种类型以及他们对应的tag的值。</p>
<p>比如对于其中的一种CONSTANT_Class_info表结构：</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u1</td>
<td>tag</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>name_index</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>   这里的tag的值肯定是0x07,标识它的类型为CONSTANT_Class_info，接下来name_index标识了一个索引值，该值指向的是一个常量词中的CONSTANT_Utf8_info结构，这个结构中有该类的全限定名字符串。现在我们来看看这种结构：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u1</td>
<td>tag</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>length</td>
<td>1</td>
</tr>
<tr>
<td>u1</td>
<td>bytes</td>
<td>length</td>
</tr>
</tbody>
</table>
<p>   对应于CONSTANT_Utf8_info的tag值为0x01,然后有一个16位数指定这个utf-8字符串所占的字节数，所以你可以推测一下你在java里直接以赋值形式构造一个所需空间大于64k的数是不可能的，接下来就是一个<strong>缩略utf-8编码</strong>所代表的字符串的字节流了，它的长度是上面给定的length。</p>
<h4 id="访问标志位"><a href="#访问标志位" class="headerlink" title="访问标志位"></a>访问标志位</h4><p>接下来一个u2类型的access_flags字段标识这个类的访问标志位，用来表示该类是不是被abstract等关键字修饰，是不是一个注解或者接口，是否是用户代码产生，是否是一个枚举类型等等，我们知道访问标志只有有和没有的区别，于是一个u2的每一位就代表了一种访问标志有还是没有，一个u2字段可以代表16种标志位，但是实际上只用了其中的8个。</p>
<p>你可以从<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4" target="_blank" rel="external">官方文档</a>，里的4.1小结查看这些标志位的具体信息，这个文档是Java se8的。</p>
<h4 id="this-class-super-class-interface索引集合"><a href="#this-class-super-class-interface索引集合" class="headerlink" title="this_class,super_class,interface索引集合"></a>this_class,super_class,interface索引集合</h4><table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u2</td>
<td>this_class</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>super_class</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces_count</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces</td>
<td>interface_count</td>
</tr>
</tbody>
</table>
<p>   ​    它们通通指向的一个常量词中类型为CONSTANT_Class_info的常量，我们上面介绍过这个常量的具体结构，它有一个name_index指向一个CONSTANT_Utf8_info常量，这个常量中包含了一段字符串，具体在这里这段字符串是完整的类名。诸如：java/lang/Object。</p>
<p>   ​    在java中除了Object外，所有的类都有父类，字节码中表现也是一样的。</p>
<h4 id="字段和方法表集合"><a href="#字段和方法表集合" class="headerlink" title="字段和方法表集合"></a>字段和方法表集合</h4><table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u2</td>
<td>field_count</td>
<td>1</td>
</tr>
<tr>
<td>field_info</td>
<td>fields</td>
<td>fields_count</td>
</tr>
<tr>
<td>u2</td>
<td>methods_count</td>
<td>1</td>
</tr>
<tr>
<td>method_info</td>
<td>methods</td>
<td>methods_count</td>
</tr>
</tbody>
</table>
<p>   字段表和方法表的结构每个字段的功能上几乎一样，<strong>但是实际上在access_flags的取值上是不同的，另外在属性表中它们也可能有不同的属性</strong>。表结构如下：</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">这里只列出了方法表其实字段表和它一模一样，只是位置一前一后，从而vm可以判断出谁是方法表，谁是字段表</div><div class="line">*/</div><div class="line">method_info &#123;</div><div class="line">    u2             access_flags;</div><div class="line">    u2             name_index;</div><div class="line">    u2             descriptor_index;</div><div class="line">    u2             attributes_count;</div><div class="line">    attribute_info attributes[attributes_count];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>   1.访问位：不再赘述，和类的访问位功能和形式上差不多，具体有哪些访问位可以参考<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4" target="_blank" rel="external">官方文档</a></p>
<p>   中4.5和4.6小结查看。</p>
<p>   2.name_index指向一个常量CONSTANT_Utf8_info，标识了方法或者字段名的<strong>简单名称</strong>，这里的简单名称指的是没有类型和参数修饰的名称，比如”inc()”-&gt;”inc”</p>
<p>   3.descriptor_index描述字段，这个字段有点复杂</p>
<p><strong>字段的描述：</strong></p>
<pre><code>首先对于除了long基本类型和void，都用首字符的大写来表示，比如void-&gt;V,int-&gt;I,double-&gt;D,long用J表示。
</code></pre><p>   ​    为什么long用J表示的原因是因为所有引用类型都用L作为开头表示，引用类型表示的方式为L+类型权限定名，比如对于java.lang.Object-&gt;Ljava/lang/Object</p>
<p>   ​    对于数组一个维度就在类型符号面前加一个[,比如对于int[]-&gt;[I,对于String[][]-&gt;[[Ljava/lang/String。</p>
<p><strong>方法的描述</strong></p>
<p>   ​    有了上面的基础，我们可以来介绍一下方法的descriptor_index字段，对于方法</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Object m(int i, double d, Thread t) &#123;...&#125;</div></pre></td></tr></table></figure>
<p>   编译器把它转换为一个描述为：</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(IDLjava/lang/Thread;)Ljava/lang/Object;</div></pre></td></tr></table></figure>
<p>   可以看到即使是在java中<strong>不能重载的同名同方法表不同返回值的方法</strong>实际上它们的描述符是不同的，实际上在class类中，这种<strong>不能重载的同名同方法表不同返回值的方法</strong>是可以存在的，但是运行期如何判断无接受值的方法调用到底调用的是什么方法呢?这是个巨大的问题。</p>
<p>   方法表和属性表中都不会列出从父类继承来的方法和字段，除非是自己在代码里重写了，但是会有你用javap去解析一个class文件时可能会发现没有在你代码里出现过的方法出现在了方法和字段表里，比如\<init>和\<clinit>方法，它们是实例的构造器和类的构造器，再比如对于内部类，我们可以访问外部类的字段和方法，编译器会直接给我们在内部类属性表插一个指向外部类实例的字段。</clinit></init></p>
<p>   <strong>就如我上面所说，对于类，方法和字段三种表中都存在的属性表，我在下篇文章介绍，这个表比较复杂，也能解开你包括，java里方法代码去哪儿了，被设为常量的类变量的赋值的值去哪儿了的疑问。</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  &lt;strong&gt;平台无关性&lt;/strong&gt;是Java语言最重要的特性之一，这个特性由&lt;strong&gt;字节码&lt;/strong&gt;这种中间码作为虚拟机执行的文件载体被大家所认识，&lt;strong&gt;一次编译到处运行&lt;/strong&gt;的这种&lt;strong&gt;平台无关性&lt;/strong&gt;在一个学习者在刚刚学习编程而且选择的是Java语言时就会了解，但是随着学习者技术视野不断扩张，就会意识到jvm不是提供了java运行的平台，而是提供了字节码运行的平台，像Scala，Groovy，Ruby，Python等等语言通过他们自己的编译器，也可以编译成字节码从而在jvm平台上运行，即&lt;strong&gt;语言无关性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;  一个非凡的公司去设计一款非凡的程序平台，Java在诞生之初，JVM和Java语言的规范就是分开来的，JVM只关心Class文件里的字节码，并不关心它是怎么来的，你甚至可以用16进制编辑器自己写一份字节码，前提你对它的结构非常的清楚，你也可自己设计一门语言，然后让这门语言编译成字节码，运行在jvm平台上，以作为你的毕业设计或者开源项目。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Junit(2):使用Hamcrest断言</title>
    <link href="http://yoursite.com/2017/10/29/Junit-2-Assert-by-Hamcrest/"/>
    <id>http://yoursite.com/2017/10/29/Junit-2-Assert-by-Hamcrest/</id>
    <published>2017-10-29T07:32:43.000Z</published>
    <updated>2017-10-31T08:51:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>  上一篇文章中，我们以几个简单的用例测试来开篇，以assertTure,assertEquals这样的简单形式来作断言，这些方法都是org.junit.Assert来提供，如果你用的是maven或者其他的项目构建工具来引入junit包，我们会发现，它居然依赖于一个org.hamcrest的项目包，实际上，如果涉及到比较复杂的断言，我们以junit需要写一大串代码，这让我们的测试代码非常不美观，这个叫做hamcrest提供了一套断言工具，而且该项目还有ruby等等语言的版本，他们返回一个org.hamcrest.Matcher的子类，另外在org.hamcrest.MatcherAssert中提供了一套assertThat方法，它接受一个org.hamcrest.Matcher和一个计算值，从而做出该值是否符合该Matcher的判断。</p>
<p>  在org.junit.Assert类中也有assertThat方法，不过它其实就是包装了一下MatcherAssert中的assertThat。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">assertThat</span><span class="params">(String reason, T actual,</span></span></div><div class="line">        Matcher&lt;? <span class="keyword">super</span> T&gt; matcher) &#123;</div><div class="line">    MatcherAssert.assertThat(reason, actual, matcher);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="常用的比较"><a href="#常用的比较" class="headerlink" title="常用的比较"></a>常用的比较</h2><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><h4 id="anything"><a href="#anything" class="headerlink" title="anything"></a>anything</h4><p>anything会返回一个匹配任意值（包括null）的matchers，如果一个值可以是任何预期，你可以用anything来做断言</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anythingMatchersTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    Calculate calculate = <span class="keyword">new</span> Calculate();</div><div class="line">    assertThat(calculate, anything());</div><div class="line">    assertThat(<span class="keyword">null</span>, anything(<span class="string">"hello world"</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="is"><a href="#is" class="headerlink" title="is"></a>is</h4><p>is匹配两个值是否相等（equals），经常做equalsTo的简写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isMatchersTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    assertThat(<span class="string">"hello world"</span>, is(<span class="string">"hello world"</span>));</div><div class="line">    assertThat(<span class="keyword">new</span> String[] &#123;<span class="string">"floor"</span>, <span class="string">"bank"</span>&#125;, is(<span class="keyword">new</span> String[] &#123;<span class="string">"floor"</span>, <span class="string">"bank"</span>&#125;));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>####describedsAs</p>
<p>包装一个Matchers，其中的三个参数：</p>
<p>description:作为包装后的Matchers的失败描述</p>
<p>matcher:要包装的matchers</p>
<p>valus:选择性插入值,它会被插入到description标识的数字占位符处，该参数不允许为null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; org.hamcrest.<span class="function">Matcher&lt;T&gt; <span class="title">describedAs</span><span class="params">(java.lang.String description, org.hamcrest.Matcher&lt;T&gt; matcher, java.lang.Object... values)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> org.hamcrest.core.DescribedAs.&lt;T&gt;describedAs(description, matcher, values);</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>比如如下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">describedsAsMatchersTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    Calculate calculate = <span class="keyword">new</span> Calculate();</div><div class="line">    Calculate calculate1 = <span class="keyword">new</span> Calculate();</div><div class="line">    assertThat(calculate1, describedAs(<span class="string">"hello world %0,%1"</span>,is(calculate),<span class="keyword">new</span> String[]&#123;<span class="string">"saul"</span>,<span class="string">"xin"</span>&#125;));</div><div class="line">    <span class="comment">//当然你也可以这样传入多值参数</span></div><div class="line">    <span class="comment">//assertThat(calculate1, describedAs("hello world %0,%1",is(calculate),"saul","xin");</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试：</p>
<p><img src="\img\QQ图片20171029180301.png" alt="QQ图片20171029180301"></p>
<h3 id="逻辑比较"><a href="#逻辑比较" class="headerlink" title="逻辑比较"></a>逻辑比较</h3><h4 id="allOf"><a href="#allOf" class="headerlink" title="allOf"></a>allOf</h4><p><img src="\img\QQ图片20171029221453.png" alt="QQ图片20171029221453"></p>
<p>allOf在hamcrest相当于与操作，如下对于”hello world”验证它是否同时符合以下两个Matchers，显然是符合的，allOf有多个重写，接受的参数是一个可变的Matchers列表，或者一个Matchers的迭代器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">allOfTest</span><span class="params">()</span></span>&#123;</div><div class="line">    assertThat(<span class="string">"hello world"</span>,allOf(endsWith(<span class="string">"ld"</span>),startsWith(<span class="string">"hello"</span>)));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="anyOf"><a href="#anyOf" class="headerlink" title="anyOf"></a>anyOf</h4><p>anyOf和allOf类似，相当于或操作，既然类似当然它们的参数表也是类似了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anyOfTest</span><span class="params">()</span></span>&#123;</div><div class="line">    assertThat(<span class="string">"hello world"</span>,anyOf(endsWith(<span class="string">"mld"</span>),startsWith(<span class="string">"hello"</span>)));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="not"><a href="#not" class="headerlink" title="not"></a>not</h4><p>not表否定，可以接受一个Matchers或者一个值，返回一个Matchers，表示非逻辑，如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notTest</span><span class="params">()</span></span>&#123;</div><div class="line">    assertThat(<span class="string">"hello world"</span>,not(<span class="string">"Hello world"</span>));</div><div class="line">    assertThat(<span class="string">"hello world"</span>,not(allOf(endsWith(<span class="string">"mld"</span>),startsWith(<span class="string">"hello"</span>))));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="equalTo"><a href="#equalTo" class="headerlink" title="equalTo"></a>equalTo</h4><p>检测两个值是否相等，equals判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">equalToTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    String k=<span class="string">"hello world"</span>;</div><div class="line">    String s=<span class="keyword">new</span> String(<span class="string">"hello world"</span>);</div><div class="line">    assertThat(k,equalTo(s));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="hasToString"><a href="#hasToString" class="headerlink" title="hasToString"></a>hasToString</h4><p>测试某个对象的toString方法的返回值是否符合某个Matchers或等于某个值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hasToStringTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    assertThat(<span class="keyword">new</span> Integer(<span class="number">1</span>), hasToString(<span class="string">"1"</span>));</div><div class="line">    assertThat(<span class="keyword">new</span> Integer(<span class="number">1</span>), hasToString(endsWith(<span class="string">"1"</span>)));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="instanceOf"><a href="#instanceOf" class="headerlink" title="instanceOf"></a>instanceOf</h4><p>判断某个对象是否是某种类型的实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">instanceOfTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    assertThat(<span class="keyword">new</span> Integer(<span class="number">1</span>), instanceOf(Number.class));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="isCompatibleType"><a href="#isCompatibleType" class="headerlink" title="isCompatibleType"></a>isCompatibleType</h4><p>测试一个类是否是可兼容另一个类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isCompatibleTypeTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    assertThat(Integer.class, typeCompatibleWith(Number.class));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="notNullValue"><a href="#notNullValue" class="headerlink" title="notNullValue"></a>notNullValue</h4><p>检测一个值是否不为null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notNullValueTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    assertThat(<span class="keyword">null</span>, not(notNullValue()));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="nullValue"><a href="#nullValue" class="headerlink" title="nullValue"></a>nullValue</h4><p>检测一个值是否为null</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nullValueTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    assertThat(<span class="keyword">null</span>, nullValue());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="sameInstance"><a href="#sameInstance" class="headerlink" title="sameInstance"></a>sameInstance</h4><p>检测两个对象是否相同,==判断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sameInstanceTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    String k=<span class="string">"hello"</span>;</div><div class="line">    String s=<span class="string">"hello"</span>;</div><div class="line">    assertThat(s,sameInstance(k));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="hasProperty"><a href="#hasProperty" class="headerlink" title="hasProperty"></a>hasProperty</h4><p>判断一个Bean对象是否有某个属性，这个Matchers会使用get方法来判断，没有get方法就是没有该属性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hasPropertyTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    User user = <span class="keyword">new</span> User();</div><div class="line">    assertThat(user, hasProperty(<span class="string">"name"</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><h4 id="array"><a href="#array" class="headerlink" title="array"></a>array</h4><p>生成一个Machers，其包含一组Machers，接着对一个数组进行遍历匹配，每个元素匹配他们的对应位置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">arrayTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    String ls[] = &#123;<span class="string">"hello"</span>, <span class="string">"world"</span>, <span class="string">"love"</span>, <span class="string">"bcd"</span>&#125;;</div><div class="line">    assertThat(ls, array(startsWith(<span class="string">"hel"</span>), startsWith(<span class="string">"wor"</span>), startsWith(<span class="string">"lo"</span>), endsWith(<span class="string">"d"</span>)));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="hasEntry-hasKey-hasValue"><a href="#hasEntry-hasKey-hasValue" class="headerlink" title="hasEntry,hasKey,hasValue"></a>hasEntry,hasKey,hasValue</h4><p>返回一个Matchers，匹配键值对</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MapTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</div><div class="line">    map.put(<span class="string">"name"</span>, <span class="string">"tom"</span>);</div><div class="line">    assertThat(map, hasEntry(<span class="string">"name"</span>, <span class="string">"tom"</span>));</div><div class="line">    assertThat(map, hasEntry(startsWith(<span class="string">"nam"</span>), endsWith(<span class="string">"om"</span>)));</div><div class="line">    assertThat(map, hasKey(<span class="string">"name"</span>));</div><div class="line">    assertThat(map, hasValue(endsWith(<span class="string">"om"</span>)));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="hasItem-hasItems-hasItemInArray"><a href="#hasItem-hasItems-hasItemInArray" class="headerlink" title="hasItem,hasItems,hasItemInArray"></a>hasItem,hasItems,hasItemInArray</h4><p>返回一个Mathers，对集合中的每一个元素进行匹配，要求至少有一个元素满足给定条件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ItemTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</div><div class="line">    set.add(<span class="string">"some"</span>);</div><div class="line">    set.add(<span class="string">"one"</span>);</div><div class="line">    set.add(<span class="string">"in here"</span>);</div><div class="line">    assertThat(set, hasItem(startsWith(<span class="string">"some"</span>)));</div><div class="line">    assertThat(set, hasItems(anyOf(startsWith(<span class="string">"can"</span>), endsWith(<span class="string">"here"</span>))));</div><div class="line">    assertThat(set.toArray(<span class="keyword">new</span> String[]&#123;&#125;), hasItemInArray(startsWith(<span class="string">"so"</span>)));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h3><h4 id="近似值匹配"><a href="#近似值匹配" class="headerlink" title="近似值匹配"></a>近似值匹配</h4><p> 匹配某个值是否在误差允许的范围内接近一个精确值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeToTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    assertThat(<span class="number">5.3</span>, closeTo(<span class="number">5</span>, <span class="number">0.3</span>));</div><div class="line">    BigDecimal bigDecimal = <span class="keyword">new</span> BigDecimal(<span class="string">"99999999999999999999999999999999999999"</span>);</div><div class="line">    BigDecimal error = <span class="keyword">new</span> BigDecimal(<span class="number">0.001</span>);</div><div class="line">    assertThat(<span class="keyword">new</span> BigDecimal(<span class="string">"99999999999999999999999999999999999999.0009"</span>), closeTo(bigDecimal, error));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="大小匹配"><a href="#大小匹配" class="headerlink" title="大小匹配"></a>大小匹配</h4><p> 返回一个Matchers做值的大小匹配</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">compareToTest</span><span class="params">()</span> </span>&#123;</div><div class="line">    assertThat(<span class="number">5</span>, greaterThan(<span class="number">4</span>));</div><div class="line">    assertThat(<span class="number">5</span>, lessThan(<span class="number">6</span>));</div><div class="line">    assertThat(<span class="number">5</span>, greaterThanOrEqualTo(<span class="number">5</span>));</div><div class="line">    assertThat(<span class="number">4</span>, lessThanOrEqualTo(<span class="number">4</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stringTest</span><span class="params">()</span></span>&#123;</div><div class="line">    assertThat(<span class="string">"jay"</span>,equalTo(<span class="string">"jay"</span>));</div><div class="line">    assertThat(<span class="string">"hello"</span>,equalToIgnoringCase(<span class="string">"HelLO"</span>));</div><div class="line">    <span class="comment">//忽略头尾所有空白字符和空字符，且非头尾空白字符，空字符都认为是1个空白字符进行匹配</span></div><div class="line">    <span class="comment">//"helloworld"匹配"  helloworld"和"helloworld  "，但是不匹配"hello world"，因为非头尾空白字符总被认为是一个需要匹配的空字符或空白字符</span></div><div class="line">    assertThat(<span class="string">"hello  wor\nld"</span>,equalToIgnoringWhiteSpace(<span class="string">"  \t\bhello wor  ld    "</span>));</div><div class="line">    assertThat(<span class="string">"hello"</span>,startsWith(<span class="string">"hel"</span>));</div><div class="line">    assertThat(<span class="string">"name"</span>,endsWith(<span class="string">"me"</span>));</div><div class="line">    assertThat(<span class="string">"hello world!"</span>,containsString(<span class="string">"!"</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  上一篇文章中，我们以几个简单的用例测试来开篇，以assertTure,assertEquals这样的简单形式来作断言，这些方法都是org.junit.Assert来提供，如果你用的是maven或者其他的项目构建工具来引入junit包，我们会发现，它居然依赖于一个org.hamcrest的项目包，实际上，如果涉及到比较复杂的断言，我们以junit需要写一大串代码，这让我们的测试代码非常不美观，这个叫做hamcrest提供了一套断言工具，而且该项目还有ruby等等语言的版本，他们返回一个org.hamcrest.Matcher的子类，另外在org.hamcrest.MatcherAssert中提供了一套assertThat方法，它接受一个org.hamcrest.Matcher和一个计算值，从而做出该值是否符合该Matcher的判断。&lt;/p&gt;
&lt;p&gt;  在org.junit.Assert类中也有assertThat方法，不过它其实就是包装了一下MatcherAssert中的assertThat。如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;assertThat&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String reason, T actual,&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        Matcher&amp;lt;? &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt; T&amp;gt; matcher) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    MatcherAssert.assertThat(reason, actual, matcher);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="软件测试" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
      <category term="TDD" scheme="http://yoursite.com/tags/TDD/"/>
    
      <category term="Junit" scheme="http://yoursite.com/tags/Junit/"/>
    
  </entry>
  
</feed>
