<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog of Saul</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-20T10:47:26.539Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Saul</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Typescript(7): Decorators</title>
    <link href="http://yoursite.com/2019/03/18/Typescript-7-Decorators/"/>
    <id>http://yoursite.com/2019/03/18/Typescript-7-Decorators/</id>
    <published>2019-03-18T09:22:56.000Z</published>
    <updated>2019-03-20T10:47:26.539Z</updated>
    
    <content type="html"><![CDATA[<p>装饰器是一种我们能够在类的声明和成员上通过元编程语法添加标注的方式，不过不管在ts（3.1）和还是在js中它都是处于试验阶段的。</p>
<p>如果要启用实验性的装饰器特性，我们需要在命令行或者tsconfig.json里启用experimentalDecorators编译器选项。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//命令行中加入编译选项参数</span></div><div class="line">tsc --target ES5 --experimentalDecorators</div><div class="line"></div><div class="line"><span class="comment">//tsconfig.json</span></div><div class="line">&#123;</div><div class="line">    <span class="string">"compilerOptions"</span>: &#123;</div><div class="line">        <span class="string">"target"</span>: <span class="string">"ES5"</span>,</div><div class="line">        <span class="string">"experimentalDecorators"</span>: <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>作为一种特殊的类型声明，装饰器能被附加到<strong>类声明，方法，访问符，属性或者参数</strong>上。装饰器不能用在声明文件中（.d.ts），或者任何外部上下文（比如 <code>declare</code>的类）里。</p>
<p>装饰器通过<strong>@expression</strong>来使用，<strong>expression</strong>求值后必须是一个函数，注意这里的expression指的是表达式，不是一个placeholder或者是单纯的指一个变量名。</p>
<p><code>function identity(args){ return args;}</code></p>
<p>上面是一个函数定义，表达式<code>identity</code>返回一个函数，所以@identity是表示使用装饰器，至于装饰器产生什么样的效果，得看你在哪里使用它(准确来说是被装饰的声明信息是什么)。</p>
<p>现在我们来简单描述装饰器：</p>
<p><strong>本质上装饰器就是一个函数，装饰器用来修饰声明信息，在运行时(js执行机中的编译阶段)以被修饰的声明信息作为参数，然后执行！</strong></p>
<p>比如下面这样定义和使用一个装饰器，以下是一个类装饰器：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">decoration</span>(<span class="params">constructor</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'I am a decoration'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@decoration</span></div><div class="line"><span class="keyword">class</span> Clazz &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译后：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// __decorate方法的定义</span></div><div class="line"><span class="keyword">var</span> __decorate = (<span class="keyword">this</span> &amp;&amp; <span class="keyword">this</span>.__decorate) || <span class="function"><span class="keyword">function</span> (<span class="params">decorators, target, key, desc</span>) </span>&#123;</div><div class="line">   <span class="comment">//先看看传入的参数列表长度，在下面的调用中显然只传入了两个参数，即decorators和target， key, desc两个参数在装饰方法时可能会被用到</span></div><div class="line">   <span class="keyword">var</span> c = <span class="built_in">arguments</span>.length, r = c &lt; <span class="number">3</span> ? target : desc === <span class="literal">null</span> ? desc = <span class="built_in">Object</span>.getOwnPropertyDescriptor(target, key) : desc, d;</div><div class="line">   <span class="comment">//看看运行环境是不是支持反射的调用，如果支持直接就反射了</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> Reflect === <span class="string">"object"</span> &amp;&amp; <span class="keyword">typeof</span> Reflect.decorate === <span class="string">"function"</span>) r = Reflect.decorate(decorators, target, key, desc);</div><div class="line">   <span class="comment">//不支持反射的话我们只有利用自己定义的代码来处理了，处理规则相当的简单</span></div><div class="line">     <span class="keyword">else</span>&#123;</div><div class="line">     <span class="comment">//循环的执行每个装饰器，这里是声明顺序的倒序</span></div><div class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = decorators.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</div><div class="line">        <span class="keyword">if</span> (d = decorators[i]) &#123;</div><div class="line">        <span class="comment">//如果参数个数小于3的话直接就将target传入装饰器，然后用上一层装饰器再次包装上次的装饰器，直到结束</span></div><div class="line">          r = (c &lt; <span class="number">3</span> ? d(r) : c &gt; <span class="number">3</span> ? d(target, key, r) : d(target, key)) || r;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> c &gt; <span class="number">3</span> &amp;&amp; r &amp;&amp; <span class="built_in">Object</span>.defineProperty(target, key, r), r;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">decoration</span>(<span class="params">constructor</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'I am a decoration'</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> Clazz = <span class="comment">/** @class */</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Clazz</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 利用__decorate方法来生成类型</span></div><div class="line">    <span class="comment">// 传入的参数有两个，装饰器数组，以及一个类的构造函数</span></div><div class="line">    Clazz = __decorate([</div><div class="line">        decoration</div><div class="line">    ], Clazz);</div><div class="line">    <span class="keyword">return</span> Clazz;</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<h3 id="装饰器组合"><a href="#装饰器组合" class="headerlink" title="装饰器组合"></a>装饰器组合</h3><p>多个装饰器可以同时应用于一个声明，它们的求值方式类似于复合函数，当复合<em>f</em>和<em>g</em>时，复合的结果(<em>f</em> ∘ <em>g</em>)(<em>x</em>)等同于<em>f</em>(<em>g</em>(<em>x</em>))。</p>
<p>同样的，在TypeScript里，当多个装饰器应用在一个声明上时会进行如下步骤的操作：</p>
<ol>
<li>由上至下依次对<strong>装饰器表达式</strong>求值。</li>
<li>第一步求得的值，从后往前调用。</li>
</ol>
<h3 id="装饰器类型"><a href="#装饰器类型" class="headerlink" title="装饰器类型"></a>装饰器类型</h3><h4 id="装饰器执行顺序"><a href="#装饰器执行顺序" class="headerlink" title="装饰器执行顺序"></a>装饰器执行顺序</h4><ol>
<li><em>参数装饰器</em>，然后依次是<em>方法装饰器</em>，<em>访问符装饰器</em>，或<em>属性装饰器</em>应用到每个<strong>实例成员</strong>。</li>
<li><em>参数装饰器</em>，然后依次是<em>方法装饰器</em>，<em>访问符装饰器</em>，或<em>属性装饰器</em>应用到每个<strong>静态成员</strong>。</li>
<li><em>参数装饰器</em>应用到<strong>构造函数</strong>。</li>
<li><em>类装饰器</em>应用到<strong>类</strong>。</li>
</ol>
<h4 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h4><p>类装饰器主要用作<strong>监视，修改，替换</strong>类定义。</p>
<p>类装饰器会把类的构造函数当做唯一的参数来调用，如果装饰器返回了一个值，这个值会使用提供的构造函数来取代类声明定义。</p>
<p>下面这个例子我们修改了Person的构造器，为它增加了一个属性skill，值为coding。addSkillProperty是一个装饰器工厂，一般情况下我们利用装饰器工厂传入的参数来使得我们的装饰器更加灵活的被创建。现在，如果我们要创造skill值不同的装饰器，我们只需要调用装饰器工厂addSkillProperty就可以了。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">    function addSkillProperty(skill: string) &#123;</div><div class="line">        return function (constructor: Function) &#123;</div><div class="line">            constructor.prototype.skill = 'coding';</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">// 表达式addSkillProperty("coding")返回了一个函数</div><div class="line">    @addSkillProperty("coding")</div><div class="line">    class Person &#123;</div><div class="line">        name: string;</div><div class="line">        age: number;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    let person: any = new Person();</div><div class="line"></div><div class="line">//output: coding</div><div class="line">    console.log(person.skill);</div></pre></td></tr></table></figure>
<h4 id="方法装饰器"><a href="#方法装饰器" class="headerlink" title="方法装饰器"></a>方法装饰器</h4><p>用来<strong>监视，修改或者替换</strong>方法定义。</p>
<p>方法装饰器接收下列三个参数：</p>
<ol>
<li>对于<strong>静态成员来说是类的构造函数</strong>，对于实例成员是<strong>类的原型对象</strong>。</li>
<li>成员的名字。</li>
<li>成员的<em>属性描述符</em>（{value: any, writable: boolean, enumerable: boolean, configurable: boolean}）。(如果代码输出目标版本小于<code>ES5</code>，<em>属性描述符</em>将会是<code>undefined</code>)</li>
</ol>
<p>如果方法装饰器返回一个值，它会被用作方法的<em>属性描述符</em>。(如果代码输出目标版本小于<code>ES5</code>返回值会被忽略)</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addSkillProperty</span>(<span class="params">skill: <span class="built_in">string</span></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">constructor: <span class="built_in">Function</span></span>) </span>&#123;</div><div class="line">            <span class="keyword">constructor</span>.prototype.skill = 'coding';</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    function methodDecorator(<span class="params"></span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(target); <span class="comment">//对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</span></div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"prop "</span> + propertyKey); <span class="comment">//成员的名字。</span></div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"desc "</span> + <span class="built_in">JSON</span>.stringify(descriptor) + <span class="string">"\n\n"</span>); <span class="comment">//成员的属性描述符</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@addSkillProperty</span>(<span class="string">"coding"</span>)</div><div class="line">    <span class="keyword">class</span> Person &#123;</div><div class="line">        name: <span class="built_in">string</span>;</div><div class="line">        age: <span class="built_in">number</span>;</div><div class="line"></div><div class="line">        <span class="meta">@methodDecorator</span>()</div><div class="line">        selfInstroduce(greetings : <span class="built_in">string</span>)&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;greetings&#125;</span> ,I am <span class="subst">$&#123;this.name&#125;</span> , <span class="subst">$&#123;this.age&#125;</span> years old. I can <span class="subst">$&#123;(&lt;any&gt;this).skill&#125;</span>`</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> person: <span class="built_in">any</span> = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(person.skill);</div><div class="line"><span class="comment">// hello ,I am undefined , undefined years old. I can coding</span></div><div class="line">    person.selfInstroduce(<span class="string">"hello"</span>);</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">Person &#123; selfInstroduce: [Function] &#125;</div><div class="line">prop selfInstroduce</div><div class="line">desc &#123;"writable":true,"enumerable":true,"configurable":true&#125;</div><div class="line">*/</div></pre></td></tr></table></figure>
<h4 id="访问装饰器"><a href="#访问装饰器" class="headerlink" title="访问装饰器"></a>访问装饰器</h4><p>访问器装饰器应用于访问器的 <em>属性描述符</em>并且可以用来<strong>监视，修改或替换</strong>一个访问器的定义</p>
<p>访问器装饰器表达式会在运行时当作函数被调用，传入下列3个参数：</p>
<ol>
<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li>
<li>成员的名字。</li>
<li>成员的<em>属性描述符</em>（{“enumerable”:true,”configurable”:true}）。</li>
</ol>
<p>TypeScript不允许同时装饰一个成员的<code>get</code>和<code>set</code>访问器。取而代之的是，一个成员的所有装饰的必须应用在文档顺序的第一个访问器上。这是因为，在装饰器应用于一个<em>属性描述符</em>时，它联合了<code>get</code>和<code>set</code>访问器，而不是分开声明的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addSkillProperty</span>(<span class="params">skill: <span class="built_in">string</span></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">constructor: <span class="built_in">Function</span></span>) </span>&#123;</div><div class="line">            <span class="keyword">constructor</span>.prototype.skill = 'coding';</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    function methodDecorator(<span class="params"></span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(target); <span class="comment">//对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</span></div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"prop "</span> + propertyKey); <span class="comment">//成员的名字。</span></div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"desc "</span> + <span class="built_in">JSON</span>.stringify(descriptor) + <span class="string">"\n\n"</span>); <span class="comment">//成员的属性描述符</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getDecorator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(target); <span class="comment">//对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</span></div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"prop "</span> + propertyKey); <span class="comment">//成员的名字。</span></div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"desc "</span> + <span class="built_in">JSON</span>.stringify(descriptor) + <span class="string">"\n\n"</span>); <span class="comment">//成员的属性描述符</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@addSkillProperty</span>(<span class="string">"coding"</span>)</div><div class="line">    <span class="keyword">class</span> Person &#123;</div><div class="line">        name: <span class="built_in">string</span>;</div><div class="line">        age: <span class="built_in">number</span>;</div><div class="line"></div><div class="line">        <span class="meta">@methodDecorator</span>()</div><div class="line">        selfInstroduce(greetings : <span class="built_in">string</span>)&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;greetings&#125;</span> ,I am <span class="subst">$&#123;this.name&#125;</span> , <span class="subst">$&#123;this.age&#125;</span> years old. I can <span class="subst">$&#123;(&lt;any&gt;this).skill&#125;</span>`</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@getDecorator</span>()</div><div class="line">        <span class="keyword">get</span> getName()&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> person: <span class="built_in">any</span> = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(person.skill);</div><div class="line"></div><div class="line">    person.selfInstroduce(<span class="string">"hello"</span>);</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">Person &#123; selfInstroduce: [Function], getName: [Getter] &#125;</div><div class="line">prop selfInstroduce</div><div class="line">desc &#123;"writable":true,"enumerable":true,"configurable":true&#125;</div><div class="line"></div><div class="line"></div><div class="line">Person &#123; selfInstroduce: [Function], getName: [Getter] &#125;</div><div class="line">prop getName</div><div class="line">desc &#123;"enumerable":true,"configurable":true&#125;</div><div class="line"></div><div class="line"></div><div class="line">coding</div><div class="line">hello ,I am undefined , undefined years old. I can coding</div><div class="line">*/</div></pre></td></tr></table></figure>
<h4 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h4><p>属性装饰器表达式会在运行时当作函数被调用，传入下列2个参数：</p>
<ol>
<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li>
<li>成员的名字。</li>
</ol>
<p>因为目前没有办法在定义一个原型对象的成员时描述一个实例属性，并且没办法监视或修改一个属性的初始化方法。返回值也会被忽略。因此，属性描述符只能用来监视类中是否声明了某个名字的属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></td><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addSkillProperty</span>(<span class="params">skill: <span class="built_in">string</span></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">constructor: <span class="built_in">Function</span></span>) </span>&#123;</div><div class="line">            <span class="keyword">constructor</span>.prototype.skill = 'coding';</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    function methodDecorator(<span class="params"></span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(target); <span class="comment">//对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</span></div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"prop "</span> + propertyKey); <span class="comment">//成员的名字。</span></div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"desc "</span> + <span class="built_in">JSON</span>.stringify(descriptor) + <span class="string">"\n\n"</span>); <span class="comment">//成员的属性描述符</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getDecorator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(target); <span class="comment">//对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</span></div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"prop "</span> + propertyKey); <span class="comment">//成员的名字。</span></div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"desc "</span> + <span class="built_in">JSON</span>.stringify(descriptor) + <span class="string">"\n\n"</span>); <span class="comment">//成员的属性描述符</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">propertyDecorator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span> </span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(target); <span class="comment">//对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</span></div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"prop "</span> + propertyKey); <span class="comment">//成员的名字。</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@addSkillProperty</span>(<span class="string">"coding"</span>)</div><div class="line">    <span class="keyword">class</span> Person &#123;</div><div class="line"></div><div class="line">        <span class="meta">@propertyDecorator</span>()</div><div class="line">        name: <span class="built_in">string</span>;</div><div class="line">        age: <span class="built_in">number</span>;</div><div class="line"></div><div class="line">        <span class="meta">@methodDecorator</span>()</div><div class="line">        selfInstroduce(greetings : <span class="built_in">string</span>)&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;greetings&#125;</span> ,I am <span class="subst">$&#123;this.name&#125;</span> , <span class="subst">$&#123;this.age&#125;</span> years old. I can <span class="subst">$&#123;(&lt;any&gt;this).skill&#125;</span>`</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@getDecorator</span>()</div><div class="line">        <span class="keyword">get</span> getName()&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> person: <span class="built_in">any</span> = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(person.skill);</div><div class="line"></div><div class="line">    person.selfInstroduce(<span class="string">"hello"</span>);</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">Person &#123; selfInstroduce: [Function], getName: [Getter] &#125;</div><div class="line">prop name</div><div class="line">Person &#123; selfInstroduce: [Function], getName: [Getter] &#125;</div><div class="line">prop selfInstroduce</div><div class="line">desc &#123;"writable":true,"enumerable":true,"configurable":true&#125;</div><div class="line"></div><div class="line"></div><div class="line">Person &#123; selfInstroduce: [Function], getName: [Getter] &#125;</div><div class="line">prop getName</div><div class="line">desc &#123;"enumerable":true,"configurable":true&#125;</div><div class="line"></div><div class="line"></div><div class="line">coding</div><div class="line">hello ,I am undefined , undefined years old. I can coding</div><div class="line">*/</div></pre></td></tr></table></figure>
<h4 id="参数装饰器"><a href="#参数装饰器" class="headerlink" title="参数装饰器"></a>参数装饰器</h4><p>参数装饰器<strong>只能用来监视一个方法的参数是否被传入</strong>。</p>
<p>参数装饰器表达式会在运行时当作函数被调用，传入下列3个参数：</p>
<ol>
<li>对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</li>
<li>成员的名字。</li>
<li>参数在函数参数列表中的索引。</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">addSkillProperty</span>(<span class="params">skill: <span class="built_in">string</span></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">constructor: <span class="built_in">Function</span></span>) </span>&#123;</div><div class="line">            <span class="keyword">constructor</span>.prototype.skill = 'coding';</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    function methodDecorator(<span class="params"></span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(target); <span class="comment">//对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</span></div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"prop "</span> + propertyKey); <span class="comment">//成员的名字。</span></div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"desc "</span> + <span class="built_in">JSON</span>.stringify(descriptor) + <span class="string">"\n\n"</span>); <span class="comment">//成员的属性描述符</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getDecorator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span>, descriptor: PropertyDescriptor</span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(target); <span class="comment">//对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</span></div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"prop "</span> + propertyKey); <span class="comment">//成员的名字。</span></div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"desc "</span> + <span class="built_in">JSON</span>.stringify(descriptor) + <span class="string">"\n\n"</span>); <span class="comment">//成员的属性描述符</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">propertyDecorator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span> </span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(target); <span class="comment">//对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</span></div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"prop "</span> + propertyKey); <span class="comment">//成员的名字。</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">argumentsDecorator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">target: <span class="built_in">any</span>, propertyKey: <span class="built_in">string</span>, argumentIndex: <span class="built_in">number</span></span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(target); <span class="comment">//对于静态成员来说是类的构造函数，对于实例成员是类的原型对象。</span></div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"prop "</span> + propertyKey); <span class="comment">//成员的名字。</span></div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"argument index "</span> + argumentIndex); <span class="comment">//参数在方法参数列表中的索引</span></div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@addSkillProperty</span>(<span class="string">"coding"</span>)</div><div class="line">    <span class="keyword">class</span> Person &#123;</div><div class="line"></div><div class="line">        <span class="meta">@propertyDecorator</span>()</div><div class="line">        name: <span class="built_in">string</span>;</div><div class="line">        age: <span class="built_in">number</span>;</div><div class="line"></div><div class="line">        <span class="meta">@methodDecorator</span>()</div><div class="line">        selfInstroduce(<span class="meta">@argumentsDecorator</span>() greetings : <span class="built_in">string</span>)&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;greetings&#125;</span> ,I am <span class="subst">$&#123;this.name&#125;</span> , <span class="subst">$&#123;this.age&#125;</span> years old. I can <span class="subst">$&#123;(&lt;any&gt;this).skill&#125;</span>`</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@getDecorator</span>()</div><div class="line">        <span class="keyword">get</span> getName()&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> person: <span class="built_in">any</span> = <span class="keyword">new</span> Person();</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(person.skill);</div><div class="line"></div><div class="line">    person.selfInstroduce(<span class="string">"hello"</span>);</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"></div><div class="line">Person &#123; selfInstroduce: [Function], getName: [Getter] &#125;</div><div class="line">prop name</div><div class="line">Person &#123; selfInstroduce: [Function], getName: [Getter] &#125;</div><div class="line">prop selfInstroduce</div><div class="line">argument index 0</div><div class="line">Person &#123; selfInstroduce: [Function], getName: [Getter] &#125;</div><div class="line">prop selfInstroduce</div><div class="line">desc &#123;"writable":true,"enumerable":true,"configurable":true&#125;</div><div class="line"></div><div class="line"></div><div class="line">Person &#123; selfInstroduce: [Function], getName: [Getter] &#125;</div><div class="line">prop getName</div><div class="line">desc &#123;"enumerable":true,"configurable":true&#125;</div><div class="line"></div><div class="line"></div><div class="line">coding</div><div class="line">hello ,I am undefined , undefined years old. I can coding</div><div class="line">*/</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;装饰器是一种我们能够在类的声明和成员上通过元编程语法添加标注的方式，不过不管在ts（3.1）和还是在js中它都是处于试验阶段的。&lt;/p&gt;
&lt;p&gt;如果要启用实验性的装饰器特性，我们需要在命令行或者tsconfig.json里启用experimentalDecorators编译
    
    </summary>
    
    
      <category term="typescript" scheme="http://yoursite.com/tags/typescript/"/>
    
      <category term="notes" scheme="http://yoursite.com/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>Typescript(6):advenced type II</title>
    <link href="http://yoursite.com/2019/03/16/Typescript-6-advenced-type-II/"/>
    <id>http://yoursite.com/2019/03/16/Typescript-6-advenced-type-II/</id>
    <published>2019-03-16T03:17:38.000Z</published>
    <updated>2019-03-18T01:52:37.701Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多态this类型"><a href="#多态this类型" class="headerlink" title="多态this类型"></a>多态this类型</h2><p>  考虑到链式编程，很多连贯性操作中我们都会返回this，ts中允许把this作为返回值类型已到达继承之后依然能用基类的方法达到链式调用的目的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> BasicCalculator &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params"><span class="keyword">protected</span> value: <span class="built_in">number</span> = 0</span>) &#123; &#125;</div><div class="line">    <span class="keyword">public</span> currentValue(): <span class="built_in">number</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> add(operand: <span class="built_in">number</span>): <span class="keyword">this</span> &#123;</div><div class="line">        <span class="keyword">this</span>.value += operand;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> multiply(operand: <span class="built_in">number</span>): <span class="keyword">this</span> &#123;</div><div class="line">        <span class="keyword">this</span>.value *= operand;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// ... other operations go here ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> ScientificCalculator <span class="keyword">extends</span> BasicCalculator &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">constructor</span>(<span class="params">value = 0</span>) &#123;</div><div class="line">        <span class="keyword">super</span>(value);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">public</span> sin() &#123;</div><div class="line">        <span class="keyword">this</span>.value = <span class="built_in">Math</span>.sin(<span class="keyword">this</span>.value);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// ... other operations go here ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> v = <span class="keyword">new</span> ScientificCalculator(<span class="number">2</span>)</div><div class="line">        .multiply(<span class="number">5</span>)</div><div class="line">        .sin()</div><div class="line">        .add(<span class="number">1</span>)</div><div class="line">        .currentValue();</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><p>有时候我们会选取一个js对象中属性的子集</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickProperties</span>(<span class="params">propertiesName: <span class="built_in">string</span>[], obj: object</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> propertiesName.map(<span class="function"><span class="params">key</span> =&gt;</span> obj[key]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> m = &#123;</div><div class="line">    hello: <span class="number">123</span>,</div><div class="line">    hi: <span class="number">123</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(pickProperties([<span class="string">'hi'</span>], m)); <span class="comment">// [ 123 ]</span></div><div class="line"><span class="built_in">console</span>.log(pickProperties([<span class="string">'h21i'</span>], m)); <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p>有可能打错了一个变量名会造成我们不想要的结果，ts语法是相当灵活的，通过索引查询和访问操作符我们可以使得编译器检验我们的输入！</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">enhancedPickProperties</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">propertiesName: K[], obj: T</span>): <span class="title">T</span>[<span class="title">K</span>][] </span>&#123;</div><div class="line">    <span class="keyword">return</span> propertiesName.map(<span class="function"><span class="params">key</span> =&gt;</span> obj[key]);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(enhancedPickProperties([<span class="string">'h21i'</span>], m)); <span class="comment">// error , h21i不属于字面量类型hi|hello</span></div></pre></td></tr></table></figure>
<p>这个方法泛型用的非常巧妙，首先我们利用索引查询符号取得T的索引联合类型，以K去继承这个类型，这意味着propertiesName的类型是这个字面量联合类型的数组，所以我们输入是会检查我们数组中的元素是不是字面量联合类型，这样就达到了检查的目的。另一方面我们用T[K]来掐死了输出类型必须是类型T的属性的数组。</p>
<h3 id="字符串索引签名的索引类型"><a href="#字符串索引签名的索引类型" class="headerlink" title="字符串索引签名的索引类型"></a>字符串索引签名的索引类型</h3><p>如对一个带有字符串索引类型签名使用keyof那么结果将是string。而且T[string]为索引签名的类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Map&lt;T&gt; &#123;</div><div class="line">    [key: <span class="built_in">string</span>]: T;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> keys: keyof Map&lt;<span class="built_in">number</span>&gt;; <span class="comment">// string</span></div></pre></td></tr></table></figure>
<h2 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h2><p>我们有一个类型，但是我希望它有两个版本，属性全部可选和属性全部只读，这样的情况之下我们可能需要声明两个类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> ImmutableCar &#123;</div><div class="line">    readonly price: <span class="built_in">number</span>;</div><div class="line">    readonly size: <span class="built_in">string</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">price: <span class="built_in">number</span>, size: <span class="built_in">string</span></span>) &#123;</div><div class="line">        <span class="keyword">this</span>.price = price;</div><div class="line">        <span class="keyword">this</span>.size = size;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Car &#123;</div><div class="line">    price?: <span class="built_in">number</span>;</div><div class="line">    size?: <span class="built_in">string</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>数量的使用泛型和类型别名来进行类型映射可以减缓很多工作。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//下面是ts标准库里的一些函数</span></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Make all properties in T optional</div><div class="line"> */</div><div class="line"><span class="keyword">type</span> Partial&lt;T&gt; = &#123;</div><div class="line">    [P <span class="keyword">in</span> keyof T]?: T[P];</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Make all properties in T required</div><div class="line"> */</div><div class="line"><span class="keyword">type</span> Required&lt;T&gt; = &#123;</div><div class="line">    [P <span class="keyword">in</span> keyof T]-?: T[P];</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Make all properties in T readonly</div><div class="line"> */</div><div class="line"><span class="keyword">type</span> Readonly&lt;T&gt; = &#123;</div><div class="line">    readonly [P <span class="keyword">in</span> keyof T]: T[P];</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * From T pick a set of properties K</div><div class="line"> */</div><div class="line"><span class="keyword">type</span> Pick&lt;T, K <span class="keyword">extends</span> keyof T&gt; = &#123;</div><div class="line">    [P <span class="keyword">in</span> K]: T[P];</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">type</span> PersonPartial = Partial&lt;Car&gt;;</div><div class="line"><span class="keyword">type</span> ReadonlyPerson = Readonly&lt;Car&gt;;</div></pre></td></tr></table></figure>
<h3 id="简单类型映射"><a href="#简单类型映射" class="headerlink" title="简单类型映射"></a>简单类型映射</h3><p>我们可以同构类型别名来声明一个字面量联合类型，然后用另一个类型别名来对这个字面量联合类型遍历，从而声明得到另一个类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> keys = <span class="string">'name'</span>|<span class="string">'phoneNumber'</span>|<span class="string">'address'</span></div><div class="line"><span class="keyword">type</span> Person = &#123;</div><div class="line">    [K <span class="keyword">in</span> keys]: <span class="built_in">string</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="同态映射"><a href="#同态映射" class="headerlink" title="同态映射"></a>同态映射</h3><p>用wiki上的话简单来讲同态：</p>
<hr>
<p><a href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0" target="_blank" rel="external">抽象代数</a>中，<strong>同态</strong>是两个<a href="https://zh.wikipedia.org/wiki/%E4%BB%A3%E6%95%B0%E7%BB%93%E6%9E%84" target="_blank" rel="external">代数结构</a>（例如<a href="https://zh.wikipedia.org/wiki/%E7%BE%A4" target="_blank" rel="external">群</a>、环、或者<a href="https://zh.wikipedia.org/wiki/%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4" target="_blank" rel="external">向量空间</a>）之间的保持结构不变的<a href="https://zh.wikipedia.org/wiki/%E6%98%A0%E5%B0%84" target="_blank" rel="external">映射</a>。</p>
<hr>
<p>上面提到的<code>Readonly</code>， <code>Partial</code>和 <code>Pick</code>，<code>Require</code>都是同态的，编译器知道在添加新属性之前拷贝所有存在的属性修饰符。 例如，假设 <code>Person.name</code>是只读的，那么 <code>Partial&lt;Person&gt;.name</code>也将是只读的且为可选的。新的类型的结构和旧类型相同（属性名和类型相同）。</p>
<p>考虑另一个映射：Record</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Record&lt;K <span class="keyword">extends</span> <span class="built_in">string</span>, T&gt; = &#123;</div><div class="line">    [P <span class="keyword">in</span> K]: T;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Record并不是同态的，从结构上来讲新类型和T并没有什么关系，Record映射的新类型并不需要从输入类型中来拷贝属性，本质上它是在创建属性。</p>
<p>一些有意思的映射已经提供在了ts的标准库中。</p>
<ul>
<li><code>Exclude&lt;T, U&gt;</code> – 从<code>T</code>中剔除可以赋值给<code>U</code>的类型。(<a href="https://github.com/Microsoft/TypeScript/issues/12215#issuecomment-307871458" target="_blank" rel="external">建议的</a><code>Diff</code>类型的一种实现)</li>
<li><code>Extract&lt;T, U&gt;</code> – 提取<code>T</code>中可以赋值给<code>U</code>的类型。</li>
<li><code>NonNullable&lt;T&gt;</code> – 从<code>T</code>中剔除<code>null</code>和<code>undefined</code>。</li>
<li><code>ReturnType&lt;T&gt;</code> – 获取函数返回值类型。</li>
<li><code>InstanceType&lt;T&gt;</code> – 获取构造函数类型的实例类型。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;多态this类型&quot;&gt;&lt;a href=&quot;#多态this类型&quot; class=&quot;headerlink&quot; title=&quot;多态this类型&quot;&gt;&lt;/a&gt;多态this类型&lt;/h2&gt;&lt;p&gt;  考虑到链式编程，很多连贯性操作中我们都会返回this，ts中允许把this作为返回值类型已到达继承之后依然能用基类的方法达到链式调用的目的。&lt;/p&gt;
&lt;figure class=&quot;highlight typescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;30&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;31&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;32&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; BasicCalculator &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;protected&lt;/span&gt; value: &lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt; = 0&lt;/span&gt;) &amp;#123; &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; currentValue(): &lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.value;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; add(operand: &lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;): &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.value += operand;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; multiply(operand: &lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;): &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.value *= operand;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ... other operations go here ...&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; ScientificCalculator &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; BasicCalculator &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;value = 0&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;super&lt;/span&gt;(value);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; sin() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.value = &lt;span class=&quot;built_in&quot;&gt;Math&lt;/span&gt;.sin(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.value);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// ... other operations go here ...&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; v = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ScientificCalculator(&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        .multiply(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        .sin()&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        .add(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        .currentValue();&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="typescript" scheme="http://yoursite.com/tags/typescript/"/>
    
      <category term="notes" scheme="http://yoursite.com/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>Typescript(5):Advenced type</title>
    <link href="http://yoursite.com/2019/03/14/Typescript-5-advenced-type/"/>
    <id>http://yoursite.com/2019/03/14/Typescript-5-advenced-type/</id>
    <published>2019-03-14T10:25:57.000Z</published>
    <updated>2019-03-14T12:53:42.655Z</updated>
    
    <content type="html"><![CDATA[<h2 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h2><p>你可能尝试过mixins，这是经常使用到的交叉类型的一种情况，交叉类型让我们可以吧多种现有类型叠加而成为一种类型，这个新类型包含所需的所有类型的特性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> BMW &#123;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> drivable:<span class="built_in">number</span></span>)&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Benz &#123;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> comfortable: <span class="built_in">number</span></span>) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> certainCar:BMW &amp; Benz;</div></pre></td></tr></table></figure>
<p>我们可以这样来创建一辆集合了驾驶感和舒适感的好车：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bestCarFactory</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">drivableCar:T,comfortableCar:U</span>): <span class="title">T</span> &amp; <span class="title">U</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> bestCar = &#123;&#125; <span class="keyword">as</span> T &amp; U;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> property <span class="keyword">in</span> drivableCar)&#123;</div><div class="line">        (&lt;<span class="built_in">any</span>&gt;bestCar)[property] = drivableCar[property];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> property <span class="keyword">in</span> comfortableCar)&#123;</div><div class="line">        <span class="keyword">if</span>(!bestCar.hasOwnProperty(property))&#123;</div><div class="line">            (&lt;<span class="built_in">any</span>&gt;bestCar)[comfortableCar] = comfortableCar[property];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> bestCar;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> carFactory = bestCarFactory(<span class="keyword">new</span> BMW(), <span class="keyword">new</span> Benz());</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(carFactory.drivable);</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h2><p>联合类型可能会出现的比较多，一个<strong>联合类型变量只能访问所有类型里的共有成员</strong>，现在我们来下修改下我们的Benz和BMW。如何我们一定要访问不共有的对象那么我们就有必要使用类型断言。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> BMW &#123;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> drivable:<span class="built_in">number</span>, <span class="keyword">public</span> price:<span class="built_in">number</span></span>)&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Benz &#123;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> comfortable: <span class="built_in">number</span>, <span class="keyword">public</span> price:<span class="built_in">number</span></span>) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> goodCar: BMW | Benz = &#123;&#125; <span class="keyword">as</span> BMW | Benz;</div><div class="line">goodCar.price;</div><div class="line"><span class="comment">// goodCar.comfortable;  error!</span></div><div class="line"></div><div class="line"><span class="comment">//类型断言</span></div><div class="line">(goodCar <span class="keyword">as</span> Benz ).comfortable</div></pre></td></tr></table></figure>
<h2 id="类型保护"><a href="#类型保护" class="headerlink" title="类型保护"></a>类型保护</h2><h4 id="自定义类型保护"><a href="#自定义类型保护" class="headerlink" title="自定义类型保护"></a>自定义类型保护</h4><p>如果我们在一个函数联合类型参数的方法中反复的使用类型断言去调用那些非共同的成员，这代码会显得很累赘，显然一个优秀的语言设计者会考虑到这一点，我们可以使用类型谓词来进行类型保护，我们只需要进行一次检查，通过之后编译器不再去检查类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// goodCar is Benz 是类型谓词</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBenz</span>(<span class="params">goodCar: BMW | Benz</span>): <span class="title">goodCar</span> <span class="title">is</span> <span class="title">Benz</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (goodCar <span class="keyword">as</span> Benz).comfortable !== <span class="literal">undefined</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">obj:BMW | Benz</span>) </span>&#123;</div><div class="line">    <span class="comment">// obj.comfortable; error!</span></div><div class="line">    <span class="keyword">if</span> (isBenz(obj)) &#123;</div><div class="line">        obj.comfortable</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        obj.drivable;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="Typeof和instanceof"><a href="#Typeof和instanceof" class="headerlink" title="Typeof和instanceof"></a>Typeof和instanceof</h4><p>对于基本的类型，我们可以简单的用typeof来实现我们的类型保护函数！而对与对象我们可以用instanceof来构建保护函数</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNumber</span>(<span class="params">variable: <span class="built_in">number</span> | <span class="built_in">string</span></span>): <span class="title">variable</span> <span class="title">is</span> <span class="title">number</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> variable === <span class="string">'number'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isBenz</span>(<span class="params">goodCar: BMW | Benz</span>): <span class="title">goodCar</span> <span class="title">is</span> <span class="title">Benz</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> goodCar <span class="keyword">instanceof</span> Benz;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上我们用不着这么麻烦</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> m;</div><div class="line"></div><div class="line"><span class="comment">// 下面两种效果相同</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> m === <span class="string">'number'</span>)&#123;</div><div class="line">    </div><div class="line">&#125; </div><div class="line"></div><div class="line"><span class="keyword">if</span> (isNumber(m)) &#123;</div><div class="line">    </div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 反向</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> m !== <span class="string">'number'</span>)&#123;</div><div class="line">    </div><div class="line">&#125; </div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//对于对象</span></div><div class="line"><span class="keyword">let</span> car:Car = CarFactory.build();</div><div class="line"></div><div class="line"><span class="keyword">if</span>(car <span class="keyword">instanceof</span> Benz)&#123;</div><div class="line">    obj.comfortable;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (isBenz(obj)) &#123;</div><div class="line">     obj.comfortable;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">     obj.drivable;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="可以为null的类型"><a href="#可以为null的类型" class="headerlink" title="可以为null的类型"></a>可以为null的类型</h2><p>默认情况下null与undefined类型可以复制给任意类型，但是近来很多事件尝试去避免空指针和undefined错误，在—strictNullChecks标记下编译，将强制程序员在编码时显示的声明null和undefined!如果是可选参数和可选属性的话，情况会略有不同，可选参数会自动的被加上undefined但是却不能复制为null。</p>
<h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>类型别名可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。其作用很简单，就是给类型起一个新的名字。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> newName = Benz;</div><div class="line"><span class="keyword">type</span> newFunctionType = <span class="function">(<span class="params">price:<span class="built_in">number</span></span>) =&gt;</span> Benz;</div><div class="line"><span class="keyword">type</span> someThing = newName &amp; newFunctionType;</div></pre></td></tr></table></figure>
<p>类型别名并没有创建新的类型，只是创建了新的名字来应用原来的类型。</p>
<h3 id="泛型类型别名"><a href="#泛型类型别名" class="headerlink" title="泛型类型别名"></a>泛型类型别名</h3><p>运用类型别名结合泛型我们可以定义一些有意思的东西</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Container&lt;T&gt; = &#123; value: T &#125;;</div><div class="line"></div><div class="line"><span class="comment">// 可以使用类型别名来在**属性**里引用自己</span></div><div class="line"><span class="keyword">type</span> Tree&lt;T&gt; = &#123;</div><div class="line">    value: T;</div><div class="line">    left: Tree&lt;T&gt;;</div><div class="line">    right: Tree&lt;T&gt;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//但是类型别名不能出现在声明右侧的任何地方</span></div><div class="line"><span class="keyword">type</span> Yikes = <span class="built_in">Array</span>&lt;Yikes&gt;; <span class="comment">// error</span></div><div class="line"></div><div class="line"><span class="keyword">type</span> LinkedList&lt;T&gt; = T &amp; &#123; next: LinkedList&lt;T&gt; &#125;;</div><div class="line"></div><div class="line"><span class="keyword">interface</span> Person &#123;</div><div class="line">    name: <span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> people: LinkedList&lt;Person&gt;;</div><div class="line"><span class="keyword">var</span> s = people.name;</div><div class="line"><span class="keyword">var</span> s = people.next.name;</div><div class="line"><span class="keyword">var</span> s = people.next.next.name;</div><div class="line"><span class="keyword">var</span> s = people.next.next.next.name;</div></pre></td></tr></table></figure>
<p>类型别名并不创建新的名字，错误信息中不会使用类型别名来作为错误，而且类型别名， 也不能被继承和实现（extends/implements）。</p>
<h2 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h2><p>我们在上一篇文章介绍了字面量枚举可以作为类型来使用，这里引入一种更加简单的方式可以来代替常量枚举，就是字面量类型。字面量类型可以和联合类型，类型保护和类型别名结合起来使用</p>
<h3 id="字符串和数字字面量类型"><a href="#字符串和数字字面量类型" class="headerlink" title="字符串和数字字面量类型"></a>字符串和数字字面量类型</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> literal = <span class="string">"A"</span> | <span class="string">"b"</span> | <span class="string">"C"</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">abc</span>(<span class="params">letter:literal</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> letter;</div><div class="line">&#125;</div><div class="line"></div><div class="line">abc(<span class="string">"A"</span>);</div><div class="line"><span class="comment">// abc("D"); error </span></div><div class="line"></div><div class="line"><span class="keyword">type</span> numbers = <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params">n:numbers</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> n;</div><div class="line">&#125;</div><div class="line"></div><div class="line">f2(<span class="number">2</span>);</div><div class="line"><span class="comment">// f2(4); error</span></div></pre></td></tr></table></figure>
<h3 id="可辨识联合"><a href="#可辨识联合" class="headerlink" title="可辨识联合"></a>可辨识联合</h3><p>在ngrx中我们经常用到action，然后运用reducer来对特别的action进行处理。ts会自动的为你识别可辨识联合</p>
<ol>
<li>具有普通的单例类型属性— <em>可辨识的特征</em>。</li>
<li>一个类型别名包含了那些类型的联合— <em>联合</em>。</li>
<li>此属性上的类型保护。</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Square &#123;</div><div class="line">    kind: <span class="string">"square"</span>;</div><div class="line">    size: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">interface</span> Rectangle &#123;</div><div class="line">    kind: <span class="string">"rectangle"</span>;</div><div class="line">    width: <span class="built_in">number</span>;</div><div class="line">    height: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">interface</span> Circle &#123;</div><div class="line">    kind: <span class="string">"circle"</span>;</div><div class="line">    radius: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">type</span> Shape = Square | Rectangle | Circle;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">s: Shape</span>) </span>&#123;</div><div class="line">    <span class="keyword">switch</span> (s.kind) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">"square"</span>: <span class="keyword">return</span> s.size * s.size;</div><div class="line">        <span class="keyword">case</span> <span class="string">"rectangle"</span>: <span class="keyword">return</span> s.height * s.width;</div><div class="line">        <span class="keyword">case</span> <span class="string">"circle"</span>: <span class="keyword">return</span> <span class="built_in">Math</span>.PI * s.radius ** <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>检查完整性，在写action时我们可能会对一些type进行处理，如果我们需要对别名进行完整性检查，我们可以效仿下面这种做法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">assertNever</span>(<span class="params">x: never</span>): <span class="title">never</span> </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Unexpected object: "</span> + x);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">s: Shape</span>) </span>&#123;</div><div class="line">    <span class="keyword">switch</span> (s.kind) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">"square"</span>: <span class="keyword">return</span> s.size * s.size;</div><div class="line">        <span class="keyword">case</span> <span class="string">"rectangle"</span>: <span class="keyword">return</span> s.height * s.width;</div><div class="line">        <span class="keyword">case</span> <span class="string">"circle"</span>: <span class="keyword">return</span> <span class="built_in">Math</span>.PI * s.radius ** <span class="number">2</span>;</div><div class="line">        <span class="keyword">default</span>: <span class="keyword">return</span> assertNever(s); <span class="comment">// error 编译器提示triangle不能被assign到never类型</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;交叉类型&quot;&gt;&lt;a href=&quot;#交叉类型&quot; class=&quot;headerlink&quot; title=&quot;交叉类型&quot;&gt;&lt;/a&gt;交叉类型&lt;/h2&gt;&lt;p&gt;你可能尝试过mixins，这是经常使用到的交叉类型的一种情况，交叉类型让我们可以吧多种现有类型叠加而成为一种类型，这个新类型包含所需的所有类型的特性。&lt;/p&gt;
&lt;figure class=&quot;highlight typescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; BMW &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; drivable:&lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;&lt;/span&gt;)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; Benz &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; comfortable: &lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;&lt;/span&gt;) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; certainCar:BMW &amp;amp; Benz;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们可以这样来创建一辆集合了驾驶感和舒适感的好车：&lt;/p&gt;
&lt;figure class=&quot;highlight typescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bestCarFactory&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;U&lt;/span&gt;&amp;gt;(&lt;span class=&quot;params&quot;&gt;drivableCar:T,comfortableCar:U&lt;/span&gt;): &lt;span class=&quot;title&quot;&gt;T&lt;/span&gt; &amp;amp; &lt;span class=&quot;title&quot;&gt;U&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; bestCar = &amp;#123;&amp;#125; &lt;span class=&quot;keyword&quot;&gt;as&lt;/span&gt; T &amp;amp; U;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; property &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; drivableCar)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        (&amp;lt;&lt;span class=&quot;built_in&quot;&gt;any&lt;/span&gt;&amp;gt;bestCar)[property] = drivableCar[property];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; property &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; comfortableCar)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(!bestCar.hasOwnProperty(property))&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            (&amp;lt;&lt;span class=&quot;built_in&quot;&gt;any&lt;/span&gt;&amp;gt;bestCar)[comfortableCar] = comfortableCar[property];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; bestCar;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; carFactory = bestCarFactory(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; BMW(), &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Benz());&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(carFactory.drivable);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="typescript" scheme="http://yoursite.com/tags/typescript/"/>
    
      <category term="notes" scheme="http://yoursite.com/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>Typescript(4):Enums</title>
    <link href="http://yoursite.com/2019/03/12/Typescript-Enums/"/>
    <id>http://yoursite.com/2019/03/12/Typescript-Enums/</id>
    <published>2019-03-12T11:54:25.000Z</published>
    <updated>2019-03-14T12:52:18.215Z</updated>
    
    <content type="html"><![CDATA[<p>枚举允许我们简单的定义一些但名字的常量，在TS语法中支持数字和基于字符串的两种枚举。</p>
<a id="more"></a>
<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><h3 id="数字枚举"><a href="#数字枚举" class="headerlink" title="数字枚举"></a>数字枚举</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//默认情况下X为0，Y为1，Z为2</span></div><div class="line"><span class="keyword">enum</span> Dimention &#123;</div><div class="line">    X,Y,Z</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//此时Y为2，Z为3</span></div><div class="line"><span class="keyword">enum</span> Dimention &#123;</div><div class="line">    X = <span class="number">1</span>,Y,Z</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//此时X=0，Z=3</span></div><div class="line"><span class="keyword">enum</span> Dimention &#123;</div><div class="line">    X ,Y = <span class="number">2</span> ,Z</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//此时X=0，Z=3.1</span></div><div class="line"><span class="keyword">enum</span> Dimention &#123;</div><div class="line">    X ,Y = <span class="number">2.1</span> ,Z</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(Dimention.Z)</div><div class="line"></div><div class="line"><span class="comment">//数字枚举的值可以是由计算表达式和常量两者来初始化，但是在用计算表达式初始化时需要放在不带初始化器或带常量初始化器的枚举值的后面</span></div><div class="line"><span class="keyword">enum</span> Dimention &#123;</div><div class="line">    <span class="comment">//Z报错，找不到初始化器</span></div><div class="line">    X ,Y = getNumber() ,Z</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// fine!</span></div><div class="line"><span class="keyword">enum</span> Dimention &#123;</div><div class="line">    X = <span class="number">0</span> ,Y = getNumber() ,Z = <span class="number">1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//没问题</span></div><div class="line"><span class="keyword">enum</span> Dimention &#123;</div><div class="line">    X ,Z ,Y = getNumber()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="数字枚举的反向映射"><a href="#数字枚举的反向映射" class="headerlink" title="数字枚举的反向映射"></a>数字枚举的反向映射</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> Enum &#123;</div><div class="line">    A</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> a = Enum.A;</div><div class="line"><span class="keyword">let</span> nameOfA = Enum[a]; <span class="comment">// "A"</span></div><div class="line"><span class="keyword">let</span> nameOfB = Enum[<span class="number">0</span>]; <span class="comment">// "A"</span></div></pre></td></tr></table></figure>
<h3 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h3><p>字符串枚举每个成员都必须用字符串字面量初始化，或者用空一格字符串成员枚举进行初始化</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> Direction &#123;</div><div class="line">    Up = <span class="string">"UP"</span>,</div><div class="line">    Down = <span class="string">"DOWN"</span>,</div><div class="line">    Left = <span class="string">"LEFT"</span>,</div><div class="line">    Right = <span class="string">"RIGHT"</span>,</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="keyword">enum</span> Direction &#123;</div><div class="line">    Up = <span class="string">"UP"</span>,</div><div class="line">    Down = <span class="string">"DOWN"</span>,</div><div class="line">    Left = <span class="string">"LEFT"</span>,</div><div class="line">    Right = Up,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="异构枚举"><a href="#异构枚举" class="headerlink" title="异构枚举"></a>异构枚举</h3><p>异构枚举是一种不太好的实现</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> Direction &#123;</div><div class="line">    Up = <span class="string">"UP"</span>,</div><div class="line">    Down = <span class="number">1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="联合枚举值和枚举成员类型"><a href="#联合枚举值和枚举成员类型" class="headerlink" title="联合枚举值和枚举成员类型"></a>联合枚举值和枚举成员类型</h2><p>存在一种特殊的非计算的常量枚举成员的子集：<strong>字面量枚举成员</strong>。 字面量枚举成员是指不带有初始值的常量枚举成员，或者是值被初始化为</p>
<ul>
<li>任何字符串字面量（例如： <code>&quot;foo&quot;</code>， <code>&quot;bar&quot;</code>， <code>&quot;baz&quot;</code>）</li>
<li>任何数字字面量（例如： <code>1</code>, <code>100</code>）</li>
<li>应用了一元 <code>-</code>符号的数字字面量（例如： <code>-1</code>, <code>-100</code></li>
</ul>
<p><strong>当所有枚举成员都拥有字面量枚举值时，它就带有了一种特殊的语义。</strong></p>
<p>首先，<strong>枚举成员成为了类型！</strong> 例如，我们可以说某些成员 <em>只能</em>是枚举成员的值：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> ShapeKind &#123;</div><div class="line">    Circle,</div><div class="line">    Square,</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">interface</span> Circle &#123;</div><div class="line">    kind: ShapeKind.Circle;</div><div class="line">    radius: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">interface</span> Square &#123;</div><div class="line">    kind: ShapeKind.Square;</div><div class="line">    sideLength: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> c: Circle = &#123;</div><div class="line">    kind: ShapeKind.Square,</div><div class="line">    <span class="comment">//    ~~~~~~~~~~~~~~~~ Error!</span></div><div class="line">    radius: <span class="number">100</span>,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>另一个变化是枚举类型本身变成了每个枚举成员的 <em>联合</em></strong>,通过联合枚举能够让类型系统知道枚举的值的集合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">enum E &#123;</div><div class="line">    Foo,</div><div class="line">    Bar,</div><div class="line">&#125;</div><div class="line"></div><div class="line">function f(x: E) &#123;</div><div class="line">    //这里会报错，原因是编译器检测出E不是Foo就是Bar，所以或操作符后面的比较毫无意义</div><div class="line">    if (x !== E.Foo || x !== E.Bar) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="运行时枚举"><a href="#运行时枚举" class="headerlink" title="运行时枚举"></a>运行时枚举</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">enum</span> Dimention &#123;</div><div class="line">    X=<span class="number">1</span> ,Y = getNumber() ,Z=<span class="number">0</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">d:&#123;X:<span class="built_in">number</span>&#125;</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> d.X;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Dimention是真正存在的对象，满足类型&#123;X:number&#125;的结构定义</span></div><div class="line"><span class="built_in">console</span>.log(f1(Dimention));</div></pre></td></tr></table></figure>
<h2 id="常量枚举"><a href="#常量枚举" class="headerlink" title="常量枚举"></a>常量枚举</h2><p>常量枚举只能用常量表达式，不允许包含计算成员。常量表达式会在常量枚举编译时删除，使用它的地方则会直接内联进来。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> <span class="keyword">enum</span> Directions &#123;</div><div class="line">    Up,</div><div class="line">    Down,</div><div class="line">    Left,</div><div class="line">    Right</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> directions = [<span class="number">0</span> <span class="comment">/* Up */</span>, <span class="number">1</span> <span class="comment">/* Down */</span>, <span class="number">2</span> <span class="comment">/* Left */</span>, <span class="number">3</span> <span class="comment">/* Right */</span>];</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;枚举允许我们简单的定义一些但名字的常量，在TS语法中支持数字和基于字符串的两种枚举。&lt;/p&gt;
    
    </summary>
    
    
      <category term="typescript" scheme="http://yoursite.com/tags/typescript/"/>
    
      <category term="notes" scheme="http://yoursite.com/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>Typescript(3):Genericity and Type Inference</title>
    <link href="http://yoursite.com/2019/03/12/Typescript-3-Genericity/"/>
    <id>http://yoursite.com/2019/03/12/Typescript-3-Genericity/</id>
    <published>2019-03-12T08:34:32.000Z</published>
    <updated>2019-03-12T11:53:14.612Z</updated>
    
    <content type="html"><![CDATA[<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="泛型函数"><a href="#泛型函数" class="headerlink" title="泛型函数"></a>泛型函数</h3><p>ts中，我们同样用尖括号来声明泛型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">genericFuction</span>&lt;<span class="title">T</span>&gt;(<span class="params">param:T</span>): <span class="title">T</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> param;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 显示泛型调用</span></div><div class="line"><span class="built_in">console</span>.log(genericFuction&lt;<span class="built_in">string</span>&gt;(<span class="string">'HELLO'</span>));</div><div class="line"></div><div class="line"><span class="comment">// 类型推导</span></div><div class="line"><span class="built_in">console</span>.log(genericFuction(<span class="string">'HELLO'</span>));</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h3><p>ts中函数也有类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> func:&lt;T&gt;<span class="function">(<span class="params">param:T</span>) =&gt;</span> T = <span class="function"><span class="keyword">function</span> <span class="title">genericFuction</span>&lt;<span class="title">T</span>&gt;(<span class="params">param:T</span>): <span class="title">T</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> param;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> func2:&lt;T,U&gt;<span class="function">(<span class="params">param:T, arg?:U</span>) =&gt;</span> T = <span class="function"><span class="keyword">function</span> <span class="title">genericFuction2</span>&lt;<span class="title">T</span>,<span class="title">U</span>&gt;(<span class="params">param:T, arg?:U</span>): <span class="title">T</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> param;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrayFunction</span>&lt;<span class="title">T</span>&gt;(<span class="params">arr:<span class="built_in">Array</span>&lt;T&gt;</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> arr.length;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">arrayFunction2</span>&lt;<span class="title">T</span>&gt;(<span class="params">arr:T[]</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> arr.length;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> GenericClazz &lt;T,U&gt; &#123;</div><div class="line">     count:T;</div><div class="line">     toU:<span class="function">(<span class="params">something:T</span>) =&gt;</span> U; </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> clazz = <span class="keyword">new</span> GenericClazz();</div><div class="line"></div><div class="line"><span class="comment">// error 类型不匹配</span></div><div class="line"><span class="comment">// let clazz = new GenericClazz&lt;number&gt;();</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> clazz = <span class="keyword">new</span> GenericClazz&lt;<span class="built_in">number</span>,<span class="built_in">string</span>&gt;();</div></pre></td></tr></table></figure>
<h3 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h3><h4 id="上界约束"><a href="#上界约束" class="headerlink" title="上界约束"></a>上界约束</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Circle &#123;</div><div class="line">    radius:<span class="built_in">number</span>;</div><div class="line">    getArea()&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * <span class="built_in">Math</span>.pow(<span class="keyword">this</span>.radius, <span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateArea</span>&lt;<span class="title">T</span>&gt;(<span class="params">shape:T</span>) </span>&#123;</div><div class="line">    <span class="comment">//报错，编译器并不知道T会存在一个叫做getArea的函数</span></div><div class="line">    <span class="keyword">return</span> shape.getArea();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//泛型约束为Circle的上届</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">enhancedCalculateArea</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Circle</span>&gt;(<span class="params">shape:T</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> shape.getArea();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//传递一个可以通过结构类型检测的对象</span></div><div class="line">enhancedCalculateArea(&#123;</div><div class="line">    radius: <span class="number">1</span>, getArea: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">3.14</span> * <span class="built_in">Math</span>.pow(<span class="keyword">this</span>.radius, <span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="属性名约束"><a href="#属性名约束" class="headerlink" title="属性名约束"></a>属性名约束</h4><p>非常有趣的，下面这段抄袭来的代码中，我们可以看到在函数定义时，我们显示的把key的类型以keyof方法，定义为了T的索引类型！</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getProperty</span>&lt;<span class="title">T</span>, <span class="title">K</span> <span class="title">extends</span> <span class="title">keyof</span> <span class="title">T</span>&gt;(<span class="params">obj: T, key: K</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> obj[key];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> x = &#123; a: <span class="number">1</span>, b: <span class="number">2</span>, c: <span class="number">3</span>, d: <span class="number">4</span> &#125;;</div><div class="line"></div><div class="line">getProperty(x, <span class="string">"a"</span>); <span class="comment">// okay</span></div><div class="line">getProperty(x, <span class="string">"m"</span>); <span class="comment">// error: Argument of type 'm' isn't assignable to 'a' | 'b' | 'c' | 'd'.</span></div></pre></td></tr></table></figure>
<h4 id="类类型约束"><a href="#类类型约束" class="headerlink" title="类类型约束"></a>类类型约束</h4><p>我们可以约束new方法的类型</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function factoryBuild&lt;T&gt;(o: &#123; new(): T &#125;):T &#123;</div><div class="line">    return new o();</div><div class="line">&#125;</div><div class="line"></div><div class="line">class TestClazz &#123;</div><div class="line">    count:number = 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">let testClazz = factoryBuild(TestClazz);</div><div class="line"></div><div class="line">console.log(testClazz.count);</div></pre></td></tr></table></figure>
<p>甚至我们可以混合的约束new方法返回值类型的上界</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> CarFactory &#123;</div><div class="line"></div><div class="line">    assembly&lt;T <span class="keyword">extends</span> Car&gt;<span class="function">(<span class="params">c: <span class="keyword">new</span>(<span class="params"></span>) =&gt; T </span>): <span class="params">T</span> &#123;</span></div><div class="line">        <span class="params">return</span> <span class="params">new</span> <span class="params">c</span><span class="params">()</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="params">construct</span>&lt;<span class="params">T</span> <span class="params">extends</span> <span class="params">Car</span>&gt;(<span class="params">c: &#123;<span class="keyword">new</span>(<span class="params"></span>):T&#125; </span>): <span class="params">T</span> &#123;</div><div class="line">        <span class="params">return</span> <span class="params">new</span> <span class="params">c</span><span class="params">()</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h2><p>最基础的类型推断也是我们经常使用的直接了当</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> n = <span class="number">1</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> n); <span class="comment">//number</span></div></pre></td></tr></table></figure>
<h3 id="最佳通用类型"><a href="#最佳通用类型" class="headerlink" title="最佳通用类型"></a>最佳通用类型</h3><p>数组和元组中经常会出现多种类型的情况，一般</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Car &#123;</div><div class="line">    pay()&#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Audi <span class="keyword">extends</span> Car &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> BMW <span class="keyword">extends</span> Car &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> cars = [<span class="keyword">new</span> Audi(), <span class="keyword">new</span> BMW()];</div></pre></td></tr></table></figure>
<h3 id="反向推断"><a href="#反向推断" class="headerlink" title="反向推断"></a>反向推断</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Car &#123;</div><div class="line">    pay()&#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 函数定义中我们并没有定义car的类型，但是反向推断编译器能知道这个car的类型就是Car,因此我们能调用到pay方法</span></div><div class="line"><span class="keyword">let</span> carFunction:<span class="function">(<span class="params">some:Car</span>) =&gt;</span> <span class="built_in">void</span> = <span class="function"><span class="keyword">function</span> (<span class="params">car</span>) </span>&#123;</div><div class="line">    car.pay();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//甚至反向类型推断会让我们所声明的类型无效</span></div><div class="line"><span class="keyword">let</span> carFunction:<span class="function">(<span class="params">car:Car</span>) =&gt;</span> <span class="built_in">void</span> = <span class="function"><span class="keyword">function</span> (<span class="params">car:<span class="built_in">any</span></span>) </span>&#123;</div><div class="line">    car.pay();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Audi <span class="keyword">extends</span> Car &#123;</div><div class="line">    audi()&#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//当然需要我们的类型是兼容的,且更加'具体'，那么将保留我们自己声明的类型</span></div><div class="line"><span class="keyword">let</span> carFunction:<span class="function">(<span class="params">car:Car</span>) =&gt;</span> <span class="built_in">void</span> = <span class="function"><span class="keyword">function</span> (<span class="params">car:Audi</span>) </span>&#123;</div><div class="line">    car.pay();</div><div class="line">    car.audi();</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;泛型&quot;&gt;&lt;a href=&quot;#泛型&quot; class=&quot;headerlink&quot; title=&quot;泛型&quot;&gt;&lt;/a&gt;泛型&lt;/h2&gt;&lt;h3 id=&quot;泛型函数&quot;&gt;&lt;a href=&quot;#泛型函数&quot; class=&quot;headerlink&quot; title=&quot;泛型函数&quot;&gt;&lt;/a&gt;泛型函数&lt;/h3&gt;&lt;p&gt;ts中，我们同样用尖括号来声明泛型：&lt;/p&gt;
&lt;figure class=&quot;highlight typescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;genericFuction&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;T&lt;/span&gt;&amp;gt;(&lt;span class=&quot;params&quot;&gt;param:T&lt;/span&gt;): &lt;span class=&quot;title&quot;&gt;T&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; param;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 显示泛型调用&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(genericFuction&amp;lt;&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;&amp;gt;(&lt;span class=&quot;string&quot;&gt;&#39;HELLO&#39;&lt;/span&gt;));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 类型推导&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(genericFuction(&lt;span class=&quot;string&quot;&gt;&#39;HELLO&#39;&lt;/span&gt;));&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="typescript" scheme="http://yoursite.com/tags/typescript/"/>
    
      <category term="notes" scheme="http://yoursite.com/tags/notes/"/>
    
  </entry>
  
  <entry>
    <title>Typescript(2):Function</title>
    <link href="http://yoursite.com/2019/03/11/Typescript-2-Function/"/>
    <id>http://yoursite.com/2019/03/11/Typescript-2-Function/</id>
    <published>2019-03-11T10:15:43.000Z</published>
    <updated>2019-03-14T12:52:34.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><p>一般情况下我们可以直接借助类型推到来声明一个函数变量，但是有些时候我们更倾向于写出完整的函数类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> func = <span class="function"><span class="keyword">function</span> (<span class="params">a:<span class="built_in">number</span>,b:<span class="built_in">number</span></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> a+b;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//完整的函数类型</span></div><div class="line"><span class="keyword">let</span> func1:<span class="function">(<span class="params">m:<span class="built_in">number</span>,k:<span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>= <span class="function"><span class="keyword">function</span> (<span class="params">a:<span class="built_in">number</span>,b:<span class="built_in">number</span></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> a+b;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>我们声明了一个func1变量，指明了它的类型，类型中的参数端的变量名其实是没有任何意义的，不过一般我们会为了可读性而把它设为一个表意点的名字。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> func1:<span class="function">(<span class="params">base:<span class="built_in">number</span>,adder:<span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>= <span class="function"><span class="keyword">function</span> (<span class="params">a:<span class="built_in">number</span>,b:<span class="built_in">number</span></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> a+b;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h2><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>js里每个参数都是默认可选的，不传就是undefined，但是ts中如果不把参数显式声明为可选，那么参数就是必须的，一个很有意思的事情是默认值，在ts中我们的默认值传入undefined时也会启用。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function jsFunction(color: string, shape:string = 'Circle') &#123;</div><div class="line">    return `$&#123;color&#125; $&#123;shape&#125;`;</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log(jsFunction('red'));</div><div class="line">console.log(jsFunction('red',undefined));</div><div class="line">console.log(jsFunction(undefined,undefined));</div><div class="line"></div><div class="line">//red Circle</div><div class="line">//red Circle</div><div class="line">//undefined Circle</div></pre></td></tr></table></figure>
<h3 id="可选参数-1"><a href="#可选参数-1" class="headerlink" title="可选参数"></a>可选参数</h3><p>可选参数必须跟在必选参数后面，除非一个函数只有可选参数</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">//error 可选参数不能在不可选参数后面</div><div class="line">function jsFunction2(shape?:string, color: string) &#123;</div><div class="line">    return `$&#123;color&#125; $&#123;shape&#125;`;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//默认参数没有这个限制</div><div class="line">function jsFunction3(shape:string = 'Circle', color: string) &#123;</div><div class="line">    return `$&#123;color&#125; $&#123;shape&#125;`;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//默认参数在前，未传入参数情况下则必须传入undefined来激活默认值</div><div class="line">//所以推荐的写法是默认参数也写在后面</div><div class="line">jsFunction3(undefined, 'green');</div><div class="line"></div><div class="line">//It is ok!</div><div class="line">function jsFunction2(shape?:string, color？: string) &#123;</div><div class="line">    return `$&#123;color&#125; $&#123;shape&#125;`;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function jsFunction(color: string, shape?:string) &#123;</div><div class="line">    return `$&#123;color&#125; $&#123;shape&#125;`;</div><div class="line">&#125;</div><div class="line"></div><div class="line">console.log(jsFunction('red'));</div><div class="line">console.log(jsFunction('red',undefined));</div><div class="line">console.log(jsFunction(undefined,undefined));</div><div class="line"></div><div class="line">// red undefined</div><div class="line">// red undefined</div><div class="line">// undefined undefined</div></pre></td></tr></table></figure>
<h3 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h3><p>类似Java等语言，ts中也可以传入可变参数，但是叫法是剩余参数,同样的用熟悉的…来表示：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Circle &#123;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> radius: <span class="built_in">number</span>,<span class="keyword">public</span> color: <span class="built_in">string</span></span>) &#123;</div><div class="line">    &#125;</div><div class="line">    draw()&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;this.radius&#125;</span> <span class="subst">$&#123;this.color&#125;</span>`</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params">...circles:Circle[]</span>) </span>&#123;</div><div class="line">    circles.forEach(<span class="function"><span class="params">circle</span> =&gt;</span> circle.draw());</div><div class="line">&#125;</div><div class="line"></div><div class="line">draw(<span class="keyword">new</span> Circle(<span class="number">1</span>, <span class="string">'red'</span>), <span class="keyword">new</span> Circle(<span class="number">2</span>, <span class="string">'green'</span>));</div><div class="line"><span class="comment">// 1 red</span></div><div class="line"><span class="comment">// 2 green</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> myDraw:<span class="function">(<span class="params">...circles:Circle[]</span>) =&gt;</span> <span class="built_in">void</span> = draw;</div><div class="line">myDraw(<span class="keyword">new</span> Circle(<span class="number">1</span>, <span class="string">'red'</span>), <span class="keyword">new</span> Circle(<span class="number">2</span>, <span class="string">'green'</span>));</div></pre></td></tr></table></figure>
<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><h3 id="顶级层级下的非方法式调用的this绑定"><a href="#顶级层级下的非方法式调用的this绑定" class="headerlink" title="顶级层级下的非方法式调用的this绑定"></a>顶级层级下的非方法式调用的this绑定</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> deck = &#123;</div><div class="line">    suits: [<span class="string">"hearts"</span>, <span class="string">"spades"</span>, <span class="string">"clubs"</span>, <span class="string">"diamonds"</span>],</div><div class="line">    cards: <span class="built_in">Array</span>(<span class="number">52</span>),</div><div class="line">    createCardPicker: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">52</span>);</div><div class="line">            <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(pickedCard / <span class="number">13</span>);</div><div class="line"></div><div class="line">            <span class="comment">//this的指向是什么？</span></div><div class="line">            <span class="keyword">return</span> &#123;suit: <span class="keyword">this</span>.suits[pickedSuit], card: pickedCard % <span class="number">13</span>&#125;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> cardPicker = deck.createCardPicker();</div><div class="line"><span class="keyword">let</span> pickedCard = cardPicker();</div><div class="line"></div><div class="line">alert(<span class="string">"card: "</span> + pickedCard.card + <span class="string">" of "</span> + pickedCard.suit);</div></pre></td></tr></table></figure>
<p>上面这段抄来的代码中，this的指向是什么呢？实际上这里的this将绑定到window（严格模式下是undefined）,所以该段方法抛出错误，因为windows汇总并没有suits，this.suits[pickedSuit]等于对undefined来调用index参数。</p>
<h3 id="箭头函数进行this绑定"><a href="#箭头函数进行this绑定" class="headerlink" title="箭头函数进行this绑定"></a>箭头函数进行this绑定</h3><p>在箭头函数出现之前，每个新定义的函数都有它自己的 <code>this</code>值（在<strong>构造函数的情况下是一个新对象，在严格模式的函数调用中为 undefined，如果该函数被作为“对象方法”调用则为基础对象等</strong>）</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> deck = &#123;</div><div class="line">    suits: [<span class="string">"hearts"</span>, <span class="string">"spades"</span>, <span class="string">"clubs"</span>, <span class="string">"diamonds"</span>],</div><div class="line">    cards: <span class="built_in">Array</span>(<span class="number">52</span>),</div><div class="line">    createCardPicker: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="comment">// <span class="doctag">NOTE:</span> the line below is now an arrow function, allowing us to capture 'this' right here</span></div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            <span class="keyword">let</span> pickedCard = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * <span class="number">52</span>);</div><div class="line">            <span class="keyword">let</span> pickedSuit = <span class="built_in">Math</span>.floor(pickedCard / <span class="number">13</span>);</div><div class="line"></div><div class="line">            <span class="keyword">return</span> &#123;suit: <span class="keyword">this</span>.suits[pickedSuit], card: pickedCard % <span class="number">13</span>&#125;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> cardPicker = deck.createCardPicker();</div><div class="line"><span class="keyword">let</span> pickedCard = cardPicker();</div></pre></td></tr></table></figure>
<p>这段代码不会报错，箭头函数将this绑定在了deck上。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;函数类型&quot;&gt;&lt;a href=&quot;#函数类型&quot; class=&quot;headerlink&quot; title=&quot;函数类型&quot;&gt;&lt;/a&gt;函数类型&lt;/h2&gt;&lt;p&gt;一般情况下我们可以直接借助类型推到来声明一个函数变量，但是有些时候我们更倾向于写出完整的函数类型。&lt;/p&gt;
&lt;figure class=&quot;highlight typescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; func = &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;a:&lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;,b:&lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a+b;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//完整的函数类型&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; func1:&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;m:&lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;,k:&lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;= &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;a:&lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;,b:&lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a+b;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们声明了一个func1变量，指明了它的类型，类型中的参数端的变量名其实是没有任何意义的，不过一般我们会为了可读性而把它设为一个表意点的名字。&lt;/p&gt;
&lt;figure class=&quot;highlight typescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; func1:&lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;base:&lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;,adder:&lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;= &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; (&lt;span class=&quot;params&quot;&gt;a:&lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;,b:&lt;span class=&quot;built_in&quot;&gt;number&lt;/span&gt;&lt;/span&gt;) &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; a+b;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="typescript" scheme="http://yoursite.com/tags/typescript/"/>
    
      <category term="study notes" scheme="http://yoursite.com/tags/study-notes/"/>
    
  </entry>
  
  <entry>
    <title>Typescript(1):Class</title>
    <link href="http://yoursite.com/2019/03/09/Typescript-1-Class/"/>
    <id>http://yoursite.com/2019/03/09/Typescript-1-Class/</id>
    <published>2019-03-09T01:50:28.000Z</published>
    <updated>2019-03-14T12:52:50.515Z</updated>
    
    <content type="html"><![CDATA[<h3 id="结构型类型系统"><a href="#结构型类型系统" class="headerlink" title="结构型类型系统"></a>结构型类型系统</h3><p>ts中，一般情况下当我们比较两种类型时，我们实际比较的是<strong>类型的结构</strong>，即对比他们的成员类型是否都是兼容的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Food &#123;</div><div class="line">    name:<span class="built_in">string</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">foodName:<span class="built_in">string</span></span>)&#123;</div><div class="line">        <span class="keyword">this</span>.name = foodName;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Cake <span class="keyword">extends</span> Food&#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> FoodModel &#123;</div><div class="line">    name:<span class="built_in">string</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">foodName:<span class="built_in">string</span></span>)&#123;</div><div class="line">        <span class="keyword">this</span>.name = foodName;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//Food可以赋值给FoodModel</span></div><div class="line"><span class="keyword">let</span> model:FoodModel = <span class="keyword">new</span> FoodModel(<span class="string">'cake'</span>);</div><div class="line">model = <span class="keyword">new</span> Food(<span class="string">'cake'</span>);</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="private和protected"><a href="#private和protected" class="headerlink" title="private和protected"></a>private和protected</h3><p>然而当类的成员带有private和protected修饰符时情况就变得不对了，<strong>如果其中一个类型里包含一个<code>private</code>成员，那么只有当另外一个类型中也存在这样一个 <code>private</code>成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于 <code>protected</code>成员也使用这个规则。</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Food &#123;</div><div class="line">    <span class="keyword">private</span> name:<span class="built_in">string</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">foodName:<span class="built_in">string</span></span>)&#123;</div><div class="line">        <span class="keyword">this</span>.name = foodName;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Cake <span class="keyword">extends</span> Food&#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> FoodModel &#123;</div><div class="line">    <span class="keyword">private</span> name:<span class="built_in">string</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">foodName:<span class="built_in">string</span></span>)&#123;</div><div class="line">        <span class="keyword">this</span>.name = foodName;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> model:FoodModel = <span class="keyword">new</span> FoodModel(<span class="string">'cake'</span>);</div><div class="line"><span class="comment">//报错，类型不兼容</span></div><div class="line">model = <span class="keyword">new</span> Food(<span class="string">'cake'</span>);</div></pre></td></tr></table></figure>
<p>如果父类声明了一个private的成员，那么它的派生类不能再声明一个相同private成员</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Food &#123;</div><div class="line">    <span class="keyword">private</span> name:<span class="built_in">string</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">foodName:<span class="built_in">string</span></span>)&#123;</div><div class="line">        <span class="keyword">this</span>.name = foodName;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Cake <span class="keyword">extends</span> Food&#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">//报错，private的成员name不能分别定义</span></div><div class="line"><span class="keyword">class</span> FoodModel <span class="keyword">extends</span> Food&#123;</div><div class="line">    <span class="keyword">private</span> name:<span class="built_in">string</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">foodName:<span class="built_in">string</span></span>)&#123;</div><div class="line">        <span class="keyword">super</span>(foodName);</div><div class="line">        <span class="keyword">this</span>.name = foodName;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>事实上子类不能重新定义一个父类已经有的同名成员为private：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Food &#123;</div><div class="line">    name:<span class="built_in">string</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">foodName:<span class="built_in">string</span></span>)&#123;</div><div class="line">        <span class="keyword">this</span>.name = foodName;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//报错，父类有name但是不是private</span></div><div class="line"><span class="keyword">class</span> FoodModel <span class="keyword">extends</span> Food&#123;</div><div class="line">    <span class="keyword">private</span> name:<span class="built_in">string</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">foodName:<span class="built_in">string</span></span>)&#123;</div><div class="line">        <span class="keyword">super</span>(foodName);</div><div class="line">        <span class="keyword">this</span>.name = foodName;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>protected类型则不然</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Food &#123;</div><div class="line">    <span class="keyword">protected</span> name:<span class="built_in">string</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params">foodName:<span class="built_in">string</span></span>)&#123;</div><div class="line">        <span class="keyword">this</span>.name = foodName;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> FoodModel <span class="keyword">extends</span> Food&#123;</div><div class="line">    <span class="keyword">protected</span> name:<span class="built_in">string</span>;</div><div class="line">    <span class="comment">//public name:string; 这样也可以</span></div><div class="line">    <span class="keyword">constructor</span>(<span class="params">foodName:<span class="built_in">string</span></span>)&#123;</div><div class="line">        <span class="keyword">super</span>(foodName);</div><div class="line">        <span class="keyword">this</span>.name = foodName;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="语法特性"><a href="#语法特性" class="headerlink" title="语法特性"></a>语法特性</h2><h3 id="属性参数"><a href="#属性参数" class="headerlink" title="属性参数"></a>属性参数</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Person &#123;</div><div class="line">    name:<span class="built_in">string</span>;</div><div class="line">    age:<span class="built_in">number</span>;</div><div class="line"></div><div class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, age: <span class="built_in">number</span></span>) &#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的写法是我们之前见过的一个类的声明，其实我们并不需要在类的块里声明变量，然后在构造器中赋值，我们有更简单的写法，这就是属性赋值，<strong>我们可以在构造函数的参数前加上修饰符(private,public,protected,readonly)</strong>。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Person &#123;</div><div class="line">    <span class="comment">//不加修饰符的变量不会被声明为成员</span></div><div class="line">    <span class="comment">//constructor(name: string, age: number) &#123;</span></div><div class="line">    <span class="comment">//&#125;</span></div><div class="line">    </div><div class="line">    <span class="comment">//效果等同于上面的声明</span></div><div class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span>,<span class="keyword">public</span> age: <span class="built_in">number</span></span>) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> person:Person = <span class="keyword">new</span> Person(<span class="string">'sd'</span>,<span class="number">1</span>);</div><div class="line">person.name;</div></pre></td></tr></table></figure>
<h3 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h3><p>声明getter/setter方法，对于protected和private成员变量我们可能需要为其设置get/set方法，在ts中如果一个成员变量有get方法而没有set方法则默认会把它设置成readonly变量。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Panda &#123;</div><div class="line">    <span class="keyword">private</span> _weight:<span class="built_in">number</span>;</div><div class="line">    <span class="keyword">private</span> _age:<span class="built_in">number</span>;</div><div class="line"></div><div class="line">    <span class="keyword">get</span> weight(): <span class="built_in">number</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._weight;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">get</span> age(): <span class="built_in">number</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._age;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">set</span> age(value: <span class="built_in">number</span>) &#123;</div><div class="line">        <span class="keyword">this</span>._age = value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="编译后的类声明"><a href="#编译后的类声明" class="headerlink" title="编译后的类声明"></a>编译后的类声明</h2><p>ts最终会编译成浏览器可以执行的js文件，比如我们声明了以下这个类</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Person &#123;</div><div class="line">    <span class="keyword">static</span> count:<span class="built_in">number</span> = <span class="number">0</span>;</div><div class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span>,<span class="keyword">public</span> age: <span class="built_in">number</span></span>) &#123;</div><div class="line">    &#125;</div><div class="line">    sayHello()&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;this.name&#125;</span> hello!`</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//最终编译后的效果</span></div><div class="line"><span class="keyword">var</span> Person = <span class="comment">/** @class */</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.age = age;</div><div class="line">    &#125;</div><div class="line">    Person.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">"+hello"</span>);</div><div class="line">    &#125;;</div><div class="line">    Person.count = <span class="number">0</span>;</div><div class="line">    <span class="keyword">return</span> Person;</div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<p>可以看到Person被赋值成为了构造函数，我们也可以清晰的看到在闭包中声明的类的静态部分和实例部分。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//output: function</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Person);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;结构型类型系统&quot;&gt;&lt;a href=&quot;#结构型类型系统&quot; class=&quot;headerlink&quot; title=&quot;结构型类型系统&quot;&gt;&lt;/a&gt;结构型类型系统&lt;/h3&gt;&lt;p&gt;ts中，一般情况下当我们比较两种类型时，我们实际比较的是&lt;strong&gt;类型的结构&lt;/strong&gt;，即对比他们的成员类型是否都是兼容的。&lt;/p&gt;
&lt;figure class=&quot;highlight typescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; Food &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    name:&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;foodName:&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;&lt;/span&gt;)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = foodName;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; Cake &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; Food&amp;#123;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; FoodModel &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    name:&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;constructor&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;foodName:&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;&lt;/span&gt;)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.name = foodName;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//Food可以赋值给FoodModel&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; model:FoodModel = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; FoodModel(&lt;span class=&quot;string&quot;&gt;&#39;cake&#39;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;model = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Food(&lt;span class=&quot;string&quot;&gt;&#39;cake&#39;&lt;/span&gt;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="typescript" scheme="http://yoursite.com/tags/typescript/"/>
    
      <category term="study notes" scheme="http://yoursite.com/tags/study-notes/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript(0):Interface</title>
    <link href="http://yoursite.com/2019/03/08/TypeScript-0-Interface/"/>
    <id>http://yoursite.com/2019/03/08/TypeScript-0-Interface/</id>
    <published>2019-03-08T06:09:47.000Z</published>
    <updated>2019-03-14T12:52:47.382Z</updated>
    
    <content type="html"><![CDATA[<h2 id="接口如何工作？"><a href="#接口如何工作？" class="headerlink" title="接口如何工作？"></a>接口如何工作？</h2><p>下面我们声明了一个函数，它接受一个{color:string}类型的对象，那么在ts编译期间编译器如何来验证我们传入对象符合我们给定的类型呢？</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params">shape:&#123;color:<span class="built_in">string</span>&#125;</span>)</span>&#123;</div><div class="line">   <span class="built_in">console</span>.log(<span class="string">`I am a <span class="subst">$&#123;shape.color&#125;</span> shape`</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实际上ts的类型检查针对以下三点：</p>
<p>1.必须属性是否存在</p>
<p>2.类型是否匹配</p>
<p>3.对于字面量对象还会有多余的属性检查</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//报错，类型检查失败，多了一个length属性, （对于字面量还会检查是否存在不必要的属性）</span></div><div class="line">draw(&#123;color: <span class="string">'red'</span>, length: <span class="number">1</span>&#125;);</div><div class="line"></div><div class="line"><span class="comment">//类型检查成功，使用变量来跳过对字面量多余属性的检查</span></div><div class="line"><span class="keyword">let</span> shape = &#123;color: <span class="string">'red'</span>, length: <span class="number">1</span>&#125;;</div><div class="line">draw(shape);</div><div class="line"></div><div class="line"><span class="comment">//报错， 没有必要的属性</span></div><div class="line"><span class="keyword">let</span> secondShape = &#123; length: <span class="number">1</span>&#125;;</div><div class="line">draw(secondShape);</div><div class="line"></div><div class="line"><span class="comment">// Ok!</span></div><div class="line">draw(&#123;color:<span class="string">'red'</span>&#125;);</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h2><p>如果属性不是必须的我们可以把它声明为可选属性</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Shape &#123;</div><div class="line">    color?:<span class="built_in">string</span>;</div><div class="line">    id?:<span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">enhancedDraw</span>(<span class="params">shape:Shape</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">`I am a <span class="subst">$&#123;shape.color&#125;</span> shape, my id is <span class="subst">$&#123;shape.id&#125;</span>`</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//Ok！</span></div><div class="line">enhancedDraw(&#123;&#125;);</div><div class="line">enhancedDraw(&#123;color:<span class="string">'red'</span>&#125;);</div><div class="line">enhancedDraw(&#123;id:<span class="number">1</span>&#125;);</div></pre></td></tr></table></figure>
<h2 id="只读属性"><a href="#只读属性" class="headerlink" title="只读属性"></a>只读属性</h2><p>一个常用的操作是设置把属性设置为只读的，ts里面也迎合了这种需求</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//只读属性</span></div><div class="line"><span class="keyword">interface</span> Circle &#123;</div><div class="line">    readonly radius:<span class="built_in">number</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不过如果我们声明一类实现该接口，类中必须强制声明一个叫做radius的属性，但是不需要它是只读的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> RedCircle <span class="keyword">implements</span> Circle&#123;</div><div class="line">    radiu: <span class="built_in">number</span>;<span class="comment">//报错，没有声明radius</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> RedCircle <span class="keyword">implements</span> Circle&#123;</div><div class="line">    radius: <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//ok</span></div><div class="line"><span class="keyword">let</span> rc = <span class="keyword">new</span> RedCircle()</div><div class="line">rc.radius = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="comment">//Error!不能修改只读属性</span></div><div class="line"><span class="keyword">let</span> c:Circle = <span class="keyword">new</span> RedCircle()</div><div class="line">c.radius = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="keyword">let</span> circle:Circle = &#123;radius:<span class="number">1</span>&#125;;</div><div class="line"><span class="comment">//报错，不能修改只读的属性</span></div><div class="line">circle.radius = <span class="number">1</span>;</div></pre></td></tr></table></figure>
<h3 id="不可变数组"><a href="#不可变数组" class="headerlink" title="不可变数组"></a>不可变数组</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//不可变数组</span></div><div class="line"><span class="keyword">let</span> readOnlyArr:ReadonlyArray&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</div><div class="line"><span class="comment">//指针可变</span></div><div class="line">readOnlyArr = readOnlyArr.concat([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</div><div class="line"></div><div class="line"><span class="comment">//报错不能，把不可变数组赋值给普通数组</span></div><div class="line"><span class="keyword">let</span> read:<span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = readOnlyArr;</div><div class="line"></div><div class="line"><span class="comment">//Ok 类型断言</span></div><div class="line"><span class="keyword">let</span> read:<span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = readOnlyArr <span class="keyword">as</span> ReadonlyArray&lt;<span class="built_in">number</span>&gt;;</div></pre></td></tr></table></figure>
<h2 id="额外的属性检查"><a href="#额外的属性检查" class="headerlink" title="额外的属性检查"></a>额外的属性检查</h2><p>对象字面量会被特殊对待，即经过额外的属性检测：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">如果一个对象字面量存在任何“目标类型”不包含的属性时，你会得到一个错误。</div></pre></td></tr></table></figure>
<p>这一点我们已经在本文的第一节中验证过了：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extractPropsCheck</span>(<span class="params">squre:&#123;color: <span class="built_in">string</span>&#125;</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(squre.color);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 报错，特殊类型检验</span></div><div class="line">extractPropsCheck(&#123;color:<span class="string">'green'</span>, id:<span class="number">1</span>&#125;)</div></pre></td></tr></table></figure>
<p>如何绕开额外的类型检测？</p>
<p>1.类型断言：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">extractPropsCheck(&#123;color:<span class="string">'green'</span>, id:<span class="number">1</span>&#125; <span class="keyword">as</span> &#123;color:<span class="built_in">string</span>&#125;);</div></pre></td></tr></table></figure>
<p>2.赋值给一个变量(使字面量变量化)</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123;color:<span class="string">'green'</span>, id:<span class="number">1</span>&#125;;</div><div class="line">extractPropsCheck(obj);</div></pre></td></tr></table></figure>
<p>3.最佳方式添加一个字符串索引签名：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> EnhancedSquare &#123;</div><div class="line">    color:<span class="built_in">string</span>;</div><div class="line">    side?:<span class="built_in">number</span>;</div><div class="line">    [props:<span class="built_in">string</span>]:<span class="built_in">any</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">enhancedExtractPropsCheck</span>(<span class="params">enhancedSquare:EnhancedSquare</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(enhancedSquare.color);</div><div class="line">    <span class="built_in">console</span>.log(enhancedSquare.side);</div><div class="line">&#125;</div><div class="line"></div><div class="line">enhancedExtractPropsCheck(&#123;color: <span class="string">'red'</span>, width: <span class="number">1</span>, height: <span class="number">2</span>&#125;);</div></pre></td></tr></table></figure>
<h2 id="使用接口来描述函数类型"><a href="#使用接口来描述函数类型" class="headerlink" title="使用接口来描述函数类型"></a>使用接口来描述函数类型</h2><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//使用接口来描述函数类型</span></div><div class="line"><span class="keyword">interface</span> plusOperator &#123;</div><div class="line">    (a: <span class="built_in">number</span>, b: <span class="built_in">number</span>): <span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> op: plusOperator = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</div><div class="line">op = <span class="function"><span class="keyword">function</span> (<span class="params">a,b</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> a + b;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="可索引的类型"><a href="#可索引的类型" class="headerlink" title="可索引的类型"></a>可索引的类型</h2><p>索引签名描述了对象的索引类型还有相应的索引的返回值类型</p>
<p>ts支持的索引签名有<strong>字符串和数字</strong></p>
<h3 id="数字索引"><a href="#数字索引" class="headerlink" title="数字索引"></a>数字索引</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//利用索引类型声明一种boolean数组</span></div><div class="line"><span class="keyword">interface</span> BooleanArray &#123;</div><div class="line">    [props:<span class="built_in">number</span>]:<span class="built_in">boolean</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> boolArr:BooleanArray = [<span class="literal">false</span>,<span class="literal">true</span>];</div><div class="line"><span class="keyword">let</span> b:<span class="built_in">boolean</span> = boolArr[<span class="number">0</span>];</div></pre></td></tr></table></figure>
<h3 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h3><p>字符串索引签名会确保所有属性与其返回值类型相匹配</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> IDEs &#123;</div><div class="line">    eclipse:<span class="built_in">string</span>;</div><div class="line">    vs:<span class="built_in">string</span>;</div><div class="line">    idea:<span class="built_in">string</span>;</div><div class="line">    [others:<span class="built_in">string</span>]:<span class="built_in">string</span>;</div><div class="line">    <span class="comment">//报错，不是string类型</span></div><div class="line">    <span class="comment">// myeclipase:number;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="混合索引"><a href="#混合索引" class="headerlink" title="混合索引"></a>混合索引</h3><p>我们可以同时使用数字和字符串两种索引类型，但是<strong>数字索引的返回值必须是字符串索引返回值的子类型</strong>，这种限制产生的原因是用number来进行索引时，js会将其转化为string在去索引对象。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Animal &#123;</div><div class="line">    sound:<span class="built_in">string</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Tiger <span class="keyword">extends</span> Animal&#123;</div><div class="line">    attackPower:<span class="built_in">number</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">interface</span> Zoo &#123;</div><div class="line">    [someThing:<span class="built_in">number</span>]:Tiger;</div><div class="line">    [ceatainThing:<span class="built_in">string</span>]:Animal;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//报错，数字索引的返回值必须是字符串索引返回值的子类型</span></div><div class="line"><span class="comment">// interface Zoo &#123;</span></div><div class="line"><span class="comment">//     [someThing:number]:Animal;</span></div><div class="line"><span class="comment">//     [ceatainThing:string]:Tiger;</span></div><div class="line"><span class="comment">// &#125;</span></div></pre></td></tr></table></figure>
<h3 id="只读的索引签名"><a href="#只读的索引签名" class="headerlink" title="只读的索引签名"></a>只读的索引签名</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//只读的索引签名</span></div><div class="line"><span class="keyword">interface</span> ReadonlyBooleanMap &#123;</div><div class="line">    readonly [key:<span class="built_in">string</span>]:<span class="built_in">boolean</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> osSupportMap:ReadonlyBooleanMap = &#123;</div><div class="line">    windows: <span class="literal">false</span>,</div><div class="line">    linux: <span class="literal">true</span>,</div><div class="line">    unix: <span class="literal">false</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 报错，只读索引的指向不能被改变</span></div><div class="line"><span class="comment">// osSupportMap['windows'] = true;</span></div></pre></td></tr></table></figure>
<h3 id="混合类型"><a href="#混合类型" class="headerlink" title="混合类型"></a>混合类型</h3><p>有时我们希望一个对象可以同时作为函数和对象使用</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">interface</span> Counter &#123;</div><div class="line">    (start: <span class="built_in">number</span>): <span class="built_in">string</span>;</div><div class="line">    interval: <span class="built_in">number</span>;</div><div class="line">    reset(): <span class="built_in">void</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCounter</span>(<span class="params"></span>): <span class="title">Counter</span> </span>&#123;</div><div class="line">    <span class="keyword">let</span> counter = &lt;Counter&gt;<span class="function"><span class="keyword">function</span> (<span class="params">start: <span class="built_in">number</span></span>) </span>&#123; &#125;;</div><div class="line">    counter.interval = <span class="number">123</span>;</div><div class="line">    counter.reset = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; &#125;;</div><div class="line">    <span class="keyword">return</span> counter;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> c = getCounter();</div><div class="line">c(<span class="number">10</span>);</div><div class="line">c.reset();</div><div class="line">c.interval = <span class="number">5.0</span>;</div></pre></td></tr></table></figure>
<h3 id="接口集成类"><a href="#接口集成类" class="headerlink" title="接口集成类"></a>接口集成类</h3><p>接口可以继承一个类，此时接口将包括这个类所有成员的声明，不管他们的访问域如何！</p>
<p><strong>如果一个接口继承了一个有private或者protected成员的类，那么该接口类型只能被这个类或者其子类实现</strong>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Control &#123;</div><div class="line">    <span class="keyword">private</span> state: <span class="built_in">any</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">interface</span> SelectableControl <span class="keyword">extends</span> Control &#123;</div><div class="line">    select(): <span class="built_in">void</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Button <span class="keyword">extends</span> Control <span class="keyword">implements</span> SelectableControl &#123;</div><div class="line">    select() &#123; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> TextBox <span class="keyword">extends</span> Control &#123;</div><div class="line">    select() &#123; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 错误：“Image”类型缺少“state”属性。</span></div><div class="line"><span class="keyword">class</span> Image <span class="keyword">implements</span> SelectableControl &#123;</div><div class="line">    select() &#123; &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Location &#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;接口如何工作？&quot;&gt;&lt;a href=&quot;#接口如何工作？&quot; class=&quot;headerlink&quot; title=&quot;接口如何工作？&quot;&gt;&lt;/a&gt;接口如何工作？&lt;/h2&gt;&lt;p&gt;下面我们声明了一个函数，它接受一个{color:string}类型的对象，那么在ts编译期间编译器如何来验证我们传入对象符合我们给定的类型呢？&lt;/p&gt;
&lt;figure class=&quot;highlight typescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;draw&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;shape:&amp;#123;color:&lt;span class=&quot;built_in&quot;&gt;string&lt;/span&gt;&amp;#125;&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(&lt;span class=&quot;string&quot;&gt;`I am a &lt;span class=&quot;subst&quot;&gt;$&amp;#123;shape.color&amp;#125;&lt;/span&gt; shape`&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;实际上ts的类型检查针对以下三点：&lt;/p&gt;
&lt;p&gt;1.必须属性是否存在&lt;/p&gt;
&lt;p&gt;2.类型是否匹配&lt;/p&gt;
&lt;p&gt;3.对于字面量对象还会有多余的属性检查&lt;/p&gt;
&lt;figure class=&quot;highlight typescript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//报错，类型检查失败，多了一个length属性, （对于字面量还会检查是否存在不必要的属性）&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;draw(&amp;#123;color: &lt;span class=&quot;string&quot;&gt;&#39;red&#39;&lt;/span&gt;, length: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//类型检查成功，使用变量来跳过对字面量多余属性的检查&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; shape = &amp;#123;color: &lt;span class=&quot;string&quot;&gt;&#39;red&#39;&lt;/span&gt;, length: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;draw(shape);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//报错， 没有必要的属性&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; secondShape = &amp;#123; length: &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;draw(secondShape);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// Ok!&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;draw(&amp;#123;color:&lt;span class=&quot;string&quot;&gt;&#39;red&#39;&lt;/span&gt;&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="typescript" scheme="http://yoursite.com/tags/typescript/"/>
    
      <category term="study notes" scheme="http://yoursite.com/tags/study-notes/"/>
    
  </entry>
  
  <entry>
    <title>ElasticSearch(1):Base knowledge</title>
    <link href="http://yoursite.com/2018/11/18/ElasticSearch-1-Base-knowledge/"/>
    <id>http://yoursite.com/2018/11/18/ElasticSearch-1-Base-knowledge/</id>
    <published>2018-11-18T12:34:06.000Z</published>
    <updated>2019-03-07T14:01:51.954Z</updated>
    
    <content type="html"><![CDATA[<p>es是一个开源搜索引擎，其建立在,lucene上提供了一系列非常直观好用的restful api接口，以及分布式方案，用es的这些提供物，你不在需要写一个java程序去访问lucene，你也不再需要依赖其他的集群方案去建立并思考如何管理一个lucene集群，es是一套非常优秀的拿来即用的工具，一个天生的分布式的软件。</p>
<a id="more"></a>
<h2 id="es集群的简单介绍"><a href="#es集群的简单介绍" class="headerlink" title="es集群的简单介绍"></a>es集群的简单介绍</h2><p>一个运行中的es实例，即是一个节点，es集群由多个cluster.name相同的节点组合而成，<strong>es集群一旦得知新节点的加入或者旧节点被移除，就会重新平均分配节点中的所有数据</strong>。</p>
<p>一个es集群会选举产生<strong>主节点</strong>，<strong>主节点负责管理集群范围内所有的变更</strong>，如增删索引或者节点，但是主节点<strong>不负责文档级别的变更或者搜索</strong>，这个特性使得对文档的变更和搜索的性能不是由主节点的数量或者性能来决定的。</p>
<p>es集群中<strong>任何节点都知道任意文档所处的位置</strong>，它们能够将我们的实际请求转发到存储我们的目标文档的节点上，所以我们不关心我们的请求发到的是哪个节点，因为任何节点都能给予我们正确的响应。</p>
<p>一个简单而重要的es api是查看集群的当前的健康状况</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">//GET _cluster/health</div><div class="line"></div><div class="line">&#123;</div><div class="line">  "cluster_name": "docker-cluster",</div><div class="line">  "status": "yellow",</div><div class="line">  "timed_out": false,</div><div class="line">  "number_of_nodes": 1,</div><div class="line">  "number_of_data_nodes": 1,</div><div class="line">  "active_primary_shards": 21,</div><div class="line">  "active_shards": 21,</div><div class="line">  "relocating_shards": 0,</div><div class="line">  "initializing_shards": 0,</div><div class="line">  "unassigned_shards": 20,</div><div class="line">  "delayed_unassigned_shards": 0,</div><div class="line">  "number_of_pending_tasks": 0,</div><div class="line">  "number_of_in_flight_fetch": 0,</div><div class="line">  "task_max_waiting_in_queue_millis": 0,</div><div class="line">  "active_shards_percent_as_number": 51.21951219512195</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到我的es集群的状态是yellow，这表示所有<strong>主分片</strong>都正常运行但是<strong>副本分片</strong>却存在没有正常运行的情况，一般来说这里是应该是green,即主分片和副本分片都正常运行，而如果是red则代表了有主分片没有正常运行。</p>
<p>我们的es集群状态为yellow是因为我们只有一个节点，这意味着所有的主分片和副本分片都在同一个节点上，这表示我们的副本毫无意义，因为这个节点挂了，主副数据都挂了，完全只是浪费空间，所以是黄色，unassigned_shards为20说明了这一点。</p>
<p>要了解<strong>分片</strong>是什么，首先我们想要知道索引，索引是在es中保存相关数据的地方，实际上它是<strong>指向对个物理分片的逻辑命名空间</strong>，而一个分片则是一个底层的工作单元，一个分片实际上就是一个lucene实例，因此本身就是一个完整的搜索引擎，我们的文档被存储和索引到分片内，然而外部的应用并不关心分片这个东西，我们直接与索引打交道。<strong>分片只是数据的容器，而它们被分散在集群中的各个节点里</strong>，一旦集群规模发生改变，es会迁移各节点中的分片，使得数据仍然均匀的分布在集群中。</p>
<p>从细节上来说，主分片的数目决定了索引能够保存的最大数据量，因为任何文档都会存在于一个主分片。</p>
<p>我们可以在建立索引时决定其分片数量，当然它也有默认值</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//PUT /cars</div><div class="line">&#123;</div><div class="line">   "settings" : &#123;</div><div class="line">      "number_of_shards" : 3,</div><div class="line">      "number_of_replicas" : 1</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于节点来说，一个节点中的分片数越少，则单个分片所分到的资源更多，单个分片的性能也就更好，<strong>写操作只能由主分片来处理</strong>，但是读操作则主副分片都可以处理，更多的副分片一方面可以保证更高的可靠性，另一方面则可以提高吞吐量。以下面的方式可以来增加我们的副分片数量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//PUT /cars/_settings</span></div><div class="line">&#123;</div><div class="line">   <span class="string">"number_of_replicas"</span> : <span class="number">2</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们的集群一开始有多个节点，然后你关闭了其中一个，然后又打开它，es会尝试重用之前的数据，并用自己的新数据去同步之前的老数据。</p>
<h2 id="文档的分布式存储"><a href="#文档的分布式存储" class="headerlink" title="文档的分布式存储"></a>文档的分布式存储</h2><p>文档是es中的最小的存储单位，我们存储文档时通常要指定其索引和类型，那么es最终会如何选择相应的分片存储这个被索引的文档呢？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">shard = hash(routing) % number_of_primary_shards</div></pre></td></tr></table></figure>
<p>实际上有上面这个公式，默认的routing是文档的_id，我们也可以自定义routing，实际上所有的文档api,如bulk，update等等都接受一个名为routing的参数。</p>
<h3 id="单文档操作"><a href="#单文档操作" class="headerlink" title="单文档操作"></a>单文档操作</h3><p>一般来说我们进行文档操作，会通过以下的步骤</p>
<p>1.请求到某个节点（称作协调节点），该节点会通过_id来确定文档属于哪个分片（routing）。</p>
<p>2.如果参数是增删改的，那么请求会被转发到这个分片的主分片</p>
<p>3.主分片执行请求中的操作，如果成功则<strong>并行</strong>转发到副本分片上，所有的副本分片会执行同样的请求，并向主分片报道成功。</p>
<p>4.主分片接到所有副本分片的成功报道，会向协调节点报告成功</p>
<p>5.协调节点接到主分片的成功报道，转而向客户端报道操作成功</p>
<p>如果第2步是一个查询操作，则协调节点会以自己的负载均衡方式（一般是轮询）来选择一个分片，但是这里可能会存在主分片有数据，而副分片还没有数据的情况，这时可能会报道查不到文档。</p>
<p>如果第2步是一个局部更新操作，则主分区会在局部更新完成后重新索引这个文档，如果它发现文档被更改，则会从新执行更新，然后再查询，如果还发现被更改则再重复执行更新和查询操作，直到达到指定的retry_on_conflict次数后，才会放弃，这是为了保证一致性。另外：当主分片把更改转发到副本分片时， 它不会转发更新请求。 相反，<strong>它转发完整文档的新版本</strong>。请记住，这些更改将会异步转发到副本分片，并且不能保证它们以发送它们相同的顺序到达。 如果es仅转发更改请求，则可能以错误的顺序应用更改，导致得到损坏的文档</p>
<h3 id="多文档操作"><a href="#多文档操作" class="headerlink" title="多文档操作"></a>多文档操作</h3><p>在用mget和bulk操作时，情况大致相同，只不过协同服务器会将请求给多个分片,并等待多个分片的响应信息。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;es是一个开源搜索引擎，其建立在,lucene上提供了一系列非常直观好用的restful api接口，以及分布式方案，用es的这些提供物，你不在需要写一个java程序去访问lucene，你也不再需要依赖其他的集群方案去建立并思考如何管理一个lucene集群，es是一套非常优秀的拿来即用的工具，一个天生的分布式的软件。&lt;/p&gt;
    
    </summary>
    
    
      <category term="-ElasticSearch" scheme="http://yoursite.com/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>React(5):HOC</title>
    <link href="http://yoursite.com/2018/10/11/React-5-HOC/"/>
    <id>http://yoursite.com/2018/10/11/React-5-HOC/</id>
    <published>2018-10-11T06:35:28.000Z</published>
    <updated>2018-10-11T07:55:38.356Z</updated>
    
    <content type="html"><![CDATA[<p>联系高阶函数概念，高阶组件是指接受一个组件返回一个组件的<strong>函数</strong>。它常用来分离组件的通用逻辑，可看作是装饰器模式的一种应用。</p>
<p><strong>注意：高阶组件并不是组件，而是函数</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myHOC</span>(<span class="params">WrappedComponent</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</div><div class="line">        render()&#123;</div><div class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125;/&gt;</span></span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>既然高阶组件是函数，那么js函数中有的性质它都有，高阶组件并不一定是只能有一个参数的单个参数列表，我们可以给它传入多个参数，定义多个参数列表，柯里化等等都没有问题。</p>
<a id="more"></a>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myHOC</span> = (<span class="params">data</span>) =&gt; (<span class="params">WrappedComponent</span>) =&gt; </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</div><div class="line">    	construct(props)&#123;</div><div class="line">            <span class="keyword">super</span>(props)</div><div class="line">            <span class="keyword">this</span>.setState(&#123;data&#125;)</div><div class="line">    	&#125;</div><div class="line">        render()&#123;</div><div class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125;/&gt;</span></span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function Mycomponent(props)&#123;</div><div class="line"> 	return <span class="tag">&lt;<span class="name">div</span> /&gt;</span>   </div><div class="line">&#125;</div><div class="line"></div><div class="line">const hoc = myHOC(&#123;name:"Saul"&#125;)(Mycomponent)</div></pre></td></tr></table></figure>
<p><strong>劫持渲染</strong></p>
<p>有事我们可能要根据props或者状态来判断组件是不是能够被渲染，或者是不是要转换为其他的表现形式，比如下面，我们判断组件是不是应该被构造</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">judgePaintComponent</span>(<span class="params">WrappedComponent</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">WrappedComponent</span></span>&#123;</div><div class="line">        render()&#123;</div><div class="line">        	<span class="keyword">if</span>(<span class="keyword">this</span>.props.paint)</div><div class="line">        		<span class="keyword">return</span> <span class="keyword">super</span>.render();</div><div class="line">        	<span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最佳实践</p>
<p>1.高阶组件采用统一的名称，比如把被包装组件的名称显示加入到高阶组件名称，如：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">withStudentList</span>(<span class="params">students</span>)</span>&#123;</div><div class="line">    <span class="comment">//...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2.高阶组件每次都会返回一个新的组件，所以最好不要再render和组件的声明周期函数中使用，因为这些函数经常被调用，所以非常消耗空间，又消耗时间（前一次组件被卸载）。</p>
<p>3.高阶组件生成的新组件不会包含被包装组件的静态方法，开发者需要手动复制</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Wrapped.staticMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myHOC</span>(<span class="params">WrappedComponent</span>)</span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">newComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</div><div class="line">        render()&#123;</div><div class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125;/&gt;</span></span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    //手动复制</div><div class="line">    newComponent.staticMethod = WrappedComponent.staticMethod;</div><div class="line">    return newComponent;</div><div class="line">&#125;</div><div class="line"></div><div class="line"> const mycomponent = myHOC(Wrapped);</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;联系高阶函数概念，高阶组件是指接受一个组件返回一个组件的&lt;strong&gt;函数&lt;/strong&gt;。它常用来分离组件的通用逻辑，可看作是装饰器模式的一种应用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：高阶组件并不是组件，而是函数&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight jsx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;myHOC&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;WrappedComponent&lt;/span&gt;)&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;React&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;Component&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        render()&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;WrappedComponent&lt;/span&gt; &amp;#123;&lt;span class=&quot;attr&quot;&gt;...this.props&lt;/span&gt;&amp;#125;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;既然高阶组件是函数，那么js函数中有的性质它都有，高阶组件并不一定是只能有一个参数的单个参数列表，我们可以给它传入多个参数，定义多个参数列表，柯里化等等都没有问题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React(4):Communication way of Component</title>
    <link href="http://yoursite.com/2018/10/10/Communication-way-of-Component/"/>
    <id>http://yoursite.com/2018/10/10/Communication-way-of-Component/</id>
    <published>2018-10-10T09:59:51.000Z</published>
    <updated>2018-10-11T04:45:28.499Z</updated>
    
    <content type="html"><![CDATA[<p>  单独的组件几乎没什么意义，一个真实的UI界面是由多个组件打起来的，而这些组件部分又与服务器通信得到数据，更改自身的state进行渲染，组件之间也有通信方式，比如父组件就通过props把数据传给子组件进行渲染，以至于整个界面“活”了起来。</p>
<a id="more"></a>
<h2 id="组件与服务器通信"><a href="#组件与服务器通信" class="headerlink" title="组件与服务器通信"></a>组件与服务器通信</h2><p>考虑通信问题，在明确怎么通信和在哪通信两个点，我们在<a href="http://saul.xin/2018/10/09/react-2-Component/" target="_blank" rel="external">前一篇文章</a>中介绍了组件的生命周期方法，组件的生命周期方法覆盖了整个组件的生命周期，在哪通信实际上就是选择合适的生命周期方法来通信。</p>
<p>首先是<strong>挂载阶段</strong>的通信：</p>
<p>挂载阶段有下面的方法：</p>
<p><code>constructor -&gt; componentWillMount -&gt; render -&gt; componentDidMount</code></p>
<p>首先我们排除两个特定的方法，构造器和render，虽然你可以在里面写通信代码但是这样做显然有背与该方法的自身定义的作用，并且你在render里写的话严重影响程序效率，因为这个方法很多时候都会被调用。</p>
<p>余下的方法里，一般我们选择componentDidMount，此时组件已经挂载，它能保证DOM操作是安全的。且如果组件在服务器端渲染，componentWillMount会被调用两次（服务器端一次，浏览器端一次）。</p>
<p><strong>更新阶段的通信</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">componentWillReceiveProps -&gt; shouldComponentUpdate -&gt; componentWillUpdate -&gt; render -&gt; componentDidUpdate</div></pre></td></tr></table></figure>
<p>组件更新阶段常常需要从服务器获取最新数据，这很容易理解，比如组件向服务器发送请求有一个参数来自于props的一个属性,那么props的这个属性发生改变时，理应从新请求服务器数据。</p>
<p>这样结果就很清楚了，<code>componentWillReceiveProps(nextProps)</code>用来做更新时的服务器通信再好不过,并且在实际请求前可以先对比nextProps和当前的props，确定请求依赖的属性有变化，再发送请求。</p>
<h3 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h3><h3 id="父子通信"><a href="#父子通信" class="headerlink" title="父子通信"></a>父子通信</h3><p>父子组件通信在React应用中是常有的情况，父子组件通信主要依赖于props，父组件向子组件传递props比较简单，子组件向父组件通信时，需要依赖于父组件传入的回调函数。</p>
<h3 id="兄弟通信"><a href="#兄弟通信" class="headerlink" title="兄弟通信"></a>兄弟通信</h3><p>另外兄弟组件之间也是可以通信的，这里的兄弟和树形兄弟不同，你可以认为如果他们有同一个祖先，那么他们就是兄弟组件，并不一定是处于相同的层级。</p>
<p>兄弟组件间不能够直接通信，一般来说要把这些组件需要共享的状态放到离他们最近的祖先中，然后通过父组件传递来的回调函数去改变这些共享状态。</p>
<h3 id="使用上下文-不推荐使用"><a href="#使用上下文-不推荐使用" class="headerlink" title="使用上下文(不推荐使用)"></a>使用上下文(不推荐使用)</h3><p>祖先往子孙传递上下文需要经过多个层级操作，这样会很麻烦，React提供了一个<strong>试用性的功能</strong>，即提供了一个context，不过要用这个功能必须在提供context的组件内新增一个getChildContext方法，并且还要在组件的childContextTypes属性上定义context对象的属性的类型信息。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span></span>&#123;</div><div class="line">	<span class="comment">//...</span></div><div class="line">	getChildContext()&#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            <span class="attr">onAction</span>: <span class="keyword">this</span>.handleMethod</div><div class="line">        &#125;;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">Container.childContextTypes = &#123;</div><div class="line">    <span class="attr">onAction</span>: PropTypes.func</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在子组件中可以通过[this.context.属性名]来获取到提供context组件中所传入的对象。子组件也需要声明context的属性类型：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">SubElement.contextTypes = &#123;</div><div class="line">    <span class="attr">onAddUser</span>: propTypes.func</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  单独的组件几乎没什么意义，一个真实的UI界面是由多个组件打起来的，而这些组件部分又与服务器通信得到数据，更改自身的state进行渲染，组件之间也有通信方式，比如父组件就通过props把数据传给子组件进行渲染，以至于整个界面“活”了起来。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React(3):More details of component</title>
    <link href="http://yoursite.com/2018/10/10/React-3-More-details-of-component/"/>
    <id>http://yoursite.com/2018/10/10/React-3-More-details-of-component/</id>
    <published>2018-10-10T00:36:20.000Z</published>
    <updated>2018-10-11T06:34:05.669Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Key属性"><a href="#Key属性" class="headerlink" title="Key属性"></a>Key属性</h2><p>React用Key来标记列表中的每一个元素，通过查看key是否改变来知道哪些元素需要重新渲染，这样就节省了渲染时间，毕竟一个列表中有时包含太多元素。<strong>因此要避免使用索引值作为key</strong>,因为索引可能很容易会被改变，比如增加或者删除列表元素时。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;ul&gt;</div><div class="line">	&lt;li key = "one"&gt;one&lt;/li&gt;</div><div class="line">	&lt;li key = "two"&gt;two&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line"></div><div class="line">//changed</div><div class="line">&lt;ul&gt;</div><div class="line">    &lt;li key = "three"&gt;three&lt;/li&gt;</div><div class="line">	&lt;li key = "one"&gt;one&lt;/li&gt;</div><div class="line">	&lt;li key = "two"&gt;two&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure>
<p>上面这种情况发生时，因为key的存在，react会知道one和two两个项根本没变，所以会直接在one的前面插入一个three。</p>
<p><strong>另外，key是一个在同列表下不能重复的属性。</strong></p>
<a id="more"></a>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p><strong>React中的事件要采用驼峰命名法</strong>，处理事件的<strong>响应函数要以对象形式赋值给事件属性</strong>。并且因为React事件是合成事件，所以不能通过返回false来阻止事件的默认行为，而<strong>必须显示的调用preventDefault来阻止</strong>，另外可以通过事件对象的nativeEvent属性来获取DOM原生事件。</p>
<p><strong>es6 class并不会自动绑定this到当前对象，所以开发者在某些形式下需要手动绑定。</strong></p>
<h3 id="箭头函数来定义事件"><a href="#箭头函数来定义事件" class="headerlink" title="箭头函数来定义事件"></a>箭头函数来定义事件</h3><p>如果用<code>{(index) =&gt; alert(index + &quot;:&quot; + this.props.name)}</code>这样的lambda形式来定义事件,因为箭头函数的this总是指向函数定义的对象，所以这里的对象就是当前组件的实例。</p>
<p>但是这样有一个缺点，就是如果箭头函数在render中定义，那么每次render时都会创建一个新的处理函数对象，虽然一般情况下这点消耗是可以忽略的，如果组件层级比较低，那么这样的消耗就比较大了。</p>
<h3 id="直接绑定组件方法"><a href="#直接绑定组件方法" class="headerlink" title="直接绑定组件方法"></a>直接绑定组件方法</h3><figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(props)&#123;</div><div class="line">        <span class="keyword">super</span>(props);</div><div class="line">        <span class="comment">//绑定指向</span></div><div class="line">        <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    handleClick(event)&#123;</div><div class="line">        alert(<span class="string">"hello"</span>+<span class="keyword">this</span>.props.whose)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span></span></div><div class="line">                &#123;this.props.whose&#125; Button</div><div class="line">            <span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这种方式在构造函数中为后面用到的事件处理函数绑定了this的指向。如果你的事件处理函数里根本没有用到this，那不绑定也可以，但是一般不会出现这种没用到this的事件处理函数。</p>
<p>有些人觉得构造函数中用的那种绑定模板代码比较繁琐，会用下面的方式直接在事件声明时绑定this指针的指向。不过bind会返回一个新的对象，这样的话相当于每次render调用时还是创建了一个新的对象。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">        <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick.bind(this)&#125;</span>&gt;</span></span></div><div class="line">            &#123;this.props.whose&#125; Button</div><div class="line">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">    );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="属性初始化语法"><a href="#属性初始化语法" class="headerlink" title="属性初始化语法"></a>属性初始化语法</h3><p>这是一个试验阶段的特性，默认不支持，不过create-react-app手脚架默认是支持的，在其他项目中可能需要引入transform-class-properties插件获取这个特性支持。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(props)&#123;</div><div class="line">        <span class="keyword">super</span>(props);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    handleClick = <span class="function">(<span class="params">event</span>) =&gt;</span>&#123;</div><div class="line">        alert(<span class="string">"hello"</span>+<span class="keyword">this</span>.props.whose)</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span></span></div><div class="line">                &#123;this.props.whose&#125; Button</div><div class="line">            <span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="受控和非受控组件"><a href="#受控和非受控组件" class="headerlink" title="受控和非受控组件"></a>受控和非受控组件</h2><p>某些元素自身维护了一些状态，比如很多表单元素维护着自身的输入和显示内容，React组件的状态只能通state来管理，这些状态不被React来控制的元素，即是非受控元素。</p>
<h3 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h3><p>那么为了达成这种控制，React引入了受控组件概念，如果一个表单元素的值是由React来管理的那么它就是一个受控组件，这样做的目的是为了保证state是界面上所有元素状态的唯一来源。</p>
<p><strong>text/password/textarea:</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyForm</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="keyword">constructor</span>(props)&#123;</div><div class="line">        <span class="keyword">super</span>(props);</div><div class="line">        <span class="keyword">this</span>.handleChange = <span class="keyword">this</span>.handleChange.bind(<span class="keyword">this</span>);</div><div class="line">        <span class="keyword">this</span>.state = &#123;<span class="attr">username</span>:<span class="string">''</span>, <span class="attr">password</span>: <span class="string">''</span>&#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            &lt;form&gt;</div><div class="line">                &lt;input name = "username" type="text" onChange=&#123;this.handleChange&#125; value=&#123;this.state.username&#125;/&gt;</div><div class="line">                &lt;input name = "password" type="password" onChange=&#123;this.handleChange&#125; value=&#123;this.state.password&#125;/&gt;</div><div class="line">            &lt;/form&gt;</div><div class="line">        );</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    handleChange(event) &#123;</div><div class="line">        this.setState(&#123;[event.target.name]: event.target.value&#125;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">export default MyForm;</div></pre></td></tr></table></figure>
<p>上面的代码展示了React如何控制表单元素的状态，在父组件的render函数中我们将表单元素的value与父组件的state绑定，然后定义onChange函数，它在受控组件被改变时触发，每次都更新我们的state,以至于视图能够重新渲染，通过state来作为唯一状态源的目的就此达到，如果你把handleChange中的setState注释掉，表单的input元素不能被输入。</p>
<p>其他表单元素也类似，只不过是受控属性有些不同：</p>
<p><strong>select:</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//通过设置option的value来选择</div><div class="line">&lt;select value = &#123;this.state.value&#125; onChange = &#123;this.handleChange&#125;&gt;</div><div class="line">	&lt;option value = "react"&gt;React&lt;/option&gt;</div><div class="line">	&lt;option value = "vue"&gt;Vue&lt;/option&gt;</div><div class="line">&lt;/select&gt;</div></pre></td></tr></table></figure>
<p><strong>checkbox/radio:</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">this.state = &#123;</div><div class="line">	vue : false,</div><div class="line">	react : false,</div><div class="line">	angluar :false</div><div class="line">&#125;</div><div class="line">*/</div><div class="line">&lt;input type = <span class="string">"checkbox"</span> name = <span class="string">"react"</span> value = <span class="string">"react"</span> checked =&#123;<span class="keyword">this</span>.state.react&#125; onchanged = &#123;<span class="keyword">this</span>.handleChange&#125; /&gt;</div><div class="line">&lt;input type = "checkbox" name = "vue" value = "vue" checked =&#123;this.state.vue&#125; onchanged = &#123;this.handleChange&#125; /&gt;</div><div class="line">&lt;input type = "checkbox" name = "angluar" value = "angluar" checked =&#123;this.state.angluar&#125; onchanged = &#123;this.handleChange&#125; /&gt;</div></pre></td></tr></table></figure>
<h3 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h3><p>定义受控组件的过程异常繁琐，如果一个表单中有大量元素，那么声明将会变得很复杂。</p>
<p>我们能不能采用非受控组件呢?如果采用非受控组件会存在一些问题，<strong>如何获取到表单元素的值？</strong>，为了解决这个问题React中提供了一个特殊的属性ref，这个属性用来应用React组件或DOM元素的实例。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;input name = <span class="string">"username"</span> type=<span class="string">"text"</span> ref=&#123;(input) =&gt; <span class="keyword">this</span>.input = input&#125; defaultValue = <span class="string">"something"</span>/&gt;</div></pre></td></tr></table></figure>
<p>这里我们利用ref属性，其中传入的input是当前的表单元素，利用ref我们把input赋值给了this.input，那么在组件的其他地方我们就能够通过this.input来访问这个元素。如果一个表单元素需要默认值，但是我们知道value属性是React没办法控制的，因此我们一般用defaultValue来指定属性的默认值。如果你直接用value指定你会发现输入框有值但是无法被改变。另外其他表单元素，如checkbox，等等都有类似的属性来设置默认值，但是这种方法破坏了React状态管理的一致性，不建议使用，所以一般我们还是通过之前的方法去声明受控组件。</p>
<h2 id="设计State"><a href="#设计State" class="headerlink" title="设计State"></a>设计State</h2><h3 id="小而完整的state"><a href="#小而完整的state" class="headerlink" title="小而完整的state"></a>小而完整的state</h3><p><strong>state最佳实践是一个最小但最完整的状态集</strong></p>
<p>完整：<strong>这个状态集必须能代表一个组件UI的呈现</strong>，换句话说UI的任何改变都能够通过state的变化反应出来。</p>
<p>最小：<strong>所有状态都用于反应UI变化，没有任何冗余</strong>，且没有通过其他状态计算出来的状态。（比如一个订单的订单金额，可以通过各项计算出来，那么它不应该为一个totalPrice状态）</p>
<p>一个完整的状态集中的数据有两类：</p>
<p>渲染组件使用的数据：比如学生的姓名</p>
<p>判断UI展现形式的依据：比如是否展示，怎么对齐等等</p>
<h3 id="普通属性"><a href="#普通属性" class="headerlink" title="普通属性"></a>普通属性</h3><p>React我们以props和state来定义组件UI，本质上它们是Component class的属性，我们只是继承了这个类（函数组件除外），有些属性，比如定时器之类的与UI的渲染无关，我们不应该把其定义为props或者state,我们直接用<code>this.属性名</code>这种方式来定义，一般来说组件的render方法中没有用到的属性都应该定义为普通属性。</p>
<h3 id="区分props和state"><a href="#区分props和state" class="headerlink" title="区分props和state"></a>区分props和state</h3><p>props是一个对外的属性，对组件本身他是不可变的，一般由父组件中传入，而state是一个对内的属性，组件通过改变它来改变UI的渲染。定义影响UI的数据时应该参照这两条，以及上面的<code>普通属性</code>和<code>小而完整的state</code>的说法来确定一个数据到底应该存在state对象里还是props对象里。</p>
<p>对于state有些点是要注意的：</p>
<p>1.首先state必须通过调用setState来改变，利用<code>this.state.name = &quot;saul&quot;</code>这种方式来改变并不会触发render。</p>
<p>2.state的<strong>更新是异步</strong>的，setState只是把要修改的状态放入一个队列，等待时机再修改，从componentWillReceiveProps中调用setState并不能立刻更新就可以略知一二，并且React可能会将多次状态修改合并成一次，<strong>有意思的是props的更新也是异步的，对于它们你都不能指望用前面的状态来计算出后面的状态。</strong></p>
<p><code>this.setState({count: this.state.count + 1})</code></p>
<p>相当于合并操作：</p>
<p><code>Object.assign({}, this.state, { count: this.state.count + 1 });</code></p>
<p>不过setState提供了另一种形式的调用，即传入一个函数</p>
<p><code>setState((preState,props)=&gt;({counter:preState.count + 1}))</code></p>
<p>这个方法用来处理异步更新，React 会把我们更新 state 的函数加入到一个队列里面，然后，按照函数的顺序依次调用，这样就能够保证顺序了，其中preState是更新前的状态,props是组件当前的props。</p>
<p>3.state的更新是一个合并过程</p>
<p>4.最佳实践:把state当做不可变对象</p>
<p>状态类型是数组：</p>
<p>用数组的concat,slice和mapreduce方法，或es6扩展语法<code>[...perState.persons,&quot;Tom&quot;]</code>，不要用push,pop,shift,unshift,splice等方法。</p>
<p>状态类型是普通对象：</p>
<p>es6扩展语法：</p>
<p><code>{...perState.person,name:&#39;Tom&#39;}</code></p>
<p>es6的Object.assign方法：</p>
<p><code>Object.assign({},preState.person,{name:&#39;Tom&#39;})</code></p>
<p>使用不可变对象，能够带来一些比较判断上的好处，比如直接比较引用而不需要比较内容，另外引入诸如Immutable之类的库，也可以方便我们创建不可变对象。</p>
<h2 id="Ref属性"><a href="#Ref属性" class="headerlink" title="Ref属性"></a>Ref属性</h2><p>在<a href="http://saul.xin/2018/10/10/React-3-More-details-of-component/#%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6" target="_blank" rel="external">非受控组件</a>中介绍了一个叫做ref的属性，一般来说这个属性是不应该使用的，因为它破坏了React的典型数据流。</p>
<p>下面复现一下我们如何定义非受控组件</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;input name = <span class="string">"username"</span> type=<span class="string">"text"</span> ref=&#123;(input) =&gt; <span class="keyword">this</span>.input = input&#125; defaultValue = <span class="string">"something"</span>/&gt;</div></pre></td></tr></table></figure>
<p>上面的这种定义方式，ref接受了一个回调函数作为值，这个回调函数会在<strong>挂载</strong>和<strong>卸载(或原有的ref属性变化)</strong>时被调用，挂载时传入的是当前DOM元素，而后两种情况时传入null。</p>
<p>ref属性只能在类组件或者返回dom元素的函数组件上定义（因为dom元素本身被实例化了）,下面这张方式ref不起作用</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyFunctionalComponent</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &lt;input /&gt;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Parent extends React.Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    // 无状态函数组件没有组件实例化过程，所以根本没有this这种东西,自然也不会有this.ref</div><div class="line">    return (</div><div class="line">      &lt;MyFunctionalComponent</div><div class="line">        ref=&#123;(input) =&gt; &#123; this.textInput = input; &#125;&#125; /&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>利用ref我们还可以获取到子组件的子元素,把函数传入props然后再对子组件的子元素的ref赋值，于是this.textInput能获取到那个input元素</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyFunctionalComponent</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &lt;input ref = &#123;props.inputRef&#125; /&gt;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class Parent extends React.Component &#123;</div><div class="line">  render() &#123;</div><div class="line">    // 无状态函数组件没有组件实例化过程，所以根本没有this这种东西</div><div class="line">    return (</div><div class="line">      &lt;MyFunctionalComponent</div><div class="line">        inputRef=&#123;(input) =&gt; &#123; this.textInput = input; &#125;&#125; /&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Key属性&quot;&gt;&lt;a href=&quot;#Key属性&quot; class=&quot;headerlink&quot; title=&quot;Key属性&quot;&gt;&lt;/a&gt;Key属性&lt;/h2&gt;&lt;p&gt;React用Key来标记列表中的每一个元素，通过查看key是否改变来知道哪些元素需要重新渲染，这样就节省了渲染时间，毕竟一个列表中有时包含太多元素。&lt;strong&gt;因此要避免使用索引值作为key&lt;/strong&gt;,因为索引可能很容易会被改变，比如增加或者删除列表元素时。&lt;/p&gt;
&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;ul&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;lt;li key = &quot;one&quot;&amp;gt;one&amp;lt;/li&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;lt;li key = &quot;two&quot;&amp;gt;two&amp;lt;/li&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;/ul&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;//changed&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;ul&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;lt;li key = &quot;three&quot;&amp;gt;three&amp;lt;/li&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;lt;li key = &quot;one&quot;&amp;gt;one&amp;lt;/li&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&amp;lt;li key = &quot;two&quot;&amp;gt;two&amp;lt;/li&amp;gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;/ul&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上面这种情况发生时，因为key的存在，react会知道one和two两个项根本没变，所以会直接在one的前面插入一个three。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另外，key是一个在同列表下不能重复的属性。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React(2):Component </title>
    <link href="http://yoursite.com/2018/10/09/react-2-Component/"/>
    <id>http://yoursite.com/2018/10/09/react-2-Component/</id>
    <published>2018-10-09T03:13:52.000Z</published>
    <updated>2018-10-10T06:29:48.773Z</updated>
    
    <content type="html"><![CDATA[<p>  React的核心概念就是组件，组件是整个React应用的基石，组件是UI中被拆分成的独立，可复用的模块。</p>
<h2 id="定义组件"><a href="#定义组件" class="headerlink" title="定义组件"></a>定义组件</h2><h3 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h3><p>  组件的声明方式有两种，使用ES 6 class声明的<strong>类组件</strong>和使用函数的声明<strong>函数组件</strong>，然而class语法只是es6的一个语法糖，不过在这里沟通过继承React已定义好的组件类能够简化开发。</p>
<p>一个class组件如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Board.js</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Board</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line"></div><div class="line">    render() &#123;</div><div class="line">        <span class="keyword">return</span> (</div><div class="line">            <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></div><div class="line">                Board</div><div class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">        );</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//这句话将Board作为默认模块导出，从而可以在其他JS文件中导入使用</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> Board;</div></pre></td></tr></table></figure>
<p>以下两点需要注意：</p>
<p><strong>class组件必须继承自React.Component</strong></p>
<p><strong>class内部必须定义render方法，该方法返回代表该组件UI的react元素</strong></p>
<a id="more"></a>
<p>此时的Board还没有挂载，所以并未正确显示，我们需要把它挂载到界面的root节点上:</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//index.js</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"></div><div class="line"><span class="comment">//导入Board组件模块</span></div><div class="line"><span class="keyword">import</span> Board <span class="keyword">from</span> <span class="string">'./Board'</span></div><div class="line"></div><div class="line"><span class="comment">//mount!</span></div><div class="line">ReactDOM.render(</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Board</span> /&gt;</span>,</span></div><div class="line">    document.getElementById('root')</div><div class="line">);</div></pre></td></tr></table></figure>
<p>上面的<code>import ReactDOM from &#39;react-dom&#39;;</code>用于导入react-dom库，这个库用于虚拟DOM节点到浏览器DOM节点间的转换。</p>
<h4 id="props和state"><a href="#props和state" class="headerlink" title="props和state"></a>props和state</h4><p>props和state是组件的两个重要属性，它们都会反映到最终UI上，但它们有所不同。</p>
<p>你可以把React组件看作是一个函数,输入是props和state输出是UI,你可以认为相同组件最终表现出的UI就是由传入的两个参数来决定的</p>
<p><code>UI = Component(props,state)</code></p>
<p>props是一般是一个由父组件中传入的不可变数据，实质上传入的一般是一个简单的结构对象，其属性由组件作为JSX标签使用时的属性组成。</p>
<p>state则是组件内部的状态，一般在组件的constructor中定义一个组件初始状态，后续通过setState来改变组件的状态（一般在相应函数中），改变后组件UI也会重新渲染。</p>
<p>可以这么说：</p>
<p>props是一个对外的接口，组件通过props接收外部的数据（有时也是方法，当然方法也是一种数据），内部不要去改变props，所以一般来说这个属性是只读的，只在组件创建的那一刻决定了。</p>
<p>states则是一个对内接口，组件的内不要变化通过state来反映出来，这个数据是可变的，我们通过setState方法来修改。</p>
<h3 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h3><p>  props和state都可以影响组件UI，那么组件必须要同时它们两者么？我们知道props一般作为只读的属性，一般来说你只能在创建组件时就把它的值给决定了，而state则不然，这样的话我们知道对于那些不可变的<strong>无状态组件</strong>，我们根本不需要state，我们一般用一个函数来定义无状态组件，因为更加简单明了，当然你也可以用比较长的类定义来定义组件，比如：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Board</span>(<span class="params">props</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.whose&#125; Board<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> Board;</div></pre></td></tr></table></figure>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</div><div class="line"><span class="keyword">import</span> Board <span class="keyword">from</span> <span class="string">'./Board'</span></div><div class="line"></div><div class="line"><span class="comment">//mount!</span></div><div class="line">ReactDOM.render(</div><div class="line">    <span class="xml"><span class="tag">&lt;<span class="name">Board</span> <span class="attr">whose</span> = <span class="string">"Saul's"</span> /&gt;</span>,</span></div><div class="line">    document.getElementById('root')</div><div class="line">);</div></pre></td></tr></table></figure>
<p>Board是一个无状态的函数式组件，我们在挂载它的时候为它传入了<code>props.whose</code>,组件渲染出来将会是<code>Saul&#39;s Board</code>这句话。</p>
<p>现实中大多数组件是一次性渲染的无状态组件，最佳实践中我们定义少量的有状态组件来管理整个应用的状态变化拥有处理状态变化的逻辑，而无状态组件关注绝大部分UI的渲染工作。</p>
<h2 id="组件和元素"><a href="#组件和元素" class="headerlink" title="组件和元素"></a>组件和元素</h2><p>React的组件和元素并不是同一个东西，JSX是createElement的语法糖，所以JSX其实就是用来创建元素的，而组件的声明方式在上面提到了，显然它们并不是一种东西。</p>
<p>React元素实际上是一个JS对象，它的结构的例子如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    type : 'div',</div><div class="line">    props : &#123;</div><div class="line">        className : 'students',</div><div class="line">        student : &#123;</div><div class="line">            type : 'Student',</div><div class="line">            props : &#123;</div><div class="line">                name : 'Liu',</div><div class="line">                age : 20</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以JSX创建上面这个元素是：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div className = <span class="string">'students'</span>&gt;</div><div class="line">	<span class="xml"><span class="tag">&lt;<span class="name">Student</span> <span class="attr">name</span> = <span class="string">'Liu'</span> <span class="attr">age</span> = <span class="string">20</span> /&gt;</span> </span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>因为JSX创建的就是一个普通的js对象，你可以用JSX语法创建一个元素对象赋值给一个变量</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> student = <span class="xml"><span class="tag">&lt;<span class="name">Student</span> <span class="attr">name</span> = <span class="string">'Liu'</span> <span class="attr">age</span> = <span class="string">20</span> /&gt;</span>;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span> = <span class="string">'students'</span>&gt;</span></div><div class="line">	&#123;student&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h3><p>React组件从创建到销毁之间会经历多个生命周期方法，目的是为了让开发者更好的控制组件行为而准备。<strong>函数组件没有生命周期方法（很简单它只是一个普通的函数，不可能无中生有出几个方法）。</strong></p>
<h4 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h4><p>该阶段组件被创建和初始化，然后被挂载到DOM里，完成组件的第一次渲染。</p>
<p><code>constructor -&gt; componentWillMount -&gt; render -&gt; componentDidMount</code></p>
<p><code>constructor</code>方法不用多说</p>
<p><code>componentWillMount</code>方法，执行且仅执行一次，该方法中调用setState不会引起重新渲染，该方法很少用到。</p>
<p><code>render</code>根据props和state返回一个React元素。注意这个元素只是描述UI并不是真正去渲染，把它当做一个输入值是this的纯函数用比较好。</p>
<p><code>componentDidMount</code>只会在组件被挂载到DOM后执行一次，此时DOM的结构已经可以获取到，一些依赖DOM节点的操作可以放到这个方法中，<strong>这个方法还常常用来向服务器请求数据</strong>，该方法中如果改变state则会引起组件的从新渲染。</p>
<h4 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h4><p>组件的更新一般只是由于props或者state的变化引起，state只能由setState来改变，而props是对外接口，一般是因为父组件的render方法执行而改变，当然有时候也许父组件的render方法并没有改变props的值，但是组件依然会执行更新阶段的声明周期函数。</p>
<p><code>componentWillReceiveProps -&gt; shouldComponentUpdate -&gt; componentWillUpdate -&gt; render -&gt; componentDidUpdate</code></p>
<p><code>componentWillReceiveProps(nextProps)</code>只在props引起的组件更新过程中才会被调用,nextProps是父组件传递过来来新的props，它的值可能和this.props一致。</p>
<p>如果在这个方法中执行了setState，实际上要等到render执行之后才更新state，<code>shouldComponentUpdate</code>，<code>componentWillUpdate</code>中的state不变。</p>
<p><code>shouldComponentUpdate(nextProps,nextState)</code>该方法决定组件是否继续执行更新过程，默认返回true，即继续执行更新，一旦该方法返回false，后面的声明周期方法不会被调用，在该方法中一般比较state和props是否改变，可以节省一部分渲染时间，因为如果state和props更本没变，则没必要渲染，该方法体里面不能调用setState，不然会引起循环调用。</p>
<p><code>componentWillUpdate(nextProps,nextState)</code>很少用到,里面不能调用setState，不然会引起循环调用。</p>
<p><code>componentDidUpdate(prevProps,prevState)</code>组件更新后被调用，作为操作更新后的DOM的地方。</p>
<h4 id="卸载阶段"><a href="#卸载阶段" class="headerlink" title="卸载阶段"></a>卸载阶段</h4><p>只有一个方法,在卸载前调用</p>
<p><code>componentWillUnmount</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  React的核心概念就是组件，组件是整个React应用的基石，组件是UI中被拆分成的独立，可复用的模块。&lt;/p&gt;
&lt;h2 id=&quot;定义组件&quot;&gt;&lt;a href=&quot;#定义组件&quot; class=&quot;headerlink&quot; title=&quot;定义组件&quot;&gt;&lt;/a&gt;定义组件&lt;/h2&gt;&lt;h3 id=&quot;类组件&quot;&gt;&lt;a href=&quot;#类组件&quot; class=&quot;headerlink&quot; title=&quot;类组件&quot;&gt;&lt;/a&gt;类组件&lt;/h3&gt;&lt;p&gt;  组件的声明方式有两种，使用ES 6 class声明的&lt;strong&gt;类组件&lt;/strong&gt;和使用函数的声明&lt;strong&gt;函数组件&lt;/strong&gt;，然而class语法只是es6的一个语法糖，不过在这里沟通过继承React已定义好的组件类能够简化开发。&lt;/p&gt;
&lt;p&gt;一个class组件如下：&lt;/p&gt;
&lt;figure class=&quot;highlight jsx&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//Board.js&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; React &lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;react&#39;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Board&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;React&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;Component&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    render() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;                Board&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;div&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        );&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//这句话将Board作为默认模块导出，从而可以在其他JS文件中导入使用&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;default&lt;/span&gt; Board;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以下两点需要注意：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;class组件必须继承自React.Component&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;class内部必须定义render方法，该方法返回代表该组件UI的react元素&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>React(1):meet react</title>
    <link href="http://yoursite.com/2018/10/09/react-1-meet-react/"/>
    <id>http://yoursite.com/2018/10/09/react-1-meet-react/</id>
    <published>2018-10-09T01:44:08.000Z</published>
    <updated>2018-10-10T06:29:56.678Z</updated>
    
    <content type="html"><![CDATA[<p>  几乎所有的软件问题都可以添加一层抽象来解决，react通过添加虚拟DOM这层抽象，=，解决了处理DOM的效率问题，<strong>虚拟DOM即用来描述真实DOM的JS对象</strong>，我们知道处理结构化的js对象，要比处理一大段文本快得多。</p>
<a id="more"></a>
<p>  特点：</p>
<p>  <strong>声明式的视图层</strong>：以JSX语法声明视图层，因此可以随意使用状态数据</p>
<p>  <strong>从状态到UI的单向数据流</strong>：定义UI的状态，让React来把它渲染为最终的UI，React根据最新状态来渲染最新UI。</p>
<p>  <strong>灵活渲染</strong>：React并不直接把视图渲染成最终的界面，而是把它们渲染为了中间的抽象，即虚拟DOM，结合其他库，可以把虚拟DOM渲染成不同的最终界面，在浏览器上是react-dom,在移动端上则可以配合Native来使用，在服务端则可以配合Node进行渲染。</p>
<p>  <strong>高效DOM操作</strong>：本身对js对象的操作就远快于对真实DOM操作，配合一些诸如Diff之类的差异算法，更是可以减少渲染速度，让界面性能增加。</p>
<h2 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h2><p>  JSX是一种用于描述UI的JS扩展语法，React用其来描述组件的UI。发明这种语法与React本身的理念有关，与传统很多模板思想把数据和UI拆分有所不同，其理念把<strong>组件</strong>当做是界面的可复用模块，<strong>且认为组件应该是具备UI描述和UI数据的完整体</strong>，不应该把它们分开来处理。</p>
<p>  实际上JSX仅仅是React提供的语法糖，它对应的方法是</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">React.createElement(component,props, ...chi)</div></pre></td></tr></table></figure>
<p>  所有的JSX最终都会转变为对上面这个方法的调用，但是为了对被声明的视图一目了然，首选使用JSX，就像java8中一般不会使用匿名类来代替lambda语法一样。</p>
<h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>  JSX只有两种标签，React通过首字母是否大写来区分这两类标签，而且它们可以互相嵌套使用：</p>
<p>  其一就是DOM类型的标签，也就是html的基础标签诸如div,span,p等等，首字母必须小写。</p>
<p>  然后则是React组件标签，首字母必须大写。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//dom标签</span></div><div class="line"><span class="keyword">const</span> divElement = <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span> hello saul <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line"></div><div class="line"><span class="comment">//组件标签</span></div><div class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">SaulBlog</span> /&gt;</span>;</span></div><div class="line">     </div><div class="line">//嵌套使用</div><div class="line">const hello = (<span class="tag">&lt;<span class="name">div</span>&gt;</span> <span class="tag">&lt;<span class="name">SaulBlog</span> /&gt;</span> <span class="tag">&lt;/<span class="name">div</span>&gt;</span>;</div></pre></td></tr></table></figure>
<h3 id="js表达式"><a href="#js表达式" class="headerlink" title="js表达式"></a>js表达式</h3><p>JSX本质上依然是Js，我们可以用{}讲表达式括起来的方式来使用表达式，一般有两种情况我们要用这种语法：</p>
<p>  <strong>通过表达式给标签属性赋值</strong></p>
<p>  <strong>通过表达式定义子组件</strong></p>
<p>需要注意的是和scala之类的语言不同，js表达式并不支持多行js语句，用;隔开两条语句是会报错的。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Error!</span></div><div class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">Saul</span> <span class="attr">value</span> = <span class="string">&#123;const</span> <span class="attr">val</span> = <span class="string">1+1;return</span> <span class="attr">val</span>; &#125; /&gt;</span></span></div></pre></td></tr></table></figure>
<p>所以你用不了if-eles语句，但是可以用三目运算符?和&amp;&amp;代替if的作用。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> boolean = <span class="literal">false</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">Saul</span> <span class="attr">value</span> = <span class="string">&#123;boolean</span> &amp;&amp; <span class="attr">1</span>&#125; /&gt;</span></span></div></pre></td></tr></table></figure>
<h3 id="标签属性和注释"><a href="#标签属性和注释" class="headerlink" title="标签属性和注释"></a>标签属性和注释</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>除了部分属性外，DOM标签支持的属性JSX同样支持，只不过有些地方有点变化，比如es6占用的class关键字，现在需要在标签属性中用className代替</p>
<p>另外React对标签支持的事件进行了重新分封装，封装时采用的是驼峰命名法，如onclick要写成onClick。</p>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>注释方面需要用{}把/**/括起来</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="comment">/* 我是注释 */</span>&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  几乎所有的软件问题都可以添加一层抽象来解决，react通过添加虚拟DOM这层抽象，=，解决了处理DOM的效率问题，&lt;strong&gt;虚拟DOM即用来描述真实DOM的JS对象&lt;/strong&gt;，我们知道处理结构化的js对象，要比处理一大段文本快得多。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Notes of CS231n:Structure of CNN</title>
    <link href="http://yoursite.com/2018/03/12/Notes-of-Deep-Learning-Structure-of-CNN/"/>
    <id>http://yoursite.com/2018/03/12/Notes-of-Deep-Learning-Structure-of-CNN/</id>
    <published>2018-03-12T03:04:18.000Z</published>
    <updated>2018-03-12T08:39:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>  卷积神经网络也由有学习能力的神经元组成，这些神经元中也有权重和偏差。整个卷积神经网络实为是一个可导的评分函数，在神经网络中我们实现的各种技巧和要点依旧适用于卷积神经网络。但是<strong>卷积神经网络与一般神经网络不同的是，它基于一个假设，即输入的数据是图像</strong>。基于这个假设，我们添加了一些特有的特性，从而让我们的前向传播更为高效，<strong>同时也大大降低了网络中的参数数量</strong>。降低参数数量是一个很好的特性，因为在一般的神经网络中，因为是全连接的，如果要处理一个大点的图像，比如一个200*200*3的图像，一个神经元就有12万个权重，显然这是不可接受的。</p>
<a id="more"></a>
<h2 id="卷积神经网络结构"><a href="#卷积神经网络结构" class="headerlink" title="卷积神经网络结构"></a>卷积神经网络结构</h2><h3 id="三维排列的神经元"><a href="#三维排列的神经元" class="headerlink" title="三维排列的神经元"></a>三维排列的神经元</h3><p>在一般的神经网络中，神经元的排列一般是如下图所示：</p>
<p><img src="\img\QQ图片20180214180333.jpg" alt="QQ图片20180214180333"></p>
<p>我们可以观察到，如果硬要以一个形式的语言来描述的话，可以用宽度和高度来描述这个二维的神经元排列，但是卷积神经网络与此不同，它是三维排列的，如下图所示，我们以<strong>宽度，高度，和深度</strong>标记了这个神经元排列：</p>
<p><img src="\img\QQ图片20180312120608.png" alt="QQ图片20180312120608"></p>
<p>  从上图中你没办法发现神经元之间具体是如何连接的，但是你可以先了解一点，<strong>卷积神经网络的各层中的神经元不再采用全连接的方式</strong>，层中的神经元将只与前一层中的一小块区域连接，当然输出层例外，输出层还是全连接的。</p>
<p>  上图中的卷积神经网络的神经元排列可能不能让你清楚的知道深度的意义。我们以CIFAR-10举例，你知道CIFAR-10中的数据体是32*32*3这个大小，后面的3是代表了RGB颜色通道，那么它的神经元排列就是深度为3，宽度和高度都是32的排列。最后的输出层是1*1*10的，表示了评分向量。</p>
<blockquote>
<p>卷积神经网络是由层组成的。每一层都有一个简单的API：用一些含或者不含参数的可导的函数，将输入的3D数据变换为3D的输出数据。</p>
</blockquote>
<h3 id="以层构造的卷积神经网络"><a href="#以层构造的卷积神经网络" class="headerlink" title="以层构造的卷积神经网络"></a>以层构造的卷积神经网络</h3><p>卷积神经网络由不同类型的层按照一定的排列顺序组成，这些层会使用一个可微分的函数将激活数据从自身层传到另一个层。比如一个简单的用于CIFAR-10图像分类的网络结构：</p>
<blockquote>
<p>[输入层-卷积层-ReLU层-汇聚层-全连接层]</p>
</blockquote>
<p>1.输入层即是输入[32*32*3]的原始图像像素值</p>
<p>2.卷基层中，神经元与输入层的一个局部区域相连，每个神经元都计算自己与输入层相连的小区域与自己权重的内积。卷积层会计算所有神经元的输出。如果我们使用12个滤波器（也叫作核），得到的输出数据体的维度就是[32x32x12]。</p>
<p>3.ReLU层将会逐个元素地进行激活函数操作，比如使用以0为阈值的max(0,x)作为激活函数。该层对数据尺寸没有改变，还是[32x32x12]。</p>
<p>4.汇聚层在在空间维度（宽度和高度）上进行降采样（downsampling）操作，数据尺寸变为[16x16x12]。</p>
<p>5.全连接层将会计算分类评分，数据尺寸变为[1x1x10]，其中10个数字对应的就是CIFAR-10中10个类别的分类评分值。正如其名，全连接层与常规神经网络一样，其中每个神经元都与前一层中所有神经元相连接。</p>
<p>具体说来，卷积层和全连接层（CONV/FC）对输入执行变换操作的时候，不仅会用到激活函数，还会用到很多参数（神经元的突触权值和偏差）。而ReLU层和汇聚层则是进行一个固定不变的函数操作，它没有参数（汇聚层有额外的超参数）。卷积层和全连接层中的参数会随着梯度下降被训练，这样卷积神经网络计算出的分类评分就能和训练集中的每个图像的标签吻合了。</p>
<h2 id="卷基层与汇聚层"><a href="#卷基层与汇聚层" class="headerlink" title="卷基层与汇聚层"></a>卷基层与汇聚层</h2><h3 id="卷基层"><a href="#卷基层" class="headerlink" title="卷基层"></a>卷基层</h3><p>  从卷积神经网络的名字你就应该知道什么层是核心，卷基层产生了网络中的大部分计算量。</p>
<h4 id="滤波器"><a href="#滤波器" class="headerlink" title="滤波器"></a>滤波器</h4><p>  首先你肯定想知道卷积层是怎么样计算的，先明确的一点是：<strong>卷基层的参数是由一些可学习的滤波器（即一组固定权重的集合，又被称作卷积核）集合构成的。</strong>这些滤波器的宽度和高度都比较小，但是深度与输入数据一致。比如在上面CIFAR例子中的第一层卷积层与输入层相连，它的滤波器大小可能是5*5*3，其中5<em>5是宽高，而3则与数据体的RGB通道深度相同。在前向传播的时候，让每个滤波器都在输入数据的宽度和高度上滑动（更精确地说是卷积），然后计算整个滤波器和输入数据任一处的内积。当<strong>滤波器沿着输入数据的宽度和高度滑过</strong>后，会生成一个2维的激活图（activation map），激活图给出了在每个空间位置处滤波器的反应。直观地来说，网络会让滤波器学习到当它看到某些类型的视觉特征时就激活。<em>*在每个卷积层上，我们会有一整个集合的滤波器（比如12个），每个都会生成一个不同的二维激活图。将这些激活映射在深度方向上层叠起来就生成了输出数据。</em></em></p>
<h4 id="感受野"><a href="#感受野" class="headerlink" title="感受野"></a>感受野</h4><p>  图像数据是高维的，如果让每个神经元与之进行全连接，那么将会产生大量的参数以至于计算量不能忍受。于是我们让每个神经元只与输入数据的一个局部区域进行连接，这个局部区域的尺寸（高宽）是一个超参数，我们把它叫做神经元的<strong>感受野</strong>。但是可以确定的是，在数据深度上这个连接大小与输入数据一致。比如：</p>
<p><em>例1</em>：假设输入数据体尺寸为[32x32x3]（比如CIFAR-10的RGB图像），如果感受野（或滤波器尺寸）是5x5，那么卷积层中的每个神经元会有输入数据体中[5x5x3]区域的权重，共5x5x3=75个权重（还要加一个偏差参数）。注意这个连接在深度维度上的大小必须为3，和输入数据体的深度一致。</p>
<p><em>例2</em>：假设输入数据体的尺寸是[16x16x20]，感受野尺寸是3x3，那么卷积层中每个神经元和输入数据体就有3x3x20=180个连接。再次提示：在空间上连接是局部的（3x3），但是在深度上是和输入数据体一致的（20）。</p>
<h3 id="输出数据体"><a href="#输出数据体" class="headerlink" title="输出数据体"></a>输出数据体</h3><p>  现在我们知道了卷积层中神经元与输入数据体中的连接方式，那么卷积层的输出数据体是怎么样的呢？有三个超参数控制着输出数据体的尺寸：<strong>即深度，步长和零填充。</strong></p>
<p>  输出数据体的深度是一个超参数，它与滤波器数量一致，每个滤波器在输入数据中寻找一些不同的东西。举例来说，如果第一个卷积层的输入是原始图像，那么在深度维度上的不同神经元将可能被不同方向的边界，或者是颜色斑点激活。我们将这些沿着深度方向排列、感受野相同的神经元集合称为<strong>深度列（depth column）</strong>，也有人使用纤维（fibre）来称呼它们。</p>
<p>  另外，滑动滤波器的时候，需要指定步长，这个步长大小同零填充的大小一起决定了输出数据体的高宽。步长和零填充的大小都是超参数。填充有一个良好性质，即可以控制输出数据体的空间尺寸（最常用的是用来保持输入数据体在空间上的尺寸，这样输入和输出的宽高都相等）。</p>
<p>  输出数据体在空间（高度和宽度）上的尺寸可以通过输入数据体尺寸（W），卷积层中神经元的感受野尺寸（F），步长（S）和零填充的数量（P）的函数来计算。（<strong>*译者注</strong>：这里假设输入数组的空间形状是正方形，即高度和宽度相等<em>）<em>*输出数据体的空间尺寸为(W-F +2P)/S+1</em></em>（注意如果这个公式得出的值不是一个整数，说明你的步长和零填充的设置是无效的）。比如输入是7x7，滤波器是3x3，步长为1，填充为0，那么就能得到一个5x5的输出。</p>
<h3 id="参数共享"><a href="#参数共享" class="headerlink" title="参数共享"></a>参数共享</h3><p>  在2012年的ImageNet挑战中，Krizhevsky采用了这么一个设定，输入图像的尺寸是[227x227x3]。在第一个卷积层，神经元使用的感受野尺寸<strong>F=11</strong>，步长<strong>S=4</strong>，不使用零填充<strong>P=0</strong>。因为(227-11)/4+1=55，卷积层的深度<strong>K=96</strong>，则卷积层的输出数据体尺寸为[55x55x96]。</p>
<p>  我们可以看到上面举出的这个第一个卷积层就有55*55*96=290,400个神经元，每个有11*11*3个参数和一个偏差，你可以乘一下就发现，第一层卷积层参数就上亿了，显然我们需要一些策略来避免这种情况发生，这个策略就是<strong>参数共享</strong>。</p>
<p>  一个合理的假设：如果一个特征在计算某个空间位置(x,y)的时候有用，那么它在计算另一个不同位置(x2,y2)的时候也有用。基于这个假设，可以显著地减少参数数量。换言之，就是将深度维度上一个单独的2维切片看做<strong>深度切片（depth slice）</strong>，比如一个数据体尺寸为[55x55x96]的就有96个深度切片，每个尺寸为[55x55]。在这样的参数共享下，例子中的第一个卷积层就只有96个不同的权重集了，一个权重集对应一个深度切片，共有96x11x11x3=34,848个不同的权重，或34,944个参数（+96个偏差）。）。在每个深度切片中的55x55个权重使用的都是同样的参数。<strong>在反向传播的时候，都要计算每个神经元对它的权重的梯度，但是需要把同一个深度切片上的所有神经元对权重的梯度累加，这样就得到了对共享权重的梯度。</strong>这样，每个切片只更新一个权重集。</p>
<p>  注意，如果在一个深度切片中的所有权重都使用同一个权重向量，那么卷积层的前向传播在每个深度切片中可以看做是在计算神经元权重和输入数据体的<strong>卷积</strong>（这就是“卷积层”名字由来）。这也是为什么总是将这些权重集合称为<strong>滤波器（filter）</strong>（或<strong>卷积核（kernel）</strong>），因为它们和输入进行了卷积。下图演示了一个卷积过程，该图中几个超参数分别是K=2（卷积层深度），F=3（感受野尺寸），S=2（步长），P=1（零填充）：</p>
<p><img src="\img\20160707204048899.gif" alt="20160707204048899"></p>
<p>我们可以看到，在该图中对一个深度切片（蓝色部分每一个矩阵），都用相同的权重进行卷积的过程。</p>
<h3 id="汇聚层"><a href="#汇聚层" class="headerlink" title="汇聚层"></a>汇聚层</h3><p>  一般我们都会在连续的卷积层之间周期性的插入一个汇聚层，目的是为了降低数据体的空间尺寸，这样的话就能够减少网络中参数的尺寸，从而降低计算成本，另外还有控制过拟合的好处。</p>
<p>  汇聚层也是对输入数据体的每一个深度切片独立进行MAX操作，以改变其空间尺寸（高宽）。最常见的形式是汇聚层使用尺寸2x2的滤波器，以步长为2来对每个深度切片进行降采样，将其中75%的激活信息都丢掉。每个MAX操作是从4个数字中取最大值（也就是在深度切片中某个2x2的区域）。深度保持不变。</p>
<p>汇聚层也有计算公式：</p>
<p>  输入数据体高H1，宽W1，深度为D1</p>
<p>  MAX操作空间大小为F,步长为S</p>
<p>  那么输出数据体:</p>
<p>  宽度：W2=(W1-F)/S+1</p>
<p>  高度：H2=(H1-F)/S+1</p>
<p>  深度不变：D2=D1</p>
<p>一般来说MAX汇聚层只有两种形式：F=3，S=2还有前面说的最常用的F=2，S=2。</p>
<p><img src="\img\641c8846abcb02d35938660cf96cef1b_r.jpg" alt="641c8846abcb02d35938660cf96cef1b_r"></p>
<h4 id="汇聚层反向传播"><a href="#汇聚层反向传播" class="headerlink" title="汇聚层反向传播"></a>汇聚层反向传播</h4><p><strong>反向传播：</strong>回顾一下反向传播的内容，其中max(x,y)函数的反向传播可以简单理解为将梯度只沿最大的数回传。因此，在向前传播经过汇聚层的时候，通常会把池中最大元素的索引记录下来（有时这个也叫作<strong>道岔（switches）</strong>），这样在反向传播的时候梯度的路由就很高效。</p>
<p>有些人更倾向于在卷积层中使用更大的步长来降低数据体的尺寸，而不是在模型中使用汇聚层，另外有发现认为，在训练一个良好的生成模型时，弃用汇聚层也是很重要的。</p>
<h2 id="全连接层到卷积层的转换"><a href="#全连接层到卷积层的转换" class="headerlink" title="全连接层到卷积层的转换"></a>全连接层到卷积层的转换</h2><p>全连接层和卷积层之间唯一的不同就是卷积层中神经元只与输入数据中的一个局部区域连接，并且在卷积列中的神经元共享参数。但是两类层中神经元都是计算点积，它们的函数形式实际上是相同的。</p>
<p>我们可以把卷积层转化为一个全连接层，这个全连接层的权重矩阵是巨大的，除了某些特定的块，其余部分都是零（局部连接）。而大部分块中，元素都是相等的（参数共享）。</p>
<p>那么，全连接层也能够被转化为卷积层，因为卷积层连接局部，但是如果这个局部大小大到了和全局一样，那就成了全连接层了。<strong>以卷积层代替全连接层可以让卷积网络在一张更大的输入图片上滑动，得到每个区域的输出（这样就突破了输入尺寸的限制）。下面这段话全部看完可以理解它的意思：</strong></p>
<blockquote>
<p>举个例子，如果我们想让224x224尺寸的浮窗，以步长为32在384x384的图片上滑动，把每个经停的位置都带入卷积网络，最后得到6x6个位置的类别得分。上述的把全连接层转换成卷积层的做法会更简便。如果224x224的输入图片经过卷积层和汇聚层之后得到了[7x7x512]的数组，那么，384x384的大图片直接经过同样的卷积层和汇聚层之后会得到[12x12x512]的数组（因为途径5个汇聚层，尺寸变为384/2/2/2/2/2 = 12）。然后再经过上面由3个全连接层转化得到的3个卷积层，最终得到[6x6x1000]的输出（因为(12 - 7)/1 + 1 = 6）。这个结果正是浮窗在原图经停的6x6个位置的得分！</p>
<p>面对384x384的图像，让（含全连接层）的初始卷积神经网络以32像素的步长独立对图像中的224x224块进行<strong>多次评价</strong>，其效果和使用把全连接层变换为卷积层后的卷积神经网络进行<strong>一次</strong>前向传播是一样的。</p>
<p>自然，相较于使用被转化前的原始卷积神经网络对所有36个位置进行迭代计算，使用转化后的卷积神经网络进行一次前向传播计算要高效得多，因为36次计算都在共享计算资源。这一技巧在实践中经常使用，一次来获得更好的结果。比如，通常将一张图像尺寸变得更大，<strong>然后使用变换后的卷积神经网络来对空间上很多不同位置进行评价得到分类评分，然后在求这些分值的平均值。</strong></p>
</blockquote>
<h2 id="一些对于层的建议"><a href="#一些对于层的建议" class="headerlink" title="一些对于层的建议"></a>一些对于层的建议</h2><h3 id="层的排列"><a href="#层的排列" class="headerlink" title="层的排列"></a>层的排列</h3><p>一个最常见的神经网络结构如下：</p>
<p><strong>INPUT -&gt; [[CONV -&gt; RELU]<em>N -&gt; POOL?]</em>M -&gt; [FC -&gt; RELU]*K -&gt; FC</strong></p>
<p>其中POOL后面的？代表汇聚层是可选的，如果没有其他说明POOL层都是MAX汇聚。</p>
<p>一般而言，几个小滤波器卷积层的组合比一个大滤波器卷积层好。比如你一层一层地重叠了3个3x3的卷积层（层与层之间有非线性激活函数）。在这个排列下，第一个卷积层中的每个神经元都对输入数据体有一个3x3的视野。第二个卷积层上的神经元对第一个卷积层有一个3x3的视野，也就是对输入数据体有5x5的视野。同样，在第三个卷积层上的神经元对第二个卷积层有3x3的视野，也就是对输入数据体有7x7的视野。假设不采用这3个3x3的卷积层，二是使用一个单独的有7x7的感受野的卷积层，那么所有神经元的感受野也是7x7，但是就有一些缺点。</p>
<p>1.多层小的卷积层能更好的提取出深层次的特征</p>
<p>2.在这里，3个3*3的卷积层的参数数目是3*3*3<em>通道数N，而7\</em>7的单个卷积层则是7*7*通道数N，这个数目要大于前者。</p>
<h3 id="层的尺寸"><a href="#层的尺寸" class="headerlink" title="层的尺寸"></a>层的尺寸</h3><p>输入层图像大小应该能被2整除多次，比如32，或者是诸如96或者224，384，512这样的数。</p>
<p>卷积层应该使用小的滤波器，比如3*3或者5*5，大的滤波器如果采用了也一般是接上原始输入层的第一个卷积层，并且我们一般会用适当的零填充来保持数据在空间维度上的尺寸，步长一般是1。在实际应用中，更小的步长效果更好。<strong>上文也已经提过，步长为1可以让空间维度的降采样全部由汇聚层负责，卷积层只负责对输入数据体的深度进行变换。</strong>如果卷积层值进行卷积而不进行零填充，那么数据体的尺寸就会略微减小，那么图像边缘的信息就会过快地损失掉。</p>
<p>对汇聚层的选择一般都是用比较小的感受野，比如2*2，一旦感受野太大可能会使得数据信息丢失。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  卷积神经网络也由有学习能力的神经元组成，这些神经元中也有权重和偏差。整个卷积神经网络实为是一个可导的评分函数，在神经网络中我们实现的各种技巧和要点依旧适用于卷积神经网络。但是&lt;strong&gt;卷积神经网络与一般神经网络不同的是，它基于一个假设，即输入的数据是图像&lt;/strong&gt;。基于这个假设，我们添加了一些特有的特性，从而让我们的前向传播更为高效，&lt;strong&gt;同时也大大降低了网络中的参数数量&lt;/strong&gt;。降低参数数量是一个很好的特性，因为在一般的神经网络中，因为是全连接的，如果要处理一个大点的图像，比如一个200*200*3的图像，一个神经元就有12万个权重，显然这是不可接受的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Notes of CS231n:Neural network 4</title>
    <link href="http://yoursite.com/2018/03/11/Notes-of-Deep-Learning-Neural-network-4/"/>
    <id>http://yoursite.com/2018/03/11/Notes-of-Deep-Learning-Neural-network-4/</id>
    <published>2018-03-11T13:30:24.000Z</published>
    <updated>2018-03-13T03:56:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>  我们利用反向传播计算出解析梯度，然后利用计算出的解析梯度来进行参数更新，这里记录一些有些的最优化技巧，但不进行细节分析。</p>
<a id="more"></a>
<h2 id="参数更新方法"><a href="#参数更新方法" class="headerlink" title="参数更新方法"></a>参数更新方法</h2><h3 id="普通更新"><a href="#普通更新" class="headerlink" title="普通更新"></a>普通更新</h3><p>  沿着负梯度方向改变参数是一个简单有效的方法，比如一个参数向量x，它的梯度为dx，那么这个简单的方法可以表示为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">x+=learning_rate*dx</div></pre></td></tr></table></figure>
<h3 id="动量更新"><a href="#动量更新" class="headerlink" title="动量更新"></a>动量更新</h3><p>  普通更新的缺点是，其更新方向完全依赖于当前的batch，使得更新非常不稳定，从物理角度得到启发，人们想出来一种在深度网络上有着更好收敛速度且更新更稳定的方法，即<strong>动量(Momentum)更新</strong>。</p>
<p>  在上面的普通更新中我们可以看到梯度的大小直接影响到了x的值的更新，<strong>而动量更新则不同，它会由梯度去影响“速度”，然后速度再去影响x的更新</strong>，研究这个方法的人把损失值理解为一个高地，而参数更新这个最优化过程可以看做是一个质量以初始速度0，慢慢的加速，把梯度看做是提供这种加速度的力。听起来很玄学，这也能扯上关系？实际上所做的就是改变了x的更新方式而已，把以前的learning_rate*dx增量变成了一个更加科学的“速度”，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">v = mu * v - learning_rate * dx</div><div class="line">x += v</div></pre></td></tr></table></figure>
<p>其中这个mu是一个超参数，叫做动量，它模拟的物体运动的惯性，即更新的时候在一定程度上保留之前更新的方向，同时利用当前batch的梯度微调最终的更新方向，实际上它的意义更加贴近于阻尼系数，mu<em>v提供了一个阻力，这个变量会抑制速度，<em>*一般mu设置为0.9</em></em>，也有一些研究表明mu随时间变化能略改善最优化效果，比如一个典型的设置是一开始mu=0.5，而随后在多个周期中慢慢提升到0.99，[0.5,0.9,0.95,0.99]。</p>
<h3 id="Nesterov动量更新"><a href="#Nesterov动量更新" class="headerlink" title="Nesterov动量更新"></a>Nesterov动量更新</h3><p>  对于动量更新，还有一个增强版的思路，理论上它对于凸函数的收敛有帮助，实践中似乎也确实比上面的标准动量更新表现好点。</p>
<p>  这个思路在于考虑到，更新时，mu*v这个项会稍加改变参数向量，我们最好是在x+mu*v这个近似未来的位置附近计算梯度，而不是在x处计算，这样我们的代码可以变为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">x_ahead = x + mu * v</div><div class="line"><span class="comment"># 计算dx_ahead(在x_ahead处的梯度，而不是在x处的梯度)</span></div><div class="line">v = mu * v - learning_rate * dx_ahead</div><div class="line">x += v</div></pre></td></tr></table></figure>
<p><img src="\img\20150906103038485.png" width="600px\"></p>
<p>  首先，按照原来的更新方向更新一步（棕色线），然后在该位置计算梯度值（红色线），然后用这个梯度值修正最终的更新方向（绿色线）。上图中描述了两步的更新示意图，其中蓝色线是标准momentum更新路径。</p>
<h3 id="二阶方法"><a href="#二阶方法" class="headerlink" title="二阶方法"></a>二阶方法</h3><p>  实际上除了各种随机梯度下降算法以外还有一种方法是基于牛顿法的，但是因为实现起来比较困难并不常用。</p>
<h2 id="学习率动态设定"><a href="#学习率动态设定" class="headerlink" title="学习率动态设定"></a>学习率动态设定</h2><h3 id="学习率退火"><a href="#学习率退火" class="headerlink" title="学习率退火"></a>学习率退火</h3><p>学习率随着时间慢慢减小对深度学习训练很有帮助，我们并不想看着参数向量无规律的跳动，但是如果学习率过高这很可能发生，并且意味着我们很难达到最好的位置。一般我们有以下三种退火方式：</p>
<p><strong>随步数衰减</strong>：每隔几个周期就根据某些因素降低学习 率，比如每5个周期减半，或者每20个周期减少到之前的0.1。训练的同时观察验证集的错误率，每当验证集错误率停止下降，就将原来的学习率乘以一个常数比例来降低它。</p>
<p><strong>指数衰减</strong>：a=a[0]e^(-kt),a0和k是超参数，t是迭代次数或者周期</p>
<p><strong>1/t衰减</strong>：a=a[0]/(1+kt),a0和k是超参数，t是迭代次数或者周期</p>
<p>实践中一般都采用第一种方法。</p>
<h3 id="逐参数适应学习率方法"><a href="#逐参数适应学习率方法" class="headerlink" title="逐参数适应学习率方法"></a>逐参数适应学习率方法</h3><p>学习率调参是很耗费计算资源的过程，所以很多工作投入到发明能够适应性地对学习率调参的方法，甚至是逐个参数适应学习率调参。这里将记录一些常用的适应算法。</p>
<h4 id="Adagrad"><a href="#Adagrad" class="headerlink" title="Adagrad"></a>Adagrad</h4> <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 假设有梯度和参数向量x</span></div><div class="line">cache += dx**<span class="number">2</span></div><div class="line">x += - learning_rate * dx / (np.sqrt(cache) + eps)</div></pre></td></tr></table></figure>
<p>Adagrad的一个缺点是，在深度学习中单调递减的学习率被证明通常过于激进且过早停止学习。这里的<strong>eps是一个很小的数</strong>，通常为1e-4到1e-8之间，<strong>引入它的目的是为了防止出现除以0这种不合法情况出现</strong>。</p>
<h4 id="RMSprop"><a href="#RMSprop" class="headerlink" title="RMSprop"></a>RMSprop</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cache =  decay_rate * cache + (1 - decay_rate) * dx**2</div><div class="line">x += - learning_rate * dx / (np.sqrt(cache) + eps)</div></pre></td></tr></table></figure>
<p>RMSprop（Root Mean Square Propagation）方法是Adagrad的改进版本，没有公开发表，但是却非常高效，它来自Geoff Hinton的Coursera课程的<a href="http://link.zhihu.com/?target=http%3A//www.cs.toronto.edu/%257Etijmen/csc321/slides/lecture_slides_lec6.pdf" target="_blank" rel="external">第六课的第29页PPT</a>。上面的代码里decay_rate是一个超参数，常用值是[0.9,0.99,0.999]。你可以观察这个方法改变了cache的计算部分，而第二个式子却是相同的。RMSProp任然是基于梯度的大小来对每个权重的学习率进行修改，但是学习率不会再单调递减，这是和Adagrad的主要区别，也就是说该方法更不那么激进。</p>
<h4 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">m = beta1*m + (<span class="number">1</span>-beta1)*dx</div><div class="line">v = beta2*v + (<span class="number">1</span>-beta2)*(dx**<span class="number">2</span>)</div><div class="line">x += - learning_rate * m / (np.sqrt(v) + eps)</div></pre></td></tr></table></figure>
<p>Adam（Adaptive Moment Estimation）是推荐使用的方法，一般而言跑起来比RMSProp要好一点。但是也可以试试SGD+Nesterov动量。Adam方法看起来真的和RMSProp很像，除了使用的是平滑版的梯度<strong>m</strong>，而不是用的原始梯度向量<strong>dx</strong>。论文中推荐的参数值<strong>eps=1e-8, beta1=0.9, beta2=0.999</strong>。完整的Adam更新算法也包含了一个偏置<em>（bias）矫正</em>机制，因为<strong>m,v</strong>两个矩阵初始为0，在没有完全热身之前存在偏差，需要采取一些补偿措施。</p>
<h2 id="超参数调优"><a href="#超参数调优" class="headerlink" title="超参数调优"></a>超参数调优</h2><p>  你知道一个模型中往往存在着很多超参数，比如随机失活的概率p，以及我们上面提到的种种适应学习率算法中的超参数，我们上面已经给出了一些好的实践值，但是有可能你想去找到更好的值，或者你研究新算法需要有新的超参数。</p>
<h3 id="采用仆程序"><a href="#采用仆程序" class="headerlink" title="采用仆程序"></a>采用仆程序</h3><p>我们可以采用仆程序持续的设置参数然后进行最优化，并且它对各个周期后验证集的准确率进行监控，并将这个记录点的模型数据（记录点中有各种各样的训练统计数据，比如随着时间的损失值变化等）记录到相关文件中。</p>
<h3 id="只使用单个验证集"><a href="#只使用单个验证集" class="headerlink" title="只使用单个验证集"></a>只使用单个验证集</h3><p>为了让代码更简单，可以只采用一个合理尺寸的验证集，而不是采用几个数据集来交叉验证。</p>
<h3 id="使用随机搜索"><a href="#使用随机搜索" class="headerlink" title="使用随机搜索"></a>使用随机搜索</h3><p>比起“网格式”搜索（即相同的间距），随机搜索往往更容易实现也更加好。</p>
<h3 id="对于边界上的最优值要小心"><a href="#对于边界上的最优值要小心" class="headerlink" title="对于边界上的最优值要小心"></a>对于边界上的最优值要小心</h3><p>这种情况一般发生在你在一个不好的范围内搜索超参数（比如学习率）的时候。比如我们使用<strong>learning_rate = 10 \</strong> uniform(-6,1)**来进行搜索。假设我们得到一个比较好的值-6，一定要确认你的值不是出于这个范围的边界上，不然你可能错过更好的其他搜索范围,就像这里可能-6是边界值而最好的结果在-8和-6之间。</p>
<h3 id="从粗到细地分阶段搜索"><a href="#从粗到细地分阶段搜索" class="headerlink" title="从粗到细地分阶段搜索"></a>从粗到细地分阶段搜索</h3><p>在实践中，先进行初略范围（比如10 ** [-6, 1]）搜索，然后根据好的结果出现的地方，缩小范围进行搜索。进行粗搜索的时候，让模型训练一个周期就可以了，因为很多超参数的设定会让模型没法学习，或者突然就爆出很大的损失值。第二个阶段就是对一个更小的范围进行搜索，这时可以让模型运行5个周期，而最后一个阶段就在最终的范围内进行仔细搜索，运行很多次周期。</p>
<h2 id="模型集成"><a href="#模型集成" class="headerlink" title="模型集成"></a>模型集成</h2><p>实践中有一个方法总是能提升神经网络几个百分点的准确率，即在训练的时候训练几个独立模型，然后在测试的时候平均它们的预测结果。集成的模型数量增加，算法的结果也单调提升（但提升效果越来越少）。还有模型之间的差异度越大，提升效果可能越好。进行集成有以下几种方法：</p>
<p>1.相同的模型，不同的初始化。</p>
<p>2.使用不同的超参数的模型。这些模型都是分别训练的。</p>
<p>3.如果训练太耗时，可以采用一次训练中不同的记录点（仆程序记录）的模型来进行集成。</p>
<p>4.在训练的时候跑参数的平均值。和上面一点相关的，还有一个也能得到1-2个百分点的提升的小代价方法，这个方法就是在训练过程中，如果损失值相较于前一次权重出现指数下降时，就在内存中对网络的权重进行一个备份。这样你就对前几次循环中的网络状态进行了平均。你会发现这个“平滑”过的版本的权重总是能得到更少的误差。直观的理解就是目标函数是一个碗状的，你的网络在这个周围跳跃，所以对它们平均一下，就更可能跳到中心去。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  我们利用反向传播计算出解析梯度，然后利用计算出的解析梯度来进行参数更新，这里记录一些有些的最优化技巧，但不进行细节分析。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Notes of CS231n:Neural network 3</title>
    <link href="http://yoursite.com/2018/03/10/Notes-of-Deep-Learning-Neural-network-3/"/>
    <id>http://yoursite.com/2018/03/10/Notes-of-Deep-Learning-Neural-network-3/</id>
    <published>2018-03-10T05:41:24.000Z</published>
    <updated>2018-03-12T08:37:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>  在上一篇文章中，记录了如何构造一个神经网络，比如如何初始化参数，如何选择激活函数和损失函数，应该用哪种方法来防止过拟合等等，在这篇记录中，记录的是如何训练一个神经网络，包括如何学习参数以及如何将超参数最优化。</p>
<a id="more"></a>
<h2 id="梯度检测"><a href="#梯度检测" class="headerlink" title="梯度检测"></a>梯度检测</h2><p>  梯度检测就是把解析梯度和数值梯度进行比较，这里只是记录一些小技巧：</p>
<h3 id="使用中心化公式而不是有限差值来近似"><a href="#使用中心化公式而不是有限差值来近似" class="headerlink" title="使用中心化公式而不是有限差值来近似"></a>使用中心化公式而不是有限差值来近似</h3><p>即使用[f(x+h)+f(x-h)]/2h来计算数值梯度，该公式计算出的梯度会近似于O(h^2)，该结果是通过对f(x+h)，f(x-h)进行泰勒展开得到的。</p>
<h3 id="使用相对误差来进行梯度检测"><a href="#使用相对误差来进行梯度检测" class="headerlink" title="使用相对误差来进行梯度检测"></a>使用相对误差来进行梯度检测</h3><p>我们知道数值梯度和解析梯度的差值正负值都有可能，很明显我们需要取这个差值的绝对值，但是我们不得不考虑实际梯度的大小，即我们要考虑这个误差绝对值占实际梯度的百分比，如果梯度是1000，误差是0.1和梯度是1e-4梯度是1.0，实际上比率是一样的，如果一个梯度是1而误差达到了0.5这个样子显然我们就得考虑梯度计算是不是错了。</p>
<p>所以我们利用|f’[a]-f’[n]|/max(f’[a],f’[n])来计算相对误差作为我们的误差值，这是一个比率值，我们倾向于在实践中采用这种判断：</p>
<p>相对误差&gt;1e-2时，梯度可能出错了</p>
<p>1e-2&gt;相对误差&gt;1e-4：这个值可能不是很好，但勉强说得过去</p>
<p>1e-4&gt;相对误差：可以接受</p>
<p>1e-7或者更小：比较完美了</p>
<h3 id="注意误差伴随深度积累"><a href="#注意误差伴随深度积累" class="headerlink" title="注意误差伴随深度积累"></a>注意误差伴随深度积累</h3><p><strong>有时候我们还是得视情况而定</strong>，要知道误差是在不断积累的，随着深度的加深误差也在不断增大，那么我们可以改变上面的策略，比如一个网络深度达到数十层时1e-2就是可以接受的了。</p>
<h3 id="注意目标函数中存在的不可导点"><a href="#注意目标函数中存在的不可导点" class="headerlink" title="注意目标函数中存在的不可导点"></a>注意目标函数中存在的不可导点</h3><p>ReLU等函数存在着不可导点，我们知道ReLU中如果出现了x&lt;0的情况，在该点梯度就是0，但是如果这个x值比较小，比如-0.000001我们增加了一个小的增量h，可能此时的h就不是负数了，f(x+h)在可导的点上，从而梯度检查认为这个梯度计算错了。</p>
<p><strong>使用少量数据点。</strong>解决上面的不可导点问题的一个办法是使用更少的数据点。因为含有不可导点的损失函数(例如：因为使用了ReLU或者边缘损失等函数)的数据点越少，不可导点就越少，所以在计算有限差值近似时越过不可导点的几率就越小。还有，如果你的梯度检查对2-3个数据点都有效，那么基本上对整个批量数据进行梯度检查也是没问题的。所以使用很少量的数据点，能让梯度检查更迅速高效。</p>
<h3 id="梯度检查中h的设置"><a href="#梯度检查中h的设置" class="headerlink" title="梯度检查中h的设置"></a>梯度检查中h的设置</h3><p>h并不是越小越好，太小了会遇到精度和数值问题，一般可以设置为1e-4或者1e-6</p>
<h3 id="梯度检查前先“预热”"><a href="#梯度检查前先“预热”" class="headerlink" title="梯度检查前先“预热”"></a>梯度检查前先“预热”</h3><p>我们的梯度检查只是在参数空间中一个特定的单独的点进行的，所以并不能很稳的确定全局梯度都正确。一般来说我们不再一开始就进行梯度检查，而是等到损失函数开始下降之后在进行梯度检查。</p>
<h3 id="当心正则化损失"><a href="#当心正则化损失" class="headerlink" title="当心正则化损失"></a>当心正则化损失</h3><p>上一文记录损失函数最后的值是正则化损失和数据损失的和，有些情况梯度主要来源于正则化部分，因此会掩盖数据损失梯度不正确的事实。为了防止这种情况出现我们可以先关掉正则化对数据损失做单独检查，当然这也做会导致我们需要再对正则化损失做单独检查。</p>
<h3 id="关闭随机失活和数据扩张"><a href="#关闭随机失活和数据扩张" class="headerlink" title="关闭随机失活和数据扩张"></a>关闭随机失活和数据扩张</h3><p>在进行梯度检查时，记得关闭网络中任何不确定的效果的操作，比如随机失活，随机数据扩展等。不然它们会在计算数值梯度的时候导致巨大误差。关闭这些操作不好的一点是无法对它们进行梯度检查（例如随机失活的反向传播实现可能有错误）我们可以在计算f(x+h)和f(x-h)时强制增加一个特定是随机种子，在计算解析梯度时也同样如此。</p>
<h3 id="检查少量的维度"><a href="#检查少量的维度" class="headerlink" title="检查少量的维度"></a>检查少量的维度</h3><p>在实际中，梯度可以有上百万的参数，在这种情况下只能检查其中一些维度然后假设其他维度是正确的。注意：确认在所有不同的参数中都抽取一部分来梯度检查。在某些应用中，为了方便，人们将所有的参数放到一个巨大的参数向量中。在这种情况下，例如偏置就可能只占用整个向量中的很小一部分，所以不要随机地从向量中取维度，一定要把这种情况考虑到，确保所有参数都收到了正确的梯度。</p>
<h2 id="跟踪各个重要数值"><a href="#跟踪各个重要数值" class="headerlink" title="跟踪各个重要数值"></a>跟踪各个重要数值</h2><p>  跟踪并可视化我们的训练过程可以让我们尽早的发现一些问题，我们所跟踪的一般是一些比较重要的数值，我们通常每个<strong>周期</strong>进行一轮跟踪，这里的<strong>周期</strong>衡量了在训练中每个样本数据都被观察过次数的期望（一个周期意味着每个样本数据都被观察过了一次）。</p>
<p>1.跟踪损失值</p>
<p>以周期为x轴度量，损失值的曲线往往会反应我们所设置的学习率的问题，比如：</p>
<p><img src="\img\loss_learningrate.png" alt="loss_learningrate"></p>
<p>上图左图中我们可以观察到学习率与损失值的关系，右图则反应了损失值的震荡程度，这与批尺寸（batch size）有关（这里的批指的是我们一般把训练集拆分成多个批次，每次取一个训练），如果批尺寸太小了比如1，那么每次修正方向以各自样本的梯度方向修正，难以达到收敛震荡幅度就大，而如果以整个训练集大小为批尺寸则震荡幅度最小，但是这并不是一个好的想法，首先内存容量增加，第二我们可能得不到最好的结果，batchsize 的正确选择是为了在内存效率和内存容量之间寻找最佳平衡，比如我们可以看下图：</p>
<p><img src="\img\lU3sx.png" alt="lU3sx"></p>
<p>红色代表批尺寸为1，绿色为一个适中的尺寸，蓝色为不分批次，即全尺寸，我们可以观察到震荡程度是不同的。</p>
<p>2.跟踪训练集和验证集的准确率</p>
<p>跟踪准确率可以知道我们的模型是不是过拟合了，如图：</p>
<p><img src="\img\QQ图片20180310170549.png" alt="QQ图片20180310170549"></p>
<p>如果观察到我们的模型过拟合了，就应该增大正则化强度，比如调高随机失活率p，或者将L1损失换位到L2损失，采用更丰富的数据集等等，当然如果你的模型太小也会导致过拟合，这时候我们就应该考虑更换更大的模型了。</p>
<p>3.跟踪权重的跟新比例</p>
<p>  权重中更新值的数量和全部值的数量之间的比例也是我们值得更新的。注意：是<em>更新的</em>，而不是原始梯度（比如，在普通sgd中就是梯度乘以学习率）。需要对每个参数集的更新比例进行单独的计算和跟踪。一个经验性的结论是这个比例应该在1e-3左右。如果更低，说明学习率可能太小，如果更高，说明学习率可能太高。</p>
<p>4.跟踪每层激活数据和梯度分布</p>
<p>  我们可以观察激活函数的输出，把这些数据变成柱状与表示会更明显，比如对于tanh函数，如果神经元输出总是0，或者总是-1或1，那说明可能出现了某些问题了。</p>
<p>5.如果是图像数据考虑将第一层特征可视化</p>
<p>如果需要做的是图像方面的识别，我们考虑将第一层特征显示出来，比如：</p>
<p><img src="\img\96573094f9d7f4b3b188069726840a2e_r.jpg" alt="96573094f9d7f4b3b188069726840a2e_r"></p>
<p>  上图中，很明显前面的图，特征非常不平滑，很多噪点，而后面则好得多，一般如果我们训练模型得到的是第一张图这种特征你需要仔细考虑是不是要重新训练模型了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  在上一篇文章中，记录了如何构造一个神经网络，比如如何初始化参数，如何选择激活函数和损失函数，应该用哪种方法来防止过拟合等等，在这篇记录中，记录的是如何训练一个神经网络，包括如何学习参数以及如何将超参数最优化。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Notes of CS231n:Neural network 2</title>
    <link href="http://yoursite.com/2018/03/01/Notes-of-Deep-Learning-Neural-network-2/"/>
    <id>http://yoursite.com/2018/03/01/Notes-of-Deep-Learning-Neural-network-2/</id>
    <published>2018-03-01T02:26:43.000Z</published>
    <updated>2018-03-12T08:36:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>  从上一篇博文，我们知道，神经网络其实就是一个一系列线性映射和非线性激活函数交织起来的评分函数，我们在输入层输入我们的数据，经过隐层的一系列点积和激活函数计算在输出层得到一个类型评分，然而要比较好地训练一个神经网络，我们需要更多的考虑，比如数据预处理，我们还需要考虑权重的初始值以及如何选择激活函数。</p>
<h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>  我们通常会对<strong>训练集</strong>数据进行预处理，当然这可能有很多种形式，比如我们如果要去除一些噪声可能要进行数据清洗，这一部分这里先不介绍了，我们这里主要介绍归一化，归一化可以有利于避免模型训练时出现数值问题，还有利于网络快速收敛，更具体的优点你可以查看<a href="http://nnetinfo.com/nninfo/showText.jsp?id=37" target="_blank" rel="external">这里</a>。</p>
<p>  归一化（Normalization）即把数据的所有维度都归一化，使其数值范围都近似相等，这个种预处理操作只在确信不同输入特征有不同的输入范围时才有意义，对于图像处理中，像素的范围都是0-255，所以这样做对于图片数据意义不大，但是数据如果是表示一个人，（体重（kg），身高（m），年龄）,这样的数据显然60Kg的体重和1.7m的身高不太对等，这会产生一些数值问题，我们有必要进行归一化。这里有两种方式进行<strong>归一化</strong>：</p>
<p>先假设数据矩阵M，尺寸是N*D,N为样本数目，D是数据维度</p>
<p>第一种：对数据先做零中心化(zero-centered)，如果用numpy表示：M-=np.mean(X,axis=0)，然后我们对每个维度都除以它的标准差就可以了，M/=np.std(X,axis=0)。</p>
<p>第二种：对每个维度归一化使得每个维度的最大和最小值是1和-1。</p>
<a id="more"></a>
<p>  实际上零中心化单独也可以看成是一种预处理操作，被称作是<strong>均值减法</strong>在实际中用的也比较多，另外由于近来BN层的引入，归一化在有BN层的情况下也就没有必要了，因为每次卷积后BN层会把数据拉到0均值1方差的分布（标准高斯分布）上，并且这个均值和方差还是更加精确的动态统计出来的，而非原始输入上统计，因此在BN引入后归一化没什么必要。</p>
<p>  我在前面就说过，数据预处理，归一化只是一种情况，还可能进行数据清洗，数据增强，白化和PCA等等操作，图片处理中有时候我们还会转换图片的格式，这也是一种预处理。预处理在模型训练中非常重要，有时候甚至决定着学习算法本身的好坏。</p>
<h2 id="权重初始化"><a href="#权重初始化" class="headerlink" title="权重初始化"></a>权重初始化</h2><p>  要训练我们的网络，我们确定好我们需要一个怎么样的模型，然后构建一个最开始的网络，这样的话，网络中各种参数的初始值就显得非常重要，权重就是其中之一。</p>
<p>  一些人可能会认为把权重都设置为0比较好，然而仔细思考一下，如果一开始整个网络中每一个神经元的输出都是一样的（权重相同），那么反向传播中他们会输出同样的梯度，从而进行同样的更新，这显然就是不对的，你相当于复制了神经元。</p>
<p>  因为数据进行了适当的归一化，又要避免相同的参数更新，我们可以让权重的初始值接近于0，但是却又不等于0，为了得到不同的权重，我们可以以随机数产生器器来初始化我们的权重，这里我们产生的随机数可以服从正态分布或者均匀分布。需要注意的时，最好不要让随机值太小，因为太小的权重值会导致计算出的额梯度非常小，以至于一致我们在反向传播中的梯度信号。</p>
<p>  为了保证神经元起始时有近似相同的输出分布，我们必须想办法校准方差，一般的方法是采用1/sqrt(N)，来做校准，其中N是输入数据的数量，这样我们可以把输出数据的分布的方差校准到1，如果用numpy表示，即：w=np.random.randn(N)/sqrt(n)。</p>
<p>  有一种被称作<strong>稀疏初始化</strong> 的方法，将索引权重设置为0，但是为了避免相同的参数更新，每个神经元都同下一层固定数目的神经元随机连接，连接权重的数值由一个小的高斯分布生成。</p>
<p>  当前比较推荐的方法是在激活函数是ReLU的情况下使用，w=np.random.randn(N)/sqrt(2/n)来进行权重初始化，另外我们一般把偏置设置为0。</p>
<p>  上面介绍数据预处理的时候我们提到过一个被称为BN层(Batch Normalization)的东西，中文翻译是：<strong>批量归一化</strong>，它不仅可以避免<strong>归一化</strong>操作，也可以帮助我们解决初始化神经网络这个问题，我们通常会在全连接或者卷积层与激活函数之间添加一个BN层，让数据服从标准高斯分布，详细操作可以看这篇<a href="https://arxiv.org/abs/1502.03167" target="_blank" rel="external">文章</a>。</p>
<h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><p>  我们在上一篇文章中知道了，正则化是避免过拟合的好方法，正则化也有很多种,比如最常见的L2正则化，以及你听的非常多的随机失活(dropout)方法。</p>
<h3 id="L1，L2正则化"><a href="#L1，L2正则化" class="headerlink" title="L1，L2正则化"></a>L1，L2正则化</h3><p>1.L2正则化</p>
<p>  <strong>L2正则化的思想是对大数值的权重向量进行严厉的惩罚，从而倾向于权重向量更加分散，即使网络更倾向于使用所有的特征。</strong>实际操作是对网络中的每个权重w，向目标函数中增加一个<strong>1/2（λ*w^2)</strong>,λ是正则化强度，而乘上常数1/2是数学上的小技巧，即让求导后梯度变成λw，而非2λw。在梯度下降和参数更新的时候，使用L2正则化意味着所有的权重都以<strong>w += -lambda * W</strong>向着0线性下降。</p>
<p>2.L1正则化</p>
<p>  <strong>L1正则化则倾向于让神经元最后使用它们最重要输入数据的稀疏子集，可看做特征选择</strong>，它的实际操作是对每个w都像目标函数增加一个λ*|w|，这样的话，你可以知道求导的时候，附加项的导数就与w的符号有关，如果w为正，最优化更新后的w变小（相比与没有添加L1正则项时），如果为负则更新后的w变大，即尽可能使权重值为0。在w为0时，我们把取符号的sgn(w）看作是0，即sgn(0)=0,sgn(w&gt;0)=1,sgn(w&lt;0)=-1。</p>
<p>一般来说，实践更倾向于使用L2正则化，除非我们需要特征选择。</p>
<h3 id="随机失活"><a href="#随机失活" class="headerlink" title="随机失活"></a>随机失活</h3><p>  目前我们经常看到随机失活(dropout)的字眼，<strong>其与L1，L2正则化，以及最大范式约束的方法互为补充</strong>，实际操作过程中，随机失活即是让神经元以超参数p为概率被设置为0或者被激活,<strong>p一般设置为0.5</strong>，这样我们可以看做对完整的神经网络抽样出一些子集，每次基于输入数据只更新子网络的参数。</p>
<p><img src="\img\dropout.jpg" alt="dropout"></p>
<p>  但实际上我们更倾向于使用Inverted dropout，这是因为如果我们在训练网络时使用前向随机失活，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_step</span><span class="params">(X)</span>:</span></div><div class="line">  <span class="comment"># 3层neural network的前向传播</span></div><div class="line">  H1 = np.maximum(<span class="number">0</span>, np.dot(W1, X) + b1)</div><div class="line">  U1 = np.random.rand(*H1.shape) &lt; p <span class="comment"># 第一个随机失活遮罩</span></div><div class="line">  H1 *= U1 <span class="comment"># drop!</span></div><div class="line">  H2 = np.maximum(<span class="number">0</span>, np.dot(W2, H1) + b2)</div><div class="line">  U2 = np.random.rand(*H2.shape) &lt; p <span class="comment"># 第二个随机失活遮罩</span></div><div class="line">  H2 *= U2 <span class="comment"># drop!</span></div><div class="line">  out = np.dot(W3, H2) + b3</div></pre></td></tr></table></figure>
<p>  上面这段代码中有p的概率，神经元会被激活，而又1-p的概率神经元会被设置为0，然后流向下一层，那么我们可以知道在随机失活进行后，输出为px，而在我们的测试过程中并不存在随机失活层，所以神经元对输入都是可见的，那么为了保持同样的预期输出，我们必须在测试时把输出结果乘以p,来缩放激活函数输出结果，以防止测试输出数值范围大于训练输出，如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(X)</span>:</span></div><div class="line">  <span class="comment"># 前向传播时模型集成</span></div><div class="line">  H1 = np.maximum(<span class="number">0</span>, np.dot(W1, X) + b1) * p <span class="comment"># 注意：激活数据要乘以p</span></div><div class="line">  H2 = np.maximum(<span class="number">0</span>, np.dot(W2, H1) + b2) * p <span class="comment"># 注意：激活数据要乘以p</span></div><div class="line">  out = np.dot(W3, H2) + b3</div></pre></td></tr></table></figure>
<p>  这样的话测试时要多乘一次p显得非常麻烦，为了让我们的测试效率更高，各种深度学习框架中实践的其实是inverted dropout,有翻译为<strong>反向随机失活</strong>，个人觉得这个翻译不太好，<strong>其实它就是在训练阶段对激活函数输出值进行放大，即是放大1/p倍，而测试阶段则保持不变。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_step</span><span class="params">(X)</span>:</span></div><div class="line">  <span class="comment"># 3层neural network的前向传播</span></div><div class="line">  H1 = np.maximum(<span class="number">0</span>, np.dot(W1, X) + b1)</div><div class="line">  U1 = (np.random.rand(*H1.shape) &lt; p) / p <span class="comment"># 第一个随机失活遮罩. 注意/p!</span></div><div class="line">  H1 *= U1 <span class="comment"># drop!</span></div><div class="line">  H2 = np.maximum(<span class="number">0</span>, np.dot(W2, H1) + b2)</div><div class="line">  U2 = (np.random.rand(*H2.shape) &lt; p) / p <span class="comment"># 第二个随机失活遮罩. 注意/p!</span></div><div class="line">  H2 *= U2 <span class="comment"># drop!</span></div><div class="line">  out = np.dot(W3, H2) + b3</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(X)</span>:</span></div><div class="line">  <span class="comment"># 前向传播时模型集成</span></div><div class="line">  H1 = np.maximum(<span class="number">0</span>, np.dot(W1, X) + b1) <span class="comment"># 不用数值范围调整了</span></div><div class="line">  H2 = np.maximum(<span class="number">0</span>, np.dot(W2, H1) + b2)</div><div class="line">  out = np.dot(W3, H2) + b3</div></pre></td></tr></table></figure>
<h2 id="损失函数的选择"><a href="#损失函数的选择" class="headerlink" title="损失函数的选择"></a>损失函数的选择</h2><p>  我们知道在<strong>分类问题中</strong>两个最常见的分类器对应的损失计算：</p>
<p>  SVM-&gt;折页损失/平方折页损失（下图没列出）</p>
<p>  Softmax-&gt;交叉熵损失</p>
<p><img src="\img\loss.jpg" alt="loss"></p>
<p>  如果我们面对的不是一个一般的分类问题，怎么办呢？上面的几种损失公式都只正确作用在每个样本只有一个正确的标签yi的假设成立的情况之下。但是你可以看到，在hexo博客中的一篇文章是可以打几个标签的，亦或者是新浪微博上的一张图片，比如你的女神正在日本旅游，发了一张在清水寺前不知道谁给它拍了一张照，可以打上美女，日本旅游，快乐等等几个标签。我们可以采取下面的一种损失评分策略：</p>
<p><img src="\img\loss2.png" alt="loss2"></p>
<p>其中yij的值为1或者-1，它表示第i个样本是否被贴上第j个标签，如果是就是1，如果不是就是-1，这样的话，可以发现，当一个正样本的得分小于+1，或者一个负样本得分大于-1的时候，算法就会累计损失值。</p>
<p>  再比如回归问题，比如你要预测北京的空气质量pm2.5的值，一般我们考虑计算预测值和真实值之间的损失，再用L2或者L1范式度量差异。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  从上一篇博文，我们知道，神经网络其实就是一个一系列线性映射和非线性激活函数交织起来的评分函数，我们在输入层输入我们的数据，经过隐层的一系列点积和激活函数计算在输出层得到一个类型评分，然而要比较好地训练一个神经网络，我们需要更多的考虑，比如数据预处理，我们还需要考虑权重的初始值以及如何选择激活函数。&lt;/p&gt;
&lt;h2 id=&quot;数据预处理&quot;&gt;&lt;a href=&quot;#数据预处理&quot; class=&quot;headerlink&quot; title=&quot;数据预处理&quot;&gt;&lt;/a&gt;数据预处理&lt;/h2&gt;&lt;p&gt;  我们通常会对&lt;strong&gt;训练集&lt;/strong&gt;数据进行预处理，当然这可能有很多种形式，比如我们如果要去除一些噪声可能要进行数据清洗，这一部分这里先不介绍了，我们这里主要介绍归一化，归一化可以有利于避免模型训练时出现数值问题，还有利于网络快速收敛，更具体的优点你可以查看&lt;a href=&quot;http://nnetinfo.com/nninfo/showText.jsp?id=37&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;  归一化（Normalization）即把数据的所有维度都归一化，使其数值范围都近似相等，这个种预处理操作只在确信不同输入特征有不同的输入范围时才有意义，对于图像处理中，像素的范围都是0-255，所以这样做对于图片数据意义不大，但是数据如果是表示一个人，（体重（kg），身高（m），年龄）,这样的数据显然60Kg的体重和1.7m的身高不太对等，这会产生一些数值问题，我们有必要进行归一化。这里有两种方式进行&lt;strong&gt;归一化&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;先假设数据矩阵M，尺寸是N*D,N为样本数目，D是数据维度&lt;/p&gt;
&lt;p&gt;第一种：对数据先做零中心化(zero-centered)，如果用numpy表示：M-=np.mean(X,axis=0)，然后我们对每个维度都除以它的标准差就可以了，M/=np.std(X,axis=0)。&lt;/p&gt;
&lt;p&gt;第二种：对每个维度归一化使得每个维度的最大和最小值是1和-1。&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Notes of CS231n:Neural network 1</title>
    <link href="http://yoursite.com/2018/02/28/Notes-of-Deep-Learning-Neural-network-1/"/>
    <id>http://yoursite.com/2018/02/28/Notes-of-Deep-Learning-Neural-network-1/</id>
    <published>2018-02-28T07:17:09.000Z</published>
    <updated>2018-03-12T08:37:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="人工神经元"><a href="#人工神经元" class="headerlink" title="人工神经元"></a>人工神经元</h2><p>  其实神经元这个翻译有点唬人，有些学者也不喜欢借用某些生物词语来蹭热度，他们直接就把所谓的人工神经元称之为单元（unit），结合人工神经网络来看的话，你可以很容易的推测出，它是由这个所谓的人工神经元组成的。在一个人工神经网络中，神经元间会有一种单向的影响，因为人工神经网络可以看做是一张有向无环图。下图是一个常见的粗糙模型：</p>
<div align="center"><br><br><img width="600px" src="\img\QQ图片20180214181505.png"><br><br><img src="\img\QQ图片20180214180333.jpg"><br><br></div>

<p>从这张图中你可以看到，一个人工神经元有几个主要的部分，如果你把它看做是有向无环图里的一个节点，那么你可以观察到它的每一个入度，分别对应一个不同的输入和一个自身权重的乘积（w和x都是向量或者矩阵，这里准确来说应该是<strong>点积</strong>），所有入度的点积的累加加上节点对应的偏差值（偏置）(Σwixi+b）代入所入节点的激活函数，图中就是f，对应为f(Σwixi+b),然后这个输出结果（<strong>激活率</strong>）顺着节点的出度流入下一层网络中的神经元。</p>
<p>  现在你大概知道什么是所谓的人工神经元，如果硬要跟生物神经元扯上一毛钱关系的话，你学过高中生物，大概会知道突触，树突，突触小泡之类的，你也许能把这个和两个神经细胞里通过突触来传递兴奋的机制联系起来…然后对别人吹嘘一波，但是我是做不到的，可能是我不怎么了解生物吧。 </p>
<a id="more"></a>
<h2 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h2><p>  认识了人工神经元之后，我们就知道了这里面有一个叫做<strong>激活函数（activation function）</strong>的重要概念，激活函数的选择对最终训练出来的模型影响是很大的，如果你以前看过一些公众号中推送的文章，可能会经常看到Sigmoid和Tanh这样的字眼，这是都是激活函数的名称，但是你不要看着这些名字这么奇怪就觉得这个函数会不会很复杂啊，其实稍微用点脑子思考一下就知道激活函数不能是多么复杂的函数，因为我们最后需要通过反向传播这样的算法去计算梯度，从而进行参数调优，如果这个激活函数是非常复杂的，这个梯度就不太好算了，激活函数通常都是非线性函数，目的是为了模型有更强的表达能力，详情可以<a href="https://www.zhihu.com/question/22334626" target="_blank" rel="external">参考这里</a>，排名前几的答案基本上把这个问题讲清楚了。这里我记录3个激活函数：</p>
<h3 id="S型函数"><a href="#S型函数" class="headerlink" title="S型函数"></a>S型函数</h3><p>  S型函数就是Sigmoid，如果在你学高等数学或者微积分的时候，肯定是接触过这个函数的，这个函数由于它在平面直角坐标系上的曲线而得名。即：</p>
<blockquote>
<p>σ（x）=1/(1+e^(-x))</p>
</blockquote>
<p><img src="\img\QQ图片20180214194819.png" alt="QQ图片20180214194819"></p>
<h3 id="Tanh函数"><a href="#Tanh函数" class="headerlink" title="Tanh函数"></a>Tanh函数</h3><p>  Tanh函数是有S型函数转化过来的零中心函数，Tanh比S型函数更受欢迎，但是他们存在着饱和问题，即在接近极值的区间，梯度几乎为0，训练模型的时候使用反向传播算法，一个接近0的梯度反向传播下去，小数相乘会以指数形式收缩到0。</p>
<blockquote>
<p>tanh=2σ(2x)-1=2/(1+e^(-2x))-1</p>
</blockquote>
<p><img src="\img\QQ图片20180214195043.png" alt="QQ图片20180214195043"></p>
<h3 id="ReLU函数"><a href="#ReLU函数" class="headerlink" title="ReLU函数"></a>ReLU函数</h3><p>目前最流行的激活函数,非常简单粗暴有效,名字的由来是Rectified Linear Unit-&gt;ReLU</p>
<blockquote>
<p>ReLu(x)=max(0,x)</p>
</blockquote>
<p><img src="\img\QQ图片20180214200631.png" alt="QQ图片20180214200631"></p>
<h2 id="神经网络结构"><a href="#神经网络结构" class="headerlink" title="神经网络结构"></a>神经网络结构</h2><p>我们通过一个普通的神经网络来展开对它的层结构认知，比如下面这个两层的网络：</p>
<p><img src="\img\NN.jpg" alt="NN"></p>
<p>  一般来说输入层是不算做层数的，所以说这个网络是2层，即一个隐层和输出层，当然有些网络有很多隐层，我们在这个图片上看到的是一个有向无环图，但是经过前面的理解，你知道实际上它是一个做矩阵点积的数学函数。</p>
<p>  在这个普通的网络中，它的层都是<strong>全连接层</strong>，全连接层中的神经元与其前后两层的神经元是完全成对连接的，但是在同一个全连接层内的神经元之间没有连接。</p>
<p>  在神经网络中，输出层是没有激活函数的，因为它用来完成分类的打分。有时候我们要表示一个神经网络的尺寸，比如上面那个神经网络是怎么样的尺寸呢，它有着4（隐层）+2（输出层）=6个神经元，因为是全连接的，它有着3*4+4*2=20个权重，以及4+2=6个偏置，权重和偏置都是可学习的，那么我们训练这个神经网络的时候需要学习这个26个参数，以最优化算法求得他们的最优值。这样看起来似乎比较清晰了，但是一般的卷积神经网络有着10-20层，1亿个可学习参数，要求这个1一个参数的最优值可不是一个简单的工程，这也是为什么大部分做深度学习的同学都处在调参的路上的原因了。</p>
<p>  是不是层数越多的神经网络越好呢?视情况而定，一般的神经网络就是3层网络，再增加层数很难增强它的表达力度，而卷积神经网络则不同，因为要提取层次化特征，所以深度就是一个很重要的问题，一般都是数十层之多，谈到这个问题，我们又有新的问题，如何设置神经网络的层数和尺寸。我们知道神经网络其实是一个函数，如果在有着相同激活函数的情况下，整个函数更为复杂，则函数的表达能力就能更强，但是也会引起<strong>过拟合</strong>等问题，<strong>过拟合</strong>是指网络对数据中的噪点拟合过甚，导致整个模型的泛化能力不强。</p>
<p>  即便大的网络会有过拟合问题，我们还是会使用更大一点的网络作为模型，因为防止过拟合还有其他的方法，比如<strong>L2正则化或者dropout</strong>，特别是正则化。因此我们没有必要去牺牲整个网络模型的表达能力去换去泛化能力。另外小网络的极小值很容易收敛到，但是这些极值的损失值一般都很高，不利于我们构建一个优秀的模型，而大的网络极小值更多，虽然更不容易收敛，但是我们可以有更多的选择，从而得到一个更好的模型。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;人工神经元&quot;&gt;&lt;a href=&quot;#人工神经元&quot; class=&quot;headerlink&quot; title=&quot;人工神经元&quot;&gt;&lt;/a&gt;人工神经元&lt;/h2&gt;&lt;p&gt;  其实神经元这个翻译有点唬人，有些学者也不喜欢借用某些生物词语来蹭热度，他们直接就把所谓的人工神经元称之为单元（unit），结合人工神经网络来看的话，你可以很容易的推测出，它是由这个所谓的人工神经元组成的。在一个人工神经网络中，神经元间会有一种单向的影响，因为人工神经网络可以看做是一张有向无环图。下图是一个常见的粗糙模型：&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;img width=&quot;600px&quot; src=&quot;\img\QQ图片20180214181505.png&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;\img\QQ图片20180214180333.jpg&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;/div&gt;

&lt;p&gt;从这张图中你可以看到，一个人工神经元有几个主要的部分，如果你把它看做是有向无环图里的一个节点，那么你可以观察到它的每一个入度，分别对应一个不同的输入和一个自身权重的乘积（w和x都是向量或者矩阵，这里准确来说应该是&lt;strong&gt;点积&lt;/strong&gt;），所有入度的点积的累加加上节点对应的偏差值（偏置）(Σwixi+b）代入所入节点的激活函数，图中就是f，对应为f(Σwixi+b),然后这个输出结果（&lt;strong&gt;激活率&lt;/strong&gt;）顺着节点的出度流入下一层网络中的神经元。&lt;/p&gt;
&lt;p&gt;  现在你大概知道什么是所谓的人工神经元，如果硬要跟生物神经元扯上一毛钱关系的话，你学过高中生物，大概会知道突触，树突，突触小泡之类的，你也许能把这个和两个神经细胞里通过突触来传递兴奋的机制联系起来…然后对别人吹嘘一波，但是我是做不到的，可能是我不怎么了解生物吧。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Junit(4):Mock</title>
    <link href="http://yoursite.com/2018/02/01/Junit-4-Mock/"/>
    <id>http://yoursite.com/2018/02/01/Junit-4-Mock/</id>
    <published>2018-02-01T08:29:46.000Z</published>
    <updated>2018-02-01T15:39:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>  就像上篇文章所说，我们还可以用mock方式模拟一个没有完成的模块，从而完成测试，事实上如果测试的业务比较繁琐，比如涉及到输入啥的，我们也可以mock一个假的输入对象，mock object是在极限编程里提出的，而今天它已经广泛用于软件测试领域。</p>
<p>  就如mock这个单词的词义一样，mock object即是一个模制的对象，但这个对象的行为是人为故意给定的，不包含实际的业务。这样说可能非常抽象，如果让我们考虑用<strong>Scala</strong>写一个在商店里用pos机刷卡的例子,比如我们刷卡并且输入密码后会构造出这样的一个CreditCard对象：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">CreditCard</span>(<span class="params">val cardId:<span class="type">String</span>,val password:<span class="type">String</span></span>)</span></div></pre></td></tr></table></figure>
<p> 而我们的Pos机要负责转账处理：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pos</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">transfer</span></span>(amount:<span class="type">Double</span>,creditCard: <span class="type">CreditCard</span>, creditCard2: <span class="type">CreditCard</span>, accountManager: <span class="type">AccountManager</span>): <span class="type">Unit</span> = &#123;</div><div class="line">    <span class="keyword">val</span> account1: <span class="type">Account</span> = accountManager.findAccount(creditCard.cardId, creditCard.password);</div><div class="line">    <span class="keyword">val</span> account2: <span class="type">Account</span> = accountManager.findAccount(creditCard2.cardId, creditCard2.password);</div><div class="line">    accountManager.saveAccount(account1.copy(account1.balance - amount,account1.creditCard))</div><div class="line">    accountManager.saveAccount(account2 copy(account2.balance + amount, account2.creditCard))</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>，但是问题是此时我们根本没有构造号银行卡账户数据库，甚至我们连dao对象都只是一个接口，那么为了测试Pos代码逻辑能不能正确执行我们该怎么办呢？</p>
<a id="more"></a>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">trait</span> <span class="title">AccountManager</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">saveAccount</span></span>(account: <span class="type">Account</span>)</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">findAccount</span></span>(cardId: <span class="type">String</span>, password: <span class="type">String</span>): <span class="type">Account</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>答案是我么可以建立一个mock object，这不仅可以很容易的测试Pos的代码逻辑，而且节省了很大的开销，设想一下，如果真正的去测试，我们不仅要确定整个容器环境无误，还要不断地去访问数据库，这肯定是不可以忍受的。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MockAccountManager</span>(<span class="params"></span>) <span class="keyword">extends</span> <span class="title">AccountManager</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> accounMap = <span class="type">Map</span> (</div><div class="line">      (<span class="string">"1001"</span>, <span class="type">Account</span>(<span class="number">1000</span>, <span class="type">CreditCard</span>(<span class="string">"1001"</span>, <span class="string">"123"</span>)))</div><div class="line">      , (<span class="string">"1002"</span>, <span class="type">Account</span>(<span class="number">1000</span>, <span class="type">CreditCard</span>(<span class="string">"1002"</span>, <span class="string">"123"</span>)))</div><div class="line">      )</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">findAccount</span></span>(cardId: <span class="type">String</span>, password: <span class="type">String</span>): <span class="type">Account</span> = &#123;</div><div class="line">      <span class="keyword">val</span> x=accounMap(cardId)</div><div class="line">      x <span class="keyword">match</span> &#123;</div><div class="line">        <span class="keyword">case</span> <span class="type">Account</span>(_,password)=&gt;x</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">saveAccount</span></span>(account: <span class="type">Account</span>): <span class="type">Unit</span> = &#123;</div><div class="line">      accounMap = accounMap ++ <span class="type">Map</span> (</div><div class="line">        (account.creditCard.cardId, account)</div><div class="line">        )</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样我们就可以利用这个，简单的mock object去测试我们的Pos逻辑了：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">testTransfer</span></span>(): <span class="type">Unit</span> = &#123;</div><div class="line">  <span class="keyword">val</span> pos = <span class="keyword">new</span> <span class="type">Pos</span>();</div><div class="line">  <span class="keyword">val</span> card = <span class="keyword">new</span> <span class="type">CreditCard</span>(<span class="string">"1001"</span>, <span class="string">"123"</span>)</div><div class="line">  <span class="keyword">val</span> card2 = <span class="keyword">new</span> <span class="type">CreditCard</span>(<span class="string">"1002"</span>, <span class="string">"123"</span>)</div><div class="line">  <span class="keyword">val</span> acm = <span class="keyword">new</span> <span class="type">MockAccountManager</span>()</div><div class="line">  pos.transfer(<span class="number">100.2</span>, card, card2, acm)</div><div class="line">  assertEquals(acm.findAccount(card2.cardId, card2.password).balance,<span class="number">1100.2</span>d,<span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  我在这里手动写了一个mock object仅仅是为了演示一下大概的思想，实际上我们不需要手动写mock object，有大量的框架帮助我们完成这一点，比如在jvm平台上就有Jmock，EasyMock,Mockito等等，它们借助jvm的反射机制，以代理模式动态的生成了一个新的对象，我们可以给定这个对象特定方法的特定输入输出，十分方便，比如对于猜数字游戏：</p>
<p>随机给定一个4位数字，且每一位的数字都不重复，然后玩家在不知道这个数字的情况下输入一个4位数字每一位都不重复，如果位置相同且数字也相同就得到一个A，如果数字存在但是位置不同就得到B。</p>
<p>如：</p>
<p>给定1234,玩家猜测为1256，则结果为2A0B</p>
<p>给定1234，玩家猜测为3412，则结果为0A4B</p>
<p>如果玩家在6次之内得到了4A0B结果，就输出玩家胜利。</p>
<p>这样的话，我们可以来写一个简单的程序：</p>
<p>首先我们需要输入和输出,以下两个类用来读取数字和输出一个字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//输入</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberReader</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        String inputNumber = scanner.next();</div><div class="line">        <span class="keyword">if</span> (StringUtils.isNumeric(inputNumber) &amp;&amp; inputNumber.length() == <span class="number">4</span>) &#123;</div><div class="line">            <span class="keyword">return</span> inputNumber;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Invalid Input"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//输出</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Printer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(String message)</span> </span>&#123;</div><div class="line">        System.out.println(message);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们需要一个随机数字生成器,它可以随机生成一个4位不同数字组成的字符串：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberGenerator</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generate</span><span class="params">()</span> </span>&#123;</div><div class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>);</div><div class="line">        Collections.shuffle(list);</div><div class="line">        <span class="keyword">return</span> String.join(<span class="string">""</span>, list.subList(<span class="number">0</span>, <span class="number">4</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们需要一种数字类,它有一个比较方法，输出xAxB这样的表示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Number</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NUMBER_LENGTH = <span class="number">4</span>;</div><div class="line">    <span class="keyword">private</span> String value;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Number</span><span class="params">(String value)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.value = value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">compare</span><span class="params">(String stringToCompare)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NUMBER_LENGTH; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (value.charAt(i) == stringToCompare.charAt(i)) &#123;</div><div class="line">                a++;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value.contains(stringToCompare.substring(i, i + <span class="number">1</span>))) &#123;</div><div class="line">                b++;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> a + <span class="string">"A"</span> + b + <span class="string">"B"</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后我们把上面的组件组成一个游戏：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Game</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String WIN_CODE = <span class="string">"4A0B"</span>;</div><div class="line">    <span class="keyword">private</span> Printer printer;</div><div class="line">    <span class="keyword">private</span> Number generatedNumber;</div><div class="line">    <span class="keyword">private</span> NumberReader reader;</div><div class="line"></div><div class="line">    <span class="comment">//我们有6次机会</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> remainingGuessCount = <span class="number">6</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Game</span><span class="params">(NumberGenerator numberGenerator, Printer printer, NumberReader reader)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.printer = printer;</div><div class="line">        <span class="keyword">this</span>.reader = reader;</div><div class="line">        <span class="keyword">this</span>.generatedNumber = <span class="keyword">new</span> Number(numberGenerator.generate());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</div><div class="line">        printer.print(<span class="string">"please input a 4 digit number:"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (remainingGuessCount &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">              <span class="comment">//比较数字输入和生成的随机数</span></div><div class="line">                String result = generatedNumber.compare(reader.read());</div><div class="line">                <span class="keyword">if</span> (WIN_CODE.equals(result)) &#123;</div><div class="line">                    printer.print(<span class="string">"you win"</span>);</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                printer.print(result);</div><div class="line">                <span class="keyword">this</span>.remainingGuessCount--;<span class="comment">//机会使用了一次，所以减少</span></div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                printer.print(e.getMessage());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        printer.print(<span class="string">"Game Over"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在我们有一个简单的游戏了，如果玩家6次内猜对了4A0B，那么就输出you win,否则输出Game Over。现在我们要对这个游戏进行测试，但是我们可能会遇到以下的问题：</p>
<p>1.我们需要自动测试，而不是每次都手动输入</p>
<p>这是一个问题，我们的输入类NumberReader，调用的是系统的System.in但是我们却要求自动化测试，而不是每次手动输入，既然如此，我们就需要一种mock object，以代理的手段自动返回我们想输入的数字，我们可以自己手写字段反射，覆盖掉输入流，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberReaderTest</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> NumberReader reader = <span class="keyword">new</span> NumberReader();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setInputStream</span><span class="params">(String input)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</div><div class="line">        Field scannerField = reader.getClass().getDeclaredField(<span class="string">"scanner"</span>);</div><div class="line">        scannerField.setAccessible(<span class="keyword">true</span>);</div><div class="line">        Scanner scannerWithMockedStream = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> ByteArrayInputStream(input.getBytes()));</div><div class="line">        scannerField.set(reader, scannerWithMockedStream);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldReadNumber</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        setInputStream(<span class="string">"1234"</span>);</div><div class="line">        assertEquals(<span class="string">"1234"</span>, reader.read());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Test</span>(expected = Exception.class)</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldThrowExceptionForNonNumberInput</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        setInputStream(<span class="string">"123d"</span>);</div><div class="line">        reader.read();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>手写是一种手段，我们可以理解框架大概是怎么做到的，当然其实可以用代理来做，现实情况中我们能够使用mock框架，这里我用的是<a href="https://github.com/mockito/mockito" target="_blank" rel="external">mockito</a>,当然你也可以用其他的框架：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.junit.Before;</div><div class="line"><span class="keyword">import</span> org.junit.Test;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.mockito.Mockito.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameTest</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> NumberGenerator numberGenerator;</div><div class="line">    <span class="keyword">private</span> NumberReader numberReader;</div><div class="line">    <span class="keyword">private</span> Printer printer;</div><div class="line">    <span class="keyword">private</span> Game game;</div><div class="line"></div><div class="line">    <span class="meta">@Before</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="comment">//我们以mock方式生成了:</span></div><div class="line">        numberGenerator = mock(NumberGenerator.class);</div><div class="line">        numberReader = mock(NumberReader.class);</div><div class="line">        printer = mock(Printer.class);</div><div class="line">      <span class="comment">//我们给定generate的返回值必须是4879，因为随机生成一个数字可就不好写expected值了</span></div><div class="line">        when(numberGenerator.generate()).thenReturn(<span class="string">"4879"</span>);</div><div class="line">        game = <span class="keyword">new</span> Game(numberGenerator, printer, numberReader);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后我们可以写一些简单测试，来体验一下mock的作用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldPrintYouWin</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    when(numberReader.read()).thenReturn(<span class="string">"4879"</span>);</div><div class="line">    game.start();</div><div class="line">  <span class="comment">//使用verify可以在白盒情况下审视代码逻辑是不是正常运转</span></div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"please input a 4 digit number:"</span>);</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"you win"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldPrintYouWinAfterFifthAttempts</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  <span class="comment">//mockito支持我们每次返回不同的值</span></div><div class="line">    when(numberReader.read()).thenReturn(<span class="string">"7849"</span>,<span class="string">"7849"</span>,<span class="string">"7849"</span>,<span class="string">"7849"</span>,<span class="string">"7849"</span>,<span class="string">"4879"</span>);</div><div class="line">    game.start();</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"please input a 4 digit number:"</span>);</div><div class="line">    verify(printer, times(<span class="number">5</span>)).print(<span class="string">"2A2B"</span>);</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"you win"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldPrintYouWinAfterSecondAttempts</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    when(numberReader.read()).thenReturn(<span class="string">"7849"</span>,<span class="string">"4879"</span>);</div><div class="line">    game.start();</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"please input a 4 digit number:"</span>);</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"2A2B"</span>);</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"you win"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldPrintGameOver</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    when(numberReader.read()).thenReturn(<span class="string">"7849"</span>);</div><div class="line">    game.start();</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"please input a 4 digit number:"</span>);</div><div class="line">    verify(printer, times(<span class="number">6</span>)).print(<span class="string">"2A2B"</span>);</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"Game Over"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Test</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shouldRunNormallyAfterThrowsException</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">  <span class="comment">//我们还可以设定抛出异常</span></div><div class="line">    when(numberReader.read()).thenThrow(<span class="keyword">new</span> IOException(<span class="string">"IO Exception Test"</span>))</div><div class="line">            .thenReturn(<span class="string">"7849"</span>,<span class="string">"7849"</span>,<span class="string">"7849"</span>,<span class="string">"7849"</span>,<span class="string">"7849"</span>,<span class="string">"4879"</span>);</div><div class="line">    game.start();</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"please input a 4 digit number:"</span>);</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"IO Exception Test"</span>);</div><div class="line">    verify(printer, times(<span class="number">5</span>)).print(<span class="string">"2A2B"</span>);</div><div class="line">    verify(printer, times(<span class="number">1</span>)).print(<span class="string">"you win"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当然上面这些简单的mock，我们也可以手动给它以代理方式写出来，有利于我们理解mockito这类框架的实际工作方式，感兴趣的朋友可以写写看，我这里就不写了~</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  就像上篇文章所说，我们还可以用mock方式模拟一个没有完成的模块，从而完成测试，事实上如果测试的业务比较繁琐，比如涉及到输入啥的，我们也可以mock一个假的输入对象，mock object是在极限编程里提出的，而今天它已经广泛用于软件测试领域。&lt;/p&gt;
&lt;p&gt;  就如mock这个单词的词义一样，mock object即是一个模制的对象，但这个对象的行为是人为故意给定的，不包含实际的业务。这样说可能非常抽象，如果让我们考虑用&lt;strong&gt;Scala&lt;/strong&gt;写一个在商店里用pos机刷卡的例子,比如我们刷卡并且输入密码后会构造出这样的一个CreditCard对象：&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CreditCard&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;val cardId:&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;,val password:&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; 而我们的Pos机要负责转账处理：&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Pos&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;transfer&lt;/span&gt;&lt;/span&gt;(amount:&lt;span class=&quot;type&quot;&gt;Double&lt;/span&gt;,creditCard: &lt;span class=&quot;type&quot;&gt;CreditCard&lt;/span&gt;, creditCard2: &lt;span class=&quot;type&quot;&gt;CreditCard&lt;/span&gt;, accountManager: &lt;span class=&quot;type&quot;&gt;AccountManager&lt;/span&gt;): &lt;span class=&quot;type&quot;&gt;Unit&lt;/span&gt; = &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; account1: &lt;span class=&quot;type&quot;&gt;Account&lt;/span&gt; = accountManager.findAccount(creditCard.cardId, creditCard.password);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; account2: &lt;span class=&quot;type&quot;&gt;Account&lt;/span&gt; = accountManager.findAccount(creditCard2.cardId, creditCard2.password);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    accountManager.saveAccount(account1.copy(account1.balance - amount,account1.creditCard))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    accountManager.saveAccount(account2 copy(account2.balance + amount, account2.creditCard))&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;  &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;，但是问题是此时我们根本没有构造号银行卡账户数据库，甚至我们连dao对象都只是一个接口，那么为了测试Pos代码逻辑能不能正确执行我们该怎么办呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://yoursite.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="软件测试" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    
      <category term="TDD" scheme="http://yoursite.com/tags/TDD/"/>
    
      <category term="Junit" scheme="http://yoursite.com/tags/Junit/"/>
    
  </entry>
  
</feed>
